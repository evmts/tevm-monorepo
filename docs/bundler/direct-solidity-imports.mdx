# Direct Solidity Imports

One of Tevm's most powerful features is the ability to import Solidity contracts directly into your TypeScript/JavaScript code. This creates a seamless development experience with full type safety and IDE integration.

## Overview

Tevm's bundler integration allows you to:

- Import `.sol` files directly in your TS/JS code
- Automatically compile Solidity at build time
- Get full TypeScript type safety for contract interactions
- See Natspec comments when hovering over contract methods
- Use go-to-definition to navigate from TS to Solidity
- Benefit from auto-imports in supported editors

This creates a tight feedback loop between writing Solidity and frontend code, making it easier to build Ethereum applications with better developer experience.

## Setting Up Direct Solidity Imports

Setting up Tevm for direct Solidity imports involves two main steps:

1. Configure your TypeScript compiler
2. Set up your bundler (Vite, Webpack, etc.)

### TypeScript Configuration

To enable TypeScript support for direct Solidity imports, you need to configure the Tevm TypeScript plugin in your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "@tevm/ts-plugin"
      }
    ],
    // Other TypeScript options...
  }
}
```

### Bundler Configuration

Tevm supports most popular JavaScript bundlers. Below are configurations for the most common ones:

::::steps

#### Vite

:::code-group
```ts [vite.config.ts]
import { defineConfig } from 'vite'
import { vitePluginTevm } from '@tevm/vite'

export default defineConfig({
  plugins: [
    // Other plugins...
    vitePluginTevm(),
  ],
})
```
:::

#### Webpack

:::code-group
```js [webpack.config.js]
const { tevmPlugin } = require('@tevm/webpack')

module.exports = {
  // Other webpack config
  plugins: [
    // Other plugins...
    tevmPlugin(),
  ],
}
```
:::

#### Bun

:::code-group
```ts [plugins.ts]
import { plugin } from 'bun'
import { tevmBunPlugin } from '@tevm/bun'

plugin(tevmBunPlugin({}))
```
:::

Then in your `bunfig.toml`:

```toml [bunfig.toml]
preload = ["./plugins.ts"]

[test]
preload = ["./plugins.ts"]
```

#### ESBuild

:::code-group
```js [build.js]
const { build } = require('esbuild')
const { esbuildPluginTevm } = require('@tevm/esbuild')

build({
  // Other esbuild options
  plugins: [
    // Other plugins...
    esbuildPluginTevm(),
  ],
})
```
:::

#### Rollup

:::code-group
```js [rollup.config.js]
import { rollupPluginTevm } from '@tevm/rollup'

export default {
  // Other rollup options
  plugins: [
    // Other plugins...
    rollupPluginTevm(),
  ],
}
```
:::

#### Next.js

:::code-group
```js [next.config.js]
const { withTevm } = require('@tevm/next-plugin')

module.exports = withTevm({
  // Your Next.js config
})
```
:::

**Important Note for Next.js:** You'll need to disable typechecking in builds while maintaining LSP support in your editor:

```js [next.config.js]
const { withTevm } = require('@tevm/next-plugin')

module.exports = withTevm({
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
})
```

::::

### Editor Integration

For optimal development experience, ensure your editor is using the workspace version of TypeScript:

- **VS Code**: Use the command palette (`Ctrl+Shift+P`) and select "TypeScript: Select TypeScript Version" â†’ "Use Workspace Version"
- **Cursor**: Similar to VS Code, select the workspace TypeScript version
- **Vim/Neovim with LSP**: Configure your LSP to use the workspace TypeScript version

## Using Direct Solidity Imports

Once configured, you can import Solidity contracts directly:

```ts
// Import the contract directly from a .sol file
import { Counter } from './Counter.sol'

// Use the contract with full type safety
const count = await Counter.read.count()
const tx = await Counter.write.increment()
```

### The Tevm Contract System

When you import a Solidity file, Tevm's bundler plugins compile the contract at build time and transform it into a [Tevm Contract](https://tevm.sh/reference/contract) instance. This is a powerful abstraction that provides type-safe access to your contract's methods and events.

```ts
// Import a Solidity contract directly
import { Counter } from './Counter.sol'

// Counter is now a Tevm Contract instance with the following structure:
// {
//   abi: [...],                 // The contract ABI
//   bytecode: '0x...',          // The contract creation bytecode
//   deployedBytecode: '0x...',  // The runtime bytecode
//   read: {                     // Read methods (view/pure functions)
//     count: () => {...},       // Type-safe method with parameters and return type from Solidity
//   },
//   write: {                    // Write methods (state-changing functions)
//     increment: () => {...},
//   },
//   events: {                   // Contract events
//     CountIncremented: (...) => {...},
//   },
//   withAddress: (address) => {...},  // Returns a new contract instance with the given address
//   withCode: (code) => {...},        // Returns a new contract instance with the given bytecode
// }
```

The Tevm Contract provides a consistent, type-safe API regardless of how the contract was created - whether imported directly from Solidity, created from an ABI, or loaded from an existing deployment.

### Integration with Popular Libraries

Tevm contracts work seamlessly with popular Ethereum libraries like Wagmi, Viem, Ethers.js, or any other JavaScript library that accepts ABIs. Here's an example using Wagmi:

```tsx
import { useContractRead, useContractWrite } from 'wagmi'
import { MyToken } from './contracts/MyToken.sol'

// In your React component
function TokenBalance({ address }) {
  // Read operations - notice we spread the contract method call which includes ABI, function name, and args
  const { data: balance } = useContractRead({
    ...MyToken.read.balanceOf(address),
    address: '0x1234...', // Contract address
    enabled: Boolean(address),
  })

  // Write operations
  const { write: transfer } = useContractWrite({
    address: '0x1234...',
    ...MyToken.write.transfer, // Just passing the function reference (not calling it)
  })

  return (
    <div>
      <div>Balance: {balance?.toString()}</div>
      <button onClick={() => 
        // Call the function when needed with arguments
        transfer(MyToken.write.transfer('0xRecipient...', 1000n))
      }>
        Transfer
      </button>
    </div>
  )
}
```

The same pattern works with Viem, Ethers.js, or any other library - the imported Solidity contracts provide standard ABI structures that all Ethereum libraries understand.

### Contract Interactions

Tevm provides a consistent, type-safe API for contract interactions:

```ts
// Read operations
const value = await Contract.read.getValue()
const balance = await Contract.read.balanceOf(address)

// Write operations (transactions)
const tx = await Contract.write.setValue(42)
const mintTx = await Contract.write.mint(address, tokenId)

// Deployment
const deployed = await Contract.deploy({
  args: [initialValue],
})
```

### Solidity Import Resolution

Tevm supports importing from:

- Local `.sol` files in your project
- Dependencies in `node_modules` (like OpenZeppelin contracts)
- Core libraries and interfaces

For example, in your Solidity file:

```solidity
// Local imports
import "./interfaces/IERC20.sol";

// npm package imports
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
```

## Example: Counter Contract

Here's a complete example using a simple Counter contract:

::::steps

#### Define your Solidity contract

:::code-group
```solidity [Counter.sol]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title A simple counter contract
/// @notice You can use this contract for only the most basic simulation
contract Counter {
    uint256 private count = 0;
    
    /// @notice Increment the counter by 1
    function increment() public {
        count += 1;
    }
    
    /// @notice Get the current count
    /// @return The current count value
    function count() public view returns (uint256) {
        return count;
    }
}
```
:::

#### Use it in your TypeScript file

:::code-group
```ts [app.ts]
import { Counter } from './Counter.sol'
import { createMemoryClient } from 'tevm'

async function main() {
  // Create a memory client for local testing
  const client = createMemoryClient()
  
  // Deploy the contract
  const deployed = await client.deployContract(Counter)
  console.log(`Counter deployed at: ${deployed.address}`)
  
  // Read the initial count
  const initialCount = await deployed.read.count()
  console.log(`Initial count: ${initialCount}`)
  
  // Increment the counter
  const tx = await deployed.write.increment()
  await client.mine({ blocks: 1 })
  
  // Read the updated count
  const newCount = await deployed.read.count()
  console.log(`New count: ${newCount}`)
}

main().catch(console.error)
```
:::

::::

## Advanced Features

### NatSpec Documentation

Tevm preserves NatSpec comments from your Solidity contracts in the TypeScript types. Hover over contract methods in your editor to see descriptions:

```solidity
/// @notice This transfers tokens to a recipient
/// @param to The address to transfer to
/// @param amount The amount of tokens to transfer
/// @return success Whether the transfer succeeded
function transfer(address to, uint256 amount) external returns (bool success);
```

### Go-to-Definition

In supported editors, you can navigate between your TypeScript code and Solidity:

- When you use `Contract.read.methodName`, "Go to Definition" will take you to the Solidity method
- This works for both read and write operations

### Hot Module Reloading

Tevm supports Hot Module Reloading (HMR) for Solidity contracts in supported bundlers:

- Changes to Solidity are reflected immediately in the browser
- Type errors appear in real-time
- No need to restart your development server

## Configuring Tevm

Tevm bundler plugins and the TypeScript plugin can be configured using a `tevm.config.json` file in your project root. This allows you to customize the Solidity compilation and import resolution process.

### tevm.config.json

Create a `tevm.config.json` file in your project root with the following options:

```json
{
  // Enable Foundry integration (boolean or path to foundry.toml)
  "foundryProject": true,
  
  // Custom library paths for Solidity imports
  "libs": ["lib", "node_modules"],
  
  // Custom import remappings (similar to Foundry remappings)
  "remappings": {
    "foo": "vendored/foo",
    "@openzeppelin/": "node_modules/@openzeppelin/"
  },
  
  // Enable debug logging
  "debug": false,
  
  // Custom cache directory (defaults to .tevm)
  "cacheDir": ".tevm"
}
```

### Foundry Integration

Tevm works seamlessly with [Foundry](https://book.getfoundry.sh/) projects. When `foundryProject` is set to `true` (or a path to your foundry.toml), Tevm will:

1. Use Foundry's remappings for resolving imports
2. Read Solidity compiler version from Foundry configuration
3. Use Foundry's library paths

This makes it easy to use the same contracts in both Foundry tests and your frontend code.

### Custom Solc Version

Each bundler plugin accepts a `solc` option to specify a custom Solidity compiler version:

```js
// package.json: { "type": "module" }
import { vitePluginTevm } from '@tevm/vite'

export default {
  plugins: [
    vitePluginTevm({
      solc: '0.8.20' // Use a specific solc version
    })
  ]
}
```

## Troubleshooting

### TypeScript LSP Not Working

If you're not seeing type information for Solidity imports:

1. Make sure your editor is using the workspace version of TypeScript
2. Verify that `@tevm/ts-plugin` is correctly configured in your tsconfig.json
3. Try restarting your TypeScript language server
4. Check that you have the latest version of TypeScript installed (minimum: 4.9.x)

### Bundler Issues

If you're encountering bundling errors:

1. Check that you've installed the correct bundler plugin for Tevm
2. Verify your bundler configuration matches the examples
3. Make sure you're using a compatible Solidity version
4. Check that your package.json has `"type": "module"` for ES modules
5. Confirm your imports use the proper syntax for your module system

### Cache Issues

If you're experiencing unexpected behavior after changing Solidity files:

1. Try clearing the cache by deleting the `.tevm` directory
2. Make sure you're not using an incompatible version of solc
3. Restart your development server

## Need Help?

If your specific setup isn't covered here or you're having issues:

- Check the [example projects](https://github.com/evmts/tevm-monorepo/tree/main/examples) for working configurations
- [Open an issue](https://github.com/evmts/tevm-monorepo/issues) with details about your setup
- Most bundlers can be supported - reach out if yours isn't on the list