# 4.9 no_std Compatibility

REVM provides robust support for `no_std` environments, enabling Ethereum VM execution in constrained environments such as WebAssembly modules, embedded systems, and bare-metal applications. This reference document covers REVM's `no_std` compatibility features, configuration options, and best practices.

## Understanding `no_std`

In Rust, the `std` library provides functionality that depends on operating system features, such as:

- Heap memory allocation (`Vec`, `Box`, `String`, etc.)
- Threading and concurrency primitives
- File system and I/O operations
- Network functionality
- Operating system interfaces

The `no_std` attribute indicates that a crate doesn't depend on the standard library, making it suitable for environments where the standard library isn't available or desired.

```rust
#![no_std]
// This crate doesn't use the standard library
```

## REVM `no_std` Support

REVM is designed with a modular architecture that allows core EVM execution with minimal dependencies. The crate can be configured to work in `no_std` environments with appropriate feature flags.

### Core Features

REVM supports `no_std` execution with the following feature configuration:

```toml
[dependencies]
revm = { version = "3.3.0", default-features = false, features = ["no_std"] }
```

With this configuration, REVM:

1. Doesn't depend on the Rust standard library
2. Uses the `alloc` crate for memory allocation
3. Disables features requiring OS support
4. Provides a minimal but complete EVM implementation

### Available Functionality in `no_std` Mode

Even in `no_std` mode, REVM provides:

- Full EVM execution engine
- Complete instruction set implementation
- Basic precompiled contracts
- Memory and stack management
- Gas accounting
- Core state transitions

### Limitations in `no_std` Mode

Some features are not available or have reduced functionality:

- No file system access for state storage
- Limited or no networking capabilities
- No standard library data structures
- No operating system time functions
- No threading or concurrency primitives

## Configuration for `no_std`

### Cargo Features

REVM provides several features to customize its behavior in `no_std` environments:

```toml
[dependencies]
revm = { 
    version = "3.3.0", 
    default-features = false, 
    features = [
        "no_std",       # Enable no_std compatibility
        "with_alloc",   # Use alloc crate for memory allocation
        "c-secp256k1",  # Use the C implementation of secp256k1 (smaller code size)
        "parity-scale", # Use parity-scale-codec for serialization
    ] 
}
```

### Memory Management

In `no_std` mode, REVM uses the `alloc` crate for memory management:

```rust
extern crate alloc;

use alloc::vec::Vec;
use alloc::string::String;
use alloc::boxed::Box;
```

REVM is designed to be conservative with memory usage, with options to control allocation:

```rust
// Configure memory limits
let cfg = CfgEnv {
    memory_limit: Some(10 * 1024 * 1024), // 10 MB memory limit
    max_contract_size: Some(0x6000),      // Match mainnet limit
    ..Default::default()
};
```

## Core Components for `no_std`

### State Management

In `no_std` environments, REVM provides specialized state implementations:

#### InMemory Database

A fully in-memory state database suitable for `no_std`:

```rust
use revm::db::{InMemoryDB, Database};
use revm::primitives::{Address, U256, Bytes};

// Create an in-memory database
let mut db = InMemoryDB::new();

// Set account data
let address = Address::from([0x42; 20]);
let code = Bytes::from([0x60, 0x01, 0x60, 0x02, 0x01, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xf3]);

// Insert account with code
db.insert_account_info(
    address,
    AccountInfo {
        balance: U256::from(1000000000),
        nonce: 0,
        code_hash: keccak256(&code),
        code: Some(code),
    },
);
```

#### BundledDB

A database with pre-bundled state suitable for constrained environments:

```rust
use revm::db::BundledDB;

// Create a pre-populated database with bundled state
let bundled_db = BundledDB::new();

// The database contains pre-loaded contracts
// This is useful for WASM or embedded environments where
// you want to minimize runtime state loading
```

### Transaction Execution

Executing transactions in `no_std` mode:

```rust
use revm::{EVM, EvmBuilder};
use revm::primitives::{TransactTo, Bytes, U256};

// Create a minimal EVM instance
let mut evm = EvmBuilder::default()
    .with_db(InMemoryDB::new())
    .build();

// Configure the transaction
let tx = TxEnv {
    caller: Address::from([0x20; 20]),
    transact_to: TransactTo::Call(Address::from([0x42; 20])),
    value: U256::from(1000),
    data: Bytes::from([0xd0, 0xe3, 0x0d, 0xb0]), // Function selector
    gas_limit: 21000,
    gas_price: U256::from(1),
    ..Default::default()
};

// Set transaction parameters
evm.env.tx = tx;

// Execute the transaction
let result = evm.transact()?;

// Process results
let gas_used = result.gas_used;
let output = result.output;
```

## Custom Allocators

For extremely constrained environments, you may need to provide a custom allocator:

```rust
#![no_std]
extern crate alloc;

// Import a custom allocator crate
extern crate wee_alloc;

// Use wee_alloc as the global allocator
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// Now use REVM with minimal memory overhead
use revm::EVM;
// ...
```

Common allocators for constrained environments:
- `wee_alloc`: Designed for WebAssembly, optimized for small code size
- `linked_list_allocator`: Simple but efficient for embedded systems
- `dlmalloc`: Port of Doug Lea's malloc, good general-purpose allocator
- `rpmalloc`: High-performance memory allocator

## Serialization in `no_std`

For serialization in `no_std` environments, REVM provides options:

### Scale Codec

Using Parity Scale Codec for compact serialization:

```rust
// Enable the parity-scale feature
// revm = { version = "3.3.0", features = ["no_std", "parity-scale"] }

use revm::primitives::Bytes;
use parity_scale_codec::{Encode, Decode};

// Serialize state data
let encoded = account_info.encode();

// Store the minimal encoded representation
let bytes = Bytes::from(encoded);

// Later, decode when needed
let decoded = AccountInfo::decode(&mut &bytes[..]).unwrap();
```

## No-OS Clock and Randomness

In `no_std` environments, REVM provides alternatives for time and randomness:

### Monotonic Counters

For nonces and timestamps when no OS clock is available:

```rust
// Simple monotonic counter
struct MonotonicCounter(u64);

impl MonotonicCounter {
    fn new() -> Self {
        Self(0)
    }
    
    fn next(&mut self) -> u64 {
        let current = self.0;
        self.0 = self.0.wrapping_add(1);
        current
    }
}

// Use for block timestamps
let mut counter = MonotonicCounter::new();
evm.env.block.timestamp = counter.next();
```

### Deterministic Randomness

For environments without entropy sources:

```rust
use revm::primitives::{keccak256, Bytes, U256};

// Create deterministic "randomness" from an initial seed
fn deterministic_random(seed: &[u8], idx: u64) -> U256 {
    let mut input = seed.to_vec();
    input.extend_from_slice(&idx.to_be_bytes());
    let hash = keccak256(&input);
    U256::from_be_bytes(hash)
}

// Generate a sequence of deterministic values
let seed = b"my_application_seed";
let random_value_1 = deterministic_random(seed, 1);
let random_value_2 = deterministic_random(seed, 2);
```

## WebAssembly Compatibility

REVM can be compiled to WebAssembly for browser or Node.js usage:

### WASM Configuration

```toml
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
revm = { version = "3.3.0", default-features = false, features = ["no_std", "with_alloc"] }
wasm-bindgen = "0.2"
```

### JavaScript Bindings

```rust
use wasm_bindgen::prelude::*;
use revm::{EVM, EvmBuilder};
use revm::primitives::{Bytes, U256, Address};

#[wasm_bindgen]
pub struct RevmWasm {
    evm: EVM<InMemoryDB>,
}

#[wasm_bindgen]
impl RevmWasm {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        // Initialize REVM for WASM
        let evm = EvmBuilder::default()
            .with_db(InMemoryDB::new())
            .build();
            
        Self { evm }
    }
    
    #[wasm_bindgen]
    pub fn execute(&mut self, to: &[u8], data: &[u8], value: &str) -> Result<String, JsValue> {
        // Parse parameters
        let to_address = Address::from_slice(to);
        let call_data = Bytes::from(data.to_vec());
        let eth_value = U256::from_dec_str(value).map_err(|e| JsValue::from_str(&e.to_string()))?;
        
        // Configure transaction
        self.evm.env.tx.transact_to = TransactTo::Call(to_address);
        self.evm.env.tx.data = call_data;
        self.evm.env.tx.value = eth_value;
        
        // Execute the call
        let result = self.evm.transact().map_err(|e| JsValue::from_str(&e.to_string()))?;
        
        // Return result as hex string
        Ok(format!("0x{}", hex::encode(&result.output)))
    }
    
    // Additional WASM interface methods...
}
```

## Embedded Systems Integration

REVM can be integrated with embedded systems for blockchain applications:

### Resource Constraints

Consider these optimizations for embedded environments:

1. **Code Size**: Minimize compiled binary size
   ```toml
   [profile.release]
   opt-level = "z"       # Optimize for size
   lto = true            # Link-time optimization
   codegen-units = 1     # Maximize size reduction
   panic = "abort"       # Remove panic unwinding code
   strip = true          # Strip symbols
   ```

2. **Memory Usage**: Limit heap allocations
   ```rust
   // Configure strict memory limits
   let cfg = CfgEnv {
       memory_limit: Some(1 * 1024 * 1024), // 1 MB memory limit
       call_stack_limit: 10,                // Limit call stack depth
       ..Default::default()
   };
   
   // Use arena-based allocators for temporary allocations
   // Implement custom inspector to monitor memory usage
   ```

3. **Execution Limits**: Prevent resource exhaustion
   ```rust
   // Set tight execution constraints
   evm.env.cfg.memory_limit = Some(256 * 1024);
   evm.env.cfg.max_steps = Some(100_000);
   ```

### Bare-Metal Example

A minimal example for bare-metal systems:

```rust
#![no_std]
#![no_main]

extern crate alloc;
extern crate panic_halt;  // Panic handler for embedded systems

use cortex_m_rt::entry;   // Entry point for Cortex-M microcontrollers
use alloc::boxed::Box;
use linked_list_allocator::LockedHeap;

// Define a global allocator with a fixed heap size
#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();

#[entry]
fn main() -> ! {
    // Initialize heap (e.g., 32KB)
    let heap_start = 0x20000000 as *mut u8;
    let heap_size = 32 * 1024;
    unsafe { ALLOCATOR.lock().init(heap_start, heap_size); }
    
    // Create minimal REVM instance
    let mut evm = EvmBuilder::default()
        .with_db(InMemoryDB::new())
        .build();
    
    // Configure a simple contract execution
    evm.env.tx.transact_to = TransactTo::Call(Address::from([0x42; 20]));
    evm.env.tx.data = Bytes::from([0x60, 0x01, 0x60, 0x02, 0x01, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xf3]);
    
    // Execute
    let result = evm.transact().unwrap_or_else(|_| panic!());
    
    // Process result (e.g., write to a hardware output)
    let output = result.output;
    
    // In embedded systems, typically enter an infinite loop at the end
    loop {
        // Process further transactions or enter low-power mode
    }
}
```

## Testing in `no_std` Environments

### Unit Testing

```rust
#![no_std]
#![cfg_attr(test, no_main)]

#[cfg(test)]
extern crate alloc;

#[cfg(test)]
use revm::{EVM, EvmBuilder};
#[cfg(test)]
use revm::primitives::*;

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_execution() {
        let mut evm = EvmBuilder::default()
            .with_db(InMemoryDB::new())
            .build();
            
        // Add test contract
        let contract = Bytes::from([0x60, 0x01, 0x60, 0x02, 0x01, 0x60, 0x00, 0x52, 0x60, 0x20, 0x60, 0x00, 0xf3]);
        let address = Address::from([0x42; 20]);
        
        evm.db().insert_account_info(
            address,
            AccountInfo {
                balance: U256::from(1),
                nonce: 0,
                code_hash: keccak256(&contract),
                code: Some(contract),
            },
        );
        
        // Set up transaction
        evm.env.tx.transact_to = TransactTo::Call(address);
        evm.env.tx.data = Bytes::new();
        
        // Execute
        let result = evm.transact().unwrap();
        
        // Verify result (output should be 0x0000...0003)
        assert_eq!(result.output.len(), 32);
        assert_eq!(result.output[31], 3);
    }
}
```

### Integration with Hardware-in-the-Loop Testing

For testing on real embedded hardware:

```rust
#[cfg(feature = "hardware_test")]
mod hardware_tests {
    use super::*;
    
    // Test that runs directly on target hardware
    #[test]
    fn test_evm_on_hardware() {
        // Initialize hardware-specific components
        let spi = setup_spi();
        let flash = setup_flash(spi);
        
        // Create a custom DB implementation that uses flash memory
        let db = FlashStorageDB::new(flash);
        
        // Run EVM with the hardware-backed database
        let mut evm = EvmBuilder::default()
            .with_db(db)
            .build();
            
        // Execute test transactions
        let result = evm.transact().unwrap();
        
        // Verify results
        assert!(result.is_success());
    }
}
```

## Performance Optimizations for Constrained Systems

### Memory Pooling

Reduce allocation overhead with memory pooling:

```rust
use alloc::boxed::Box;

// Simple memory pool for frequently used objects
struct BytesPool {
    pool: [Option<Box<[u8; 32]>>; 10],
}

impl BytesPool {
    fn new() -> Self {
        // Initialize with empty slots
        Self {
            pool: Default::default(),
        }
    }
    
    fn get(&mut self) -> Box<[u8; 32]> {
        // Try to reuse from pool
        for slot in &mut self.pool {
            if let Some(bytes) = slot.take() {
                return bytes;
            }
        }
        
        // Create new if pool is empty
        Box::new([0u8; 32])
    }
    
    fn release(&mut self, bytes: Box<[u8; 32]>) {
        // Find empty slot and return bytes to pool
        for slot in &mut self.pool {
            if slot.is_none() {
                *slot = Some(bytes);
                return;
            }
        }
        
        // If pool is full, the box will be dropped
    }
}
```

### Minimizing Call Depth

Deep call stacks can be problematic in constrained environments:

```rust
// Configure EVM to limit call depth
evm.env.cfg.call_stack_limit = 5;

// Implement call depth monitoring inspector
struct CallDepthInspector {
    max_depth_seen: usize,
    current_depth: usize,
}

impl Inspector for CallDepthInspector {
    fn call(
        &mut self,
        _context: &Context,
        _call: &Call,
        _gas: u64,
    ) -> Option<(InstructionResult, Gas, Bytes)> {
        self.current_depth += 1;
        self.max_depth_seen = self.max_depth_seen.max(self.current_depth);
        None
    }
    
    fn call_end(
        &mut self,
        _context: &Context,
        _call: &Call,
        gas: u64,
        result: InstructionResult,
        return_data: &Bytes,
    ) -> (InstructionResult, Gas, Bytes) {
        self.current_depth -= 1;
        (result, gas, return_data.clone())
    }
}
```

## Custom Database Implementations

For `no_std` environments, you might need custom database implementations suited to your hardware:

### Flash Memory Database

```rust
use revm::db::Database;
use revm::primitives::*;

// Database using embedded flash memory
pub struct FlashDB<F> {
    flash: F,
    cache: HashMap<Address, AccountInfo>,
}

impl<F: FlashStorage> FlashDB<F> {
    pub fn new(flash: F) -> Self {
        Self {
            flash,
            cache: HashMap::new(),
        }
    }
    
    // Helper to read from flash with caching
    fn read_account(&mut self, address: &Address) -> Option<AccountInfo> {
        // Check cache first
        if let Some(info) = self.cache.get(address) {
            return Some(info.clone());
        }
        
        // Try to read from flash
        if let Some(data) = self.flash.read_account(address) {
            let info: AccountInfo = deserialize(&data)?;
            self.cache.insert(*address, info.clone());
            return Some(info);
        }
        
        None
    }
}

impl<F: FlashStorage> Database for FlashDB<F> {
    fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, DatabaseError> {
        Ok(self.read_account(&address))
    }
    
    fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytes, DatabaseError> {
        self.flash.read_code(&code_hash)
            .ok_or(DatabaseError::MissingCode(code_hash))
    }
    
    fn storage(
        &mut self,
        address: Address,
        index: U256,
    ) -> Result<U256, DatabaseError> {
        Ok(self.flash.read_storage(&address, &index).unwrap_or_default())
    }
    
    fn block_hash(&mut self, number: U256) -> Result<B256, DatabaseError> {
        Ok(self.flash.read_block_hash(&number).unwrap_or_default())
    }
}

// Trait for flash storage operations
pub trait FlashStorage {
    fn read_account(&self, address: &Address) -> Option<Vec<u8>>;
    fn read_code(&self, code_hash: &B256) -> Option<Bytes>;
    fn read_storage(&self, address: &Address, index: &U256) -> Option<U256>;
    fn read_block_hash(&self, number: &U256) -> Option<B256>;
    
    fn write_account(&mut self, address: &Address, account: &AccountInfo) -> Result<(), FlashError>;
    fn write_code(&mut self, code_hash: &B256, code: &Bytes) -> Result<(), FlashError>;
    fn write_storage(&mut self, address: &Address, index: &U256, value: &U256) -> Result<(), FlashError>;
    fn write_block_hash(&mut self, number: &U256, hash: &B256) -> Result<(), FlashError>;
}
```

## Best Practices for `no_std` Usage

1. **Minimize Allocations**: Reuse objects when possible
2. **Static Allocation**: Use const arrays and static buffers where appropriate
3. **Memory Ceilings**: Set strict limits on EVM memory usage
4. **Buffer sizing**: Pre-allocate buffers based on expected workloads
5. **Error Handling**: Use simplified error handling without panics
6. **Deterministic Logic**: Avoid unpredictable behavior in constrained environments
7. **Modular Features**: Only enable required REVM components
8. **State Management**: Implement state pruning and garbage collection
9. **Testing**: Test on the actual target environment
10. **Monitoring**: Implement resource usage tracking

### Example: Deterministic EVM Configuration

```rust
// Configure a deterministic EVM for no_std environments
fn create_deterministic_evm<DB: Database>(db: DB) -> EVM<DB> {
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .build();
        
    // Set strict, deterministic constraints
    evm.env.cfg = CfgEnv {
        memory_limit: Some(2 * 1024 * 1024),  // 2 MB max memory
        max_steps: Some(1_000_000),           // Limit execution steps
        call_stack_limit: 10,                 // Limit call depth
        create_contract_limit: Some(0x6000),  // EIP-170 contract size limit
        ..Default::default()
    };
    
    // Set fixed block parameters
    evm.env.block = BlockEnv {
        number: U256::from(1),
        timestamp: U256::from(1000),
        difficulty: U256::zero(),
        gas_limit: U256::from(30_000_000),
        basefee: U256::from(7),
        ..Default::default()
    };
    
    evm
}
```

## Conclusion

REVM's `no_std` compatibility makes it a versatile EVM implementation suitable for constrained environments like WebAssembly, embedded systems, and bare-metal applications. By carefully selecting features, implementing appropriate database backends, and following memory management best practices, you can integrate Ethereum VM functionality into a wide range of environments beyond traditional operating systems.

The modularity and configurability of REVM allow developers to make appropriate trade-offs between functionality, performance, and resource usage, making Ethereum-compatible execution available even in the most constrained computing environments.