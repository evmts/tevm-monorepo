# 3.5 Custom Tracing and Debugging with REVM

In this guide, we'll explore REVM's powerful tracing and debugging capabilities. REVM provides extensive instrumentation through its Inspector trait, allowing developers to trace execution, debug transactions, and gain deep insights into EVM behavior.

## Overview

The EVM's opaque execution model makes debugging smart contracts challenging. REVM solves this with its Inspector interface, enabling fine-grained tracing and inspection of every step in transaction execution.

In this guide, you'll learn:

1. How to implement custom inspectors for tracing execution
2. Techniques for collecting and analyzing execution data
3. Methods for debugging failed transactions
4. How to visualize execution flow
5. Practical examples of common debugging scenarios

## Prerequisites

- Understanding of REVM basics and transaction processing
- Familiarity with EVM opcodes and execution model
- Rust programming knowledge

## Basic Execution Tracing

Let's start with a simple example of tracing EVM execution:

```rust
use revm::{
    db::EthMemoryDB,
    primitives::{address, TransactTo, TxEnv, U256},
    EVM,
};
use revm::inspector::InspectorStack;
use revm::inspector::{Inspector, GasInspector, TracerEip3155};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Set up the EVM with an in-memory database
    let mut evm = EVM::new();
    let mut memory_db = EthMemoryDB::new();
    
    // Create a stack of inspectors
    let gas_inspector = GasInspector::new();
    let tracer = TracerEip3155::new();
    let inspector_stack = InspectorStack::new()
        .with_inspector(gas_inspector)
        .with_inspector(tracer);
    
    // Configure the EVM with our inspector stack
    evm.database(memory_db);
    evm.inspect(inspector_stack);
    
    // Set up a simple ETH transfer transaction
    let sender = address!("0x1000000000000000000000000000000000000000");
    let recipient = address!("0x2000000000000000000000000000000000000000");
    
    // Fund the sender account
    let sender_account = revm::primitives::AccountInfo::new(
        U256::from(10_000_000_000_000_000_u64), // 0.01 ETH
        0,
        None,
    );
    memory_db.insert_account_info(sender, sender_account);
    
    // Configure the transaction
    let mut tx_env = TxEnv::default();
    tx_env.caller = sender;
    tx_env.transact_to = TransactTo::Call(recipient);
    tx_env.value = U256::from(1_000_000_000_000_000_u64); // 0.001 ETH
    tx_env.gas_limit = 21000;
    
    evm.env.tx = tx_env;
    
    // Execute the transaction and capture the results
    let result = evm.transact()?;
    
    // Access the tracing information from our inspectors
    let inspector_stack = evm.take_inspector().unwrap();
    let (gas_inspector, tracer) = inspector_stack.inner();
    
    // Print gas information
    println!("Gas used: {}", result.gas_used());
    
    // Print trace information
    println!("Execution trace:");
    for (i, step) in tracer.steps().iter().enumerate() {
        println!("{}: pc={}, op={}, gas={}, stack_depth={}", 
            i, step.pc, step.op, step.gas, step.stack_depth);
    }
    
    Ok(())
}
```

This example shows how to use the built-in `TracerEip3155` inspector to capture a trace of the EVM execution. The trace includes information like program counter, opcode, gas, and stack depth at each step.

## Custom Inspector Implementation

While REVM provides built-in inspectors, you can also implement your own for specialized debugging needs:

```rust
use revm::inspector::{Inspector, InspectorData};
use revm::primitives::{Bytes, Eval, EVMError, Gas, Spec};
use revm::interpreter::{CallInputs, CreateInputs, GasInspector, InterpreterResult, OpCode};
use std::collections::HashMap;

/// A custom inspector that records detailed call information
#[derive(Debug, Default)]
struct CallTraceInspector {
    call_depth: usize,
    call_stack: Vec<String>,
    calls: HashMap<String, Vec<(String, String, U256)>>, // caller -> [(callee, function_sig, value)]
}

impl Inspector for CallTraceInspector {
    fn initialize_interp(&mut self, _data: InspectorData, _is_static: bool) -> Eval {
        self.call_depth = 0;
        Eval::Continue
    }

    fn step(&mut self, _data: InspectorData, _is_static: bool) -> Eval {
        Eval::Continue
    }

    fn step_end(&mut self, _data: InspectorData, _is_static: bool) -> Eval {
        Eval::Continue
    }

    fn call(
        &mut self,
        data: InspectorData,
        inputs: &CallInputs,
        _is_static: bool,
    ) -> (Eval, Gas) {
        self.call_depth += 1;
        
        let caller = format!("{:?}", inputs.context.caller);
        let callee = format!("{:?}", inputs.contract);
        
        // Extract the function signature (first 4 bytes of input)
        let function_sig = if inputs.input.len() >= 4 {
            format!("0x{}", hex::encode(&inputs.input.data()[..4]))
        } else {
            "0x".to_string()
        };
        
        // Record the call in our call stack
        let call_id = format!("{}:{}", self.call_depth, callee);
        self.call_stack.push(call_id.clone());
        
        // Add call to our calls map
        self.calls
            .entry(caller)
            .or_insert_with(Vec::new)
            .push((callee, function_sig, inputs.transfer.value));
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }

    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        _ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        self.call_stack.pop();
        self.call_depth -= 1;
        (Eval::Continue, remaining_gas)
    }

    fn create(
        &mut self,
        data: InspectorData,
        inputs: &CreateInputs,
    ) -> (Eval, Gas) {
        self.call_depth += 1;
        
        let creator = format!("{:?}", inputs.caller);
        let contract_addr = format!("NEW_CONTRACT_{}", self.call_depth);
        
        // Record creation in call stack
        let call_id = format!("{}:CREATE", self.call_depth);
        self.call_stack.push(call_id);
        
        // Record contract creation
        self.calls
            .entry(creator)
            .or_insert_with(Vec::new)
            .push((contract_addr, "CONTRACT_CREATION".to_string(), inputs.value));
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }

    fn create_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
        remaining_gas: Gas,
        _ret: InterpreterResult,
    ) -> (Eval, Gas) {
        self.call_stack.pop();
        self.call_depth -= 1;
        (Eval::Continue, remaining_gas)
    }
}

// Usage example
fn trace_contract_calls() -> Result<(), Box<dyn std::error::Error>> {
    // Set up EVM with our custom inspector
    let mut evm = EVM::new();
    let memory_db = EthMemoryDB::new();
    
    let call_trace_inspector = CallTraceInspector::default();
    evm.database(memory_db);
    evm.inspect(call_trace_inspector);
    
    // Set up a contract interaction transaction
    // ... configure transaction env ...
    
    // Execute and analyze results
    let result = evm.transact()?;
    let call_trace_inspector = evm.take_inspector().unwrap();
    
    // Print the call graph
    println!("Call Graph:");
    for (caller, calls) in &call_trace_inspector.calls {
        println!("From {}", caller);
        for (callee, function, value) in calls {
            println!("  â†’ To {} calling {} with {} wei", callee, function, value);
        }
    }
    
    Ok(())
}
```

This custom inspector tracks all contract calls during execution, building a call graph that helps visualize the interaction between contracts.

## Debugging Failed Transactions

One of the most powerful uses of REVM's inspector mechanism is debugging failed transactions. Here's how to identify exactly where and why a transaction fails:

```rust
use revm::inspector::{Inspector, InspectorData};
use revm::primitives::{Bytes, Eval, EVMError, Gas, Spec};
use revm::interpreter::{CallInputs, CreateInputs, InterpreterResult, OpCode};
use std::fmt;

#[derive(Debug, Default)]
struct FailureDebugger {
    execution_steps: Vec<ExecutionStep>,
    current_depth: usize,
    error_location: Option<ExecutionStep>,
}

#[derive(Debug, Clone)]
struct ExecutionStep {
    depth: usize,
    pc: usize,
    opcode: u8,
    opcode_name: String,
    stack: Vec<U256>,
    memory: Vec<u8>,
    contract_address: revm::primitives::Address,
}

impl Inspector for FailureDebugger {
    fn step(&mut self, data: InspectorData, _is_static: bool) -> Eval {
        let opcode = data.interp.contract.bytecode.bytecode()[data.interp.program_counter()];
        
        let step = ExecutionStep {
            depth: self.current_depth,
            pc: data.interp.program_counter(),
            opcode,
            opcode_name: revm::interpreter::opcode::OPCODE_JUMPMAP[opcode as usize].name.to_string(),
            stack: data.interp.stack.clone(),
            memory: data.interp.memory.data().to_vec(),
            contract_address: data.interp.contract.address,
        };
        
        self.execution_steps.push(step);
        Eval::Continue
    }
    
    fn call(&mut self, _data: InspectorData, _inputs: &CallInputs, _is_static: bool) -> (Eval, Gas) {
        self.current_depth += 1;
        (Eval::Continue, Gas::new(0))
    }
    
    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, _) = ret {
            // Save the last execution step before the revert
            if !self.execution_steps.is_empty() {
                self.error_location = Some(self.execution_steps.last().unwrap().clone());
            }
        }
        
        self.current_depth -= 1;
        (Eval::Continue, remaining_gas)
    }
    
    fn create_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, _) = ret {
            // Save the last execution step before the revert
            if !self.execution_steps.is_empty() {
                self.error_location = Some(self.execution_steps.last().unwrap().clone());
            }
        }
        
        self.current_depth -= 1;
        (Eval::Continue, remaining_gas)
    }
}

// Helper to decode revert reasons
fn decode_revert_reason(data: &[u8]) -> String {
    if data.len() < 4 {
        return "Unknown revert reason (no data)".to_string();
    }
    
    // Check if this is a standard Error(string) revert
    if &data[0..4] == &[0x08, 0xc3, 0x79, 0xa0] {
        // Error(string) selector
        if data.len() > 4 + 32 {
            // Try to decode the string
            let offset = U256::from_big_endian(&data[4..36]).as_usize();
            if offset == 32 && data.len() >= 4 + 32 + 32 {
                let str_len = U256::from_big_endian(&data[4+32..4+64]).as_usize();
                if 4 + 64 + str_len <= data.len() {
                    let str_data = &data[4+64..4+64+str_len];
                    if let Ok(reason) = String::from_utf8(str_data.to_vec()) {
                        return format!("Revert reason: {}", reason);
                    }
                }
            }
        }
    }
    
    format!("Unknown revert with data: 0x{}", hex::encode(data))
}

// Example of debugging a failing transaction
fn debug_failing_transaction() -> Result<(), Box<dyn std::error::Error>> {
    // Set up EVM with our debugging inspector
    let mut evm = EVM::new();
    let memory_db = EthMemoryDB::new();
    
    let failure_debugger = FailureDebugger::default();
    evm.database(memory_db);
    evm.inspect(failure_debugger);
    
    // Configure a transaction that will fail
    // ... set up transaction ...
    
    // Execute and analyze results
    let result = evm.transact()?;
    let failure_debugger = evm.take_inspector().unwrap();
    
    // Check if transaction reverted
    match result.result {
        revm::primitives::ExecutionResult::Revert { output, .. } => {
            println!("Transaction reverted!");
            println!("{}", decode_revert_reason(&output));
            
            if let Some(error_step) = failure_debugger.error_location {
                println!("\nExecution failed at:");
                println!("  Contract: {:?}", error_step.contract_address);
                println!("  PC: {}", error_step.pc);
                println!("  Opcode: {} (0x{:02x})", error_step.opcode_name, error_step.opcode);
                println!("  Call depth: {}", error_step.depth);
                
                println!("\nStack at revert point:");
                for (i, item) in error_step.stack.iter().enumerate() {
                    println!("  [{}]: {}", i, item);
                }
                
                // Print the last few execution steps for context
                println!("\nExecution steps leading to revert:");
                let start_idx = failure_debugger.execution_steps.len().saturating_sub(10);
                for (i, step) in failure_debugger.execution_steps.iter().enumerate().skip(start_idx) {
                    println!("  {}. [depth:{}] {}:{} (0x{:02x})", 
                        i, step.depth, step.pc, step.opcode_name, step.opcode);
                }
            }
        },
        _ => {
            println!("Transaction did not revert as expected");
        }
    }
    
    Ok(())
}
```

This example implements a specialized debugger that captures the execution state at the point of failure, helping to pinpoint exactly where and why a transaction reverted.

## Stack Trace Generation

Another valuable debugging tool is a stack trace generator that shows the call hierarchy when a transaction fails:

```rust
use revm::inspector::{Inspector, InspectorData};
use revm::primitives::{Bytes, Eval, EVMError, Gas, Spec};
use revm::interpreter::{CallInputs, CreateInputs, InterpreterResult, OpCode};
use std::collections::HashMap;

#[derive(Debug, Default)]
struct StackTraceInspector {
    call_stack: Vec<CallFrame>,
    contract_names: HashMap<revm::primitives::Address, String>,
    current_tx_revert: bool,
}

#[derive(Debug, Clone)]
struct CallFrame {
    caller: revm::primitives::Address,
    contract: revm::primitives::Address,
    function_sig: Option<[u8; 4]>,
    pc: usize,
    is_static: bool,
}

impl Inspector for StackTraceInspector {
    fn call(
        &mut self,
        data: InspectorData,
        inputs: &CallInputs,
        is_static: bool,
    ) -> (Eval, Gas) {
        let function_sig = if inputs.input.len() >= 4 {
            let mut sig = [0u8; 4];
            sig.copy_from_slice(&inputs.input.data()[..4]);
            Some(sig)
        } else {
            None
        };
        
        self.call_stack.push(CallFrame {
            caller: inputs.context.caller,
            contract: inputs.contract,
            function_sig,
            pc: data.interp.program_counter(),
            is_static,
        });
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }
    
    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, _) = ret {
            if self.call_stack.len() == 1 {
                // This is the top-level call, mark the transaction as reverted
                self.current_tx_revert = true;
            }
        }
        
        self.call_stack.pop();
        (Eval::Continue, remaining_gas)
    }
    
    fn create(
        &mut self,
        data: InspectorData,
        inputs: &CreateInputs,
    ) -> (Eval, Gas) {
        self.call_stack.push(CallFrame {
            caller: inputs.caller,
            contract: inputs.created_address,
            function_sig: None, // Contract creation has no function signature
            pc: data.interp.program_counter(),
            is_static: false,
        });
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }
    
    fn create_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, _) = ret {
            if self.call_stack.len() == 1 {
                // This is the top-level call, mark the transaction as reverted
                self.current_tx_revert = true;
            }
        }
        
        self.call_stack.pop();
        (Eval::Continue, remaining_gas)
    }
}

// Helper to resolve function signatures to names (simplified version)
fn resolve_function_sig(sig: &[u8; 4]) -> String {
    match sig {
        [0x70, 0xa0, 0x82, 0x31] => "balanceOf(address)".to_string(),
        [0xa9, 0x05, 0x9c, 0xbb] => "transfer(address,uint256)".to_string(),
        [0x09, 0x5e, 0xa7, 0xb3] => "approve(address,uint256)".to_string(),
        [0x23, 0xb8, 0x72, 0xdd] => "transferFrom(address,address,uint256)".to_string(),
        // Add more known signatures here
        _ => format!("0x{}", hex::encode(sig)),
    }
}

// Example of generating a stack trace for a failed transaction
fn generate_stack_trace() -> Result<(), Box<dyn std::error::Error>> {
    // Set up EVM with our stack trace inspector
    let mut evm = EVM::new();
    let memory_db = EthMemoryDB::new();
    
    // Populate contract names for better debugging
    let mut inspector = StackTraceInspector::default();
    inspector.contract_names.insert(
        address!("0x1234567890123456789012345678901234567890"),
        "TokenContract".to_string(),
    );
    inspector.contract_names.insert(
        address!("0x2345678901234567890123456789012345678901"),
        "VaultContract".to_string(),
    );
    
    evm.database(memory_db);
    evm.inspect(inspector);
    
    // Configure and execute a transaction that will fail
    // ... set up transaction ...
    
    let result = evm.transact()?;
    let inspector = evm.take_inspector().unwrap();
    
    // Generate a stack trace if the transaction reverted
    if inspector.current_tx_revert {
        println!("Transaction reverted with stack trace:");
        
        // Get revert data
        let revert_data = match &result.result {
            revm::primitives::ExecutionResult::Revert { output, .. } => output,
            _ => &[],
        };
        
        println!("Revert reason: {}", decode_revert_reason(revert_data));
        println!("\nCall stack at time of revert:");
        
        for (i, frame) in inspector.call_stack.iter().enumerate() {
            let contract_name = inspector.contract_names
                .get(&frame.contract)
                .cloned()
                .unwrap_or_else(|| format!("{:?}", frame.contract));
            
            let function_name = if let Some(sig) = frame.function_sig {
                resolve_function_sig(&sig)
            } else {
                "CONTRACT_CREATION".to_string()
            };
            
            println!("  {}. {} -> {}.{}{}",
                i,
                if i == 0 { "EOA".to_string() } else { format!("{:?}", frame.caller) },
                contract_name,
                function_name,
                if frame.is_static { " (static call)" } else { "" }
            );
        }
    } else {
        println!("Transaction did not revert");
    }
    
    Ok(())
}
```

This example creates a stack trace showing the entire call hierarchy at the point of failure, making it easier to understand complex contract interactions and identify where a transaction reverted.

## Visualizing Execution Flow

In addition to text-based tracing, it can be helpful to visualize execution flow. Here's an example that generates execution data that can be visualized:

```rust
use revm::inspector::{Inspector, InspectorData};
use revm::primitives::{Bytes, Eval, EVMError, Gas, Spec};
use revm::interpreter::{CallInputs, CreateInputs, InterpreterResult};
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

#[derive(Debug, Default)]
struct ExecutionVisualizer {
    steps: Vec<ExecutionNode>,
    current_depth: usize,
    current_call_id: usize,
    call_hierarchy: HashMap<usize, usize>, // call_id -> parent_call_id
}

#[derive(Debug, Clone)]
struct ExecutionNode {
    step_id: usize,
    call_id: usize,
    depth: usize,
    pc: usize,
    opcode: u8,
    opcode_name: String,
    gas_used: u64,
    contract: revm::primitives::Address,
    stack_size: usize,
}

impl Inspector for ExecutionVisualizer {
    fn step(&mut self, data: InspectorData, _is_static: bool) -> Eval {
        let opcode = data.interp.contract.bytecode.bytecode()[data.interp.program_counter()];
        
        self.steps.push(ExecutionNode {
            step_id: self.steps.len(),
            call_id: self.current_call_id,
            depth: self.current_depth,
            pc: data.interp.program_counter(),
            opcode,
            opcode_name: revm::interpreter::opcode::OPCODE_JUMPMAP[opcode as usize].name.to_string(),
            gas_used: data.gas.spent(),
            contract: data.interp.contract.address,
            stack_size: data.interp.stack.len(),
        });
        
        Eval::Continue
    }
    
    fn call(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        _is_static: bool,
    ) -> (Eval, Gas) {
        self.current_depth += 1;
        
        // Record call hierarchy
        let parent_call_id = self.current_call_id;
        self.current_call_id = self.call_hierarchy.len() + 1;
        self.call_hierarchy.insert(self.current_call_id, parent_call_id);
        
        (Eval::Continue, Gas::new(0))
    }
    
    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        _ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        self.current_depth -= 1;
        
        // Restore parent call id
        if let Some(&parent_id) = self.call_hierarchy.get(&self.current_call_id) {
            self.current_call_id = parent_id;
        }
        
        (Eval::Continue, remaining_gas)
    }
    
    fn create(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
    ) -> (Eval, Gas) {
        self.current_depth += 1;
        
        // Record call hierarchy for contract creation
        let parent_call_id = self.current_call_id;
        self.current_call_id = self.call_hierarchy.len() + 1;
        self.call_hierarchy.insert(self.current_call_id, parent_call_id);
        
        (Eval::Continue, Gas::new(0))
    }
    
    fn create_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
        remaining_gas: Gas,
        _ret: InterpreterResult,
    ) -> (Eval, Gas) {
        self.current_depth -= 1;
        
        // Restore parent call id
        if let Some(&parent_id) = self.call_hierarchy.get(&self.current_call_id) {
            self.current_call_id = parent_id;
        }
        
        (Eval::Continue, remaining_gas)
    }
    
    // Export execution trace to JSON for visualization
    fn export_json(&self, file_path: &str) -> std::io::Result<()> {
        use serde::{Serialize, Serializer};
        use serde_json::json;
        
        #[derive(Serialize)]
        struct Node {
            id: usize,
            call_id: usize,
            depth: usize,
            pc: usize,
            opcode: String,
            #[serde(serialize_with = "serialize_address")]
            contract: revm::primitives::Address,
            gas_used: u64,
            stack_size: usize,
        }
        
        fn serialize_address<S>(
            address: &revm::primitives::Address,
            serializer: S,
        ) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(&format!("{:?}", address))
        }
        
        let nodes: Vec<Node> = self.steps
            .iter()
            .map(|step| Node {
                id: step.step_id,
                call_id: step.call_id,
                depth: step.depth,
                pc: step.pc,
                opcode: step.opcode_name.clone(),
                contract: step.contract,
                gas_used: step.gas_used,
                stack_size: step.stack_size,
            })
            .collect();
        
        // Create call hierarchy links
        let links: Vec<serde_json::Value> = self.call_hierarchy
            .iter()
            .map(|(&call_id, &parent_id)| {
                json!({
                    "source": parent_id,
                    "target": call_id,
                    "type": "call"
                })
            })
            .collect();
        
        // Create step links (steps within the same call)
        let mut step_links: Vec<serde_json::Value> = Vec::new();
        for i in 1..self.steps.len() {
            let prev = &self.steps[i-1];
            let curr = &self.steps[i];
            
            if prev.call_id == curr.call_id {
                step_links.push(json!({
                    "source": prev.step_id,
                    "target": curr.step_id,
                    "type": "step"
                }));
            }
        }
        
        let output = json!({
            "nodes": nodes,
            "links": [links, step_links].concat()
        });
        
        let mut file = File::create(file_path)?;
        file.write_all(serde_json::to_string_pretty(&output)?.as_bytes())?;
        
        Ok(())
    }
}

// Example of visualizing contract execution
fn visualize_contract_execution() -> Result<(), Box<dyn std::error::Error>> {
    // Set up EVM with our execution visualizer
    let mut evm = EVM::new();
    let memory_db = EthMemoryDB::new();
    
    let visualizer = ExecutionVisualizer::default();
    evm.database(memory_db);
    evm.inspect(visualizer);
    
    // Configure and execute a transaction
    // ... set up transaction ...
    
    evm.transact()?;
    let visualizer = evm.take_inspector().unwrap();
    
    // Export the visualization data
    visualizer.export_json("execution_trace.json")?;
    println!("Execution visualization data exported to execution_trace.json");
    println!("Total execution steps: {}", visualizer.steps.len());
    
    // Print some summary statistics
    let opcodes_count = visualizer.steps
        .iter()
        .fold(HashMap::new(), |mut acc, step| {
            *acc.entry(step.opcode_name.clone()).or_insert(0) += 1;
            acc
        });
    
    println!("\nTop 10 most frequent opcodes:");
    let mut opcodes: Vec<(String, usize)> = opcodes_count
        .into_iter()
        .collect();
    opcodes.sort_by(|a, b| b.1.cmp(&a.1));
    
    for (i, (opcode, count)) in opcodes.into_iter().take(10).enumerate() {
        println!("  {}. {}: {} times", i+1, opcode, count);
    }
    
    Ok(())
}
```

This example generates a JSON file with execution data that can be visualized using tools like D3.js to create interactive execution flow diagrams.

## Memory and Storage Debugging

When debugging complex contracts, it's often helpful to track memory and storage state changes:

```rust
use revm::inspector::{Inspector, InspectorData};
use revm::primitives::{Bytes, Eval, EVMError, Gas, Spec};
use revm::interpreter::{CallInputs, CreateInputs, InterpreterResult, OpCode};
use std::collections::{HashMap, BTreeMap};

#[derive(Debug, Default)]
struct MemoryStorageInspector {
    // Track memory changes per contract and execution step
    memory_snapshots: HashMap<revm::primitives::Address, Vec<(usize, Vec<u8>)>>,
    
    // Track storage changes per contract
    storage_changes: HashMap<revm::primitives::Address, BTreeMap<revm::primitives::U256, revm::primitives::U256>>,
    
    current_contract: Option<revm::primitives::Address>,
    step_count: usize,
}

impl Inspector for MemoryStorageInspector {
    fn initialize_interp(&mut self, data: InspectorData, _is_static: bool) -> Eval {
        self.current_contract = Some(data.interp.contract.address);
        Eval::Continue
    }
    
    fn step(&mut self, data: InspectorData, _is_static: bool) -> Eval {
        self.step_count += 1;
        
        // Check if this is a memory or storage operation
        let pc = data.interp.program_counter();
        let opcode = data.interp.contract.bytecode.bytecode()[pc];
        
        // Take memory snapshot after MSTORE, MSTORE8 operations
        if opcode == OpCode::MSTORE.as_u8() || opcode == OpCode::MSTORE8.as_u8() {
            if let Some(contract) = self.current_contract {
                let memory_snapshot = data.interp.memory.data().to_vec();
                self.memory_snapshots
                    .entry(contract)
                    .or_insert_with(Vec::new)
                    .push((self.step_count, memory_snapshot));
            }
        }
        
        // Record storage changes after SSTORE operations
        if opcode == OpCode::SSTORE.as_u8() && data.interp.stack.len() >= 2 {
            if let Some(contract) = self.current_contract {
                let key = data.interp.stack.peek(0).unwrap_or_default();
                let value = data.interp.stack.peek(1).unwrap_or_default();
                
                self.storage_changes
                    .entry(contract)
                    .or_insert_with(BTreeMap::new)
                    .insert(key, value);
            }
        }
        
        Eval::Continue
    }
    
    fn call(
        &mut self,
        data: InspectorData,
        _inputs: &CallInputs,
        _is_static: bool,
    ) -> (Eval, Gas) {
        self.current_contract = Some(data.interp.contract.address);
        (Eval::Continue, Gas::new(0))
    }
    
    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        _ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        (Eval::Continue, remaining_gas)
    }
    
    // Print a summary of memory and storage changes
    fn print_summary(&self) {
        println!("Memory Changes Summary:");
        for (contract, snapshots) in &self.memory_snapshots {
            println!("Contract: {:?}", contract);
            
            for (i, (step, snapshot)) in snapshots.iter().enumerate() {
                if i < snapshots.len() - 1 {
                    continue; // Only show the final memory state
                }
                
                println!("  Final memory state at step {}:", step);
                
                // Print memory in chunks for readability
                for (chunk_idx, chunk) in snapshot.chunks(32).enumerate() {
                    if !chunk.iter().all(|&b| b == 0) {
                        println!("    0x{:04x}: {}", chunk_idx * 32, hex::encode(chunk));
                    }
                }
            }
        }
        
        println!("\nStorage Changes Summary:");
        for (contract, changes) in &self.storage_changes {
            println!("Contract: {:?}", contract);
            
            for (key, value) in changes {
                println!("  Slot 0x{}: 0x{}", hex::encode(key.to_be_bytes::<32>()), hex::encode(value.to_be_bytes::<32>()));
            }
        }
    }
}

// Example of tracking memory and storage changes
fn debug_memory_and_storage() -> Result<(), Box<dyn std::error::Error>> {
    // Set up EVM with our memory/storage inspector
    let mut evm = EVM::new();
    let memory_db = EthMemoryDB::new();
    
    let inspector = MemoryStorageInspector::default();
    evm.database(memory_db);
    evm.inspect(inspector);
    
    // Configure and execute a transaction
    // ... set up transaction ...
    
    evm.transact()?;
    let inspector = evm.take_inspector().unwrap();
    
    // Print memory and storage changes summary
    inspector.print_summary();
    
    Ok(())
}
```

This inspector tracks memory and storage changes throughout execution, providing insights into how contracts manipulate state.

## Best Practices for Debugging with REVM

1. **Use Multiple Inspectors Simultaneously**: Combine different inspectors to get a comprehensive view of execution
   ```rust
   let inspector_stack = InspectorStack::new()
       .with_inspector(GasInspector::new())
       .with_inspector(TracerEip3155::new())
       .with_inspector(CallTraceInspector::default());
   ```

2. **Filter Trace Data**: For complex transactions, filter trace data to focus on relevant information
   ```rust
   // Filter to only show SSTORE operations
   steps.iter()
       .filter(|step| step.op == OpCode::SSTORE.as_u8())
       .for_each(|step| println!("Storage write at PC={}", step.pc));
   ```

3. **Inspect Return Data**: Always check return data for error information
   ```rust
   match result.result {
       ExecutionResult::Success { .. } => println!("Success"),
       ExecutionResult::Revert { output, .. } => {
           println!("Revert: {}", decode_revert_reason(&output));
       },
       ExecutionResult::Halt { reason, .. } => {
           println!("Halt: {:?}", reason);
       },
   }
   ```

4. **Compare Traces**: When debugging, compare traces between working and failing transactions
   ```rust
   // Save traces to files for comparison
   std::fs::write("working_trace.json", serde_json::to_string_pretty(&working_trace)?)?;
   std::fs::write("failing_trace.json", serde_json::to_string_pretty(&failing_trace)?)?;
   ```

5. **Recreate Mainnet Transactions**: To debug production issues, recreate the exact transaction in REVM
   ```rust
   // Use the exact block state and transaction input
   evm.env.block.number = block_number;
   evm.env.block.timestamp = block_timestamp;
   // ... set other env values to match mainnet ...
   
   // Add the transaction with exact same parameters
   evm.env.tx = tx_env;
   ```

6. **Check Gas Consumption**: High gas usage can indicate inefficient code
   ```rust
   // Track gas usage per opcode
   let gas_by_opcode = steps.iter().fold(HashMap::new(), |mut acc, step| {
       *acc.entry(step.op).or_insert(0) += step.gas_remaining.saturating_sub(step.gas_remaining_after);
       acc
   });
   ```

7. **Log External Calls**: External calls are common failure points
   ```rust
   // In your inspector, focus on CALL, DELEGATECALL, and STATICCALL
   if [OpCode::CALL.as_u8(), OpCode::DELEGATECALL.as_u8(), OpCode::STATICCALL.as_u8()]
       .contains(&opcode) {
       println!("External call at PC={}", pc);
   }
   ```

## Next Steps

Now that you're familiar with REVM's debugging capabilities, you can:

1. Implement a custom debugger for your specific use case
2. Create visualization tools for contract execution
3. Build testing frameworks that use REVM inspectors to validate contracts
4. Explore REVM's precompile implementations for cryptographic operations
5. Check out the next example, which shows how to build a simple block explorer using REVM

For more advanced topics, see the Expert Reference section, particularly "Inspector API Deep Dive" for more details on the Inspector trait.

---

In this guide, we've explored REVM's powerful debugging and tracing capabilities. By leveraging the Inspector trait, you can gain deep insights into EVM execution, debug transactions, and build tools that enhance your understanding of smart contract behavior. These techniques are invaluable when developing, testing, and maintaining smart contracts.