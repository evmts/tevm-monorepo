# Getting Started with REVM

This guide will help you set up and configure REVM for local development. You'll learn how to install REVM, set up a basic project, and create a simple "Hello REVM" application.

## Prerequisites

Before getting started with REVM, make sure you have the following:

- **Rust and Cargo**: REVM is written in Rust, so you'll need a Rust development environment. If you don't have Rust installed, follow the instructions at [rustup.rs](https://rustup.rs/).
- **Basic Rust Knowledge**: Familiarity with Rust programming concepts and syntax will be helpful.
- **Development Environment**: A code editor or IDE with Rust support (VS Code with the rust-analyzer extension is recommended).
- **Basic Ethereum Knowledge**: Understanding of fundamental Ethereum concepts like transactions, accounts, and smart contracts.

## Installing REVM

REVM is available as a Rust crate on [crates.io](https://crates.io). To use it in your project, follow these steps:

### 1. Create a New Rust Project

First, create a new Rust project using Cargo:

```bash
cargo new revm-hello-world
cd revm-hello-world
```

### 2. Add REVM as a Dependency

Open the `Cargo.toml` file in your project and add REVM as a dependency:

```toml
[package]
name = "revm-hello-world"
version = "0.1.0"
edition = "2021"

[dependencies]
revm = "3.5.0"  # Replace with the latest version
```

### 3. Build the Project

Build the project to download and compile REVM and its dependencies:

```bash
cargo build
```

This might take a few minutes the first time as it downloads and compiles all dependencies.

## Project Structure

A basic REVM project typically has the following structure:

```
revm-hello-world/
├── Cargo.toml         # Project configuration and dependencies
├── Cargo.lock         # Locked dependencies (auto-generated)
├── src/
│   └── main.rs        # Main application code
└── tests/             # Test files (optional)
```

## Your First REVM Application

Let's create a simple application that sets up an EVM instance and checks its properties. Replace the contents of `src/main.rs` with the following code:

```rust
use revm::{
    context::Context,
    primitives::{SpecId, U256},
    MainBuilder, MainContext,
};

fn main() {
    // Create a Context with default mainnet settings
    let ctx = Context::mainnet();
    
    // Print the EVM version and configuration
    println!("REVM Hello World!");
    println!("=================");
    println!("EVM Specification: {:?}", ctx.cfg().spec);
    println!("Chain ID: {}", ctx.cfg().chain_id);
    println!("Block Gas Limit: {}", ctx.block().gas_limit);
    
    // Build the EVM instance
    let evm = ctx.build_mainnet();
    
    println!("\nSuccessfully initialized REVM!");
}
```

This simple program creates an EVM instance with default mainnet settings and prints out some basic configuration information.

## Running Your Application

Run your application with the following command:

```bash
cargo run
```

You should see output similar to this:

```
REVM Hello World!
=================
EVM Specification: CANCUN
Chain ID: 1
Block Gas Limit: 30000000

Successfully initialized REVM!
```

Congratulations! You've successfully created and run your first REVM application.

## Understanding the Basic Components

Let's break down the key components used in this example:

### Context

The `Context` is the central configuration object for REVM. It contains:

- **Environment Data**: Transaction, Block, and Configuration settings
- **State Management**: Journal for tracking changes and Database for accessing blockchain state
- **Builder Methods**: Functions to construct the appropriate EVM instance

In our example, we used `Context::mainnet()` to create a context with default Ethereum mainnet settings.

### Configuration

The configuration (`cfg`) contains settings that control the EVM's behavior:

- **Specification**: The Ethereum hardfork rules to follow (e.g., CANCUN)
- **Chain ID**: The blockchain network identifier (1 for Ethereum mainnet)
- **Gas Limits**: Constraints on computation resources
- **Other Settings**: Various flags and options that control execution

### Block

The block context contains information about the current block being processed:

- **Gas Limit**: Maximum gas allowed for all transactions in the block
- **Beneficiary**: Address that receives transaction fees
- **Timestamp**: Block timestamp
- **Other Properties**: Number, difficulty, etc.

## Creating a More Complete Example

Now, let's extend our example to perform a simple value transfer transaction. Update your `main.rs` file:

```rust
use revm::{
    context::Context,
    primitives::{address, TxKind, U256},
    ExecuteEvm, MainBuilder, MainContext,
};

fn main() {
    println!("REVM Hello World!");
    println!("=================");

    // Create an EVM instance with a modified transaction
    let mut evm = Context::mainnet()
        .modify_tx_chained(|tx| {
            // Set up a simple value transfer from one address to another
            tx.caller = address!("0x1000000000000000000000000000000000000000");
            tx.kind = TxKind::Call(address!("0x2000000000000000000000000000000000000000"));
            tx.value = U256::from(1000000000000000000u64); // 1 ETH
        })
        .build_mainnet();

    // Execute the transaction
    match evm.transact() {
        Ok(result) => {
            println!("\nTransaction executed successfully!");
            println!("Gas used: {}", result.result.gas_used());
            println!("Remaining gas: {}", result.result.gas_remaining());
            
            // Print state changes
            println!("\nState changes:");
            for (address, account) in result.state.iter() {
                println!("Address: {}", address);
                if let Some(balance_change) = account.balance_changed() {
                    println!("  Balance change: {}", balance_change);
                }
                if account.nonce_changed() {
                    println!("  New nonce: {}", account.info.nonce);
                }
            }
        },
        Err(error) => println!("Transaction failed: {:?}", error),
    }
}
```

This example:
1. Creates an EVM instance with a modified transaction
2. Sets up a simple value transfer of 1 ETH between two addresses
3. Executes the transaction and handles the result
4. Prints information about gas usage and state changes

Note that this example will actually fail with an error because we haven't provided any initial state (the sender doesn't have any funds). We'll address this in the next tutorial when we cover state management.

## Common Patterns

When working with REVM, you'll often follow these patterns:

### 1. Context Configuration

```rust
// Create a context with default settings
let ctx = Context::mainnet();

// Modify configuration
let ctx = ctx.modify_cfg_chained(|cfg| {
    cfg.chain_id = 1;
    cfg.spec = SpecId::CANCUN;
});

// Modify block information
let ctx = ctx.modify_block_chained(|block| {
    block.number = 1_000_000;
    block.timestamp = 1625097600;
});

// Modify transaction
let ctx = ctx.modify_tx_chained(|tx| {
    tx.caller = sender_address;
    tx.kind = TxKind::Call(target_address);
});
```

### 2. EVM Construction

```rust
// Build a mainnet EVM
let mut evm = ctx.build_mainnet();

// Or build with a specific database
let mut evm = ctx.with_db(database).build_mainnet();
```

### 3. Transaction Execution

```rust
// Execute a transaction
match evm.transact() {
    Ok(result) => {
        // Handle successful execution
    },
    Err(error) => {
        // Handle error
    }
}

// Execute and commit state changes (if using a database that supports it)
match evm.transact_commit() {
    Ok(result) => {
        // Handle successful execution with committed state
    },
    Err(error) => {
        // Handle error
    }
}
```

## Troubleshooting Common Issues

### Missing Dependencies

If you see errors about missing dependencies when building your project, make sure you've added all necessary dependencies to your `Cargo.toml` file. Some REVM features might require additional crates.

### Version Compatibility

REVM is under active development, and APIs might change between versions. If you encounter unexpected errors, check that you're using compatible versions of all dependencies.

### Memory Usage

REVM can use significant memory when processing large blocks or complex contracts. If you encounter memory issues, consider:

- Processing smaller batches of transactions
- Using a more efficient database implementation
- Implementing custom caching strategies

## Next Steps

Now that you've set up REVM and created a simple application, you're ready to dive deeper. In the next tutorial, we'll explore:

- How to execute different types of transactions
- Working with transaction input data
- Understanding and interpreting transaction results
- Handling errors and gas usage

Continue to [Basic Transaction Execution](./1.3-basic-transaction-execution.md) to learn more about executing transactions with REVM.

---

**Note:** The code examples in this guide are simplified for learning purposes. In real-world applications, you would typically provide proper error handling, state initialization, and more robust configuration.