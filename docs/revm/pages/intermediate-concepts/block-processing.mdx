---
title: Block Processing
description: Detailed guide about block processing in REVM (Rust Ethereum Virtual Machine)
---

# Block Processing

This document explains how REVM processes blocks of transactions, including block structure, validation, transaction ordering, state transitions, and finalization.

## Block Structure

Before diving into block processing, let's understand the structure of an Ethereum block in REVM.

### Block Environment

In REVM, block information is represented by the `BlockEnv` structure:

```rust
pub struct BlockEnv {
    /// Number of the current block.
    pub number: u64,
    /// Coinbase address.
    pub coinbase: Address,
    /// Block timestamp.
    pub timestamp: u64,
    /// Block gas limit.
    pub gas_limit: u64,
    /// Difficulty of the current block.
    pub difficulty: U256,
    /// Prevrandao value of the current block.
    pub prevrandao: Option<B256>,
    /// Base fee per gas.
    pub basefee: u64,
    /// Blob base fee.
    pub blob_gasprice: Option<u64>,
    /// Chain ID.
    pub chain_id: u64,
}
```

The block environment contains critical information that affects transaction execution:
- **Gas Limit**: Maximum gas that can be used by all transactions in the block
- **Base Fee**: Base fee per gas used in EIP-1559 fee calculation
- **Blob Gas Price**: Base fee per blob gas for EIP-4844 transactions
- **Coinbase**: Address of the block beneficiary (miner/validator)
- **Timestamp**: Block timestamp, used by the `TIMESTAMP` opcode
- **Number**: Block number, used by the `NUMBER` opcode
- **Difficulty/Prevrandao**: Used by the `DIFFICULTY`/`PREVRANDAO` opcode

### Block Lifecycle

The lifecycle of a block in REVM consists of:

1. **Block Initialization**: Setting up the block parameters
2. **Transaction Processing**: Executing transactions and updating state
3. **Block Finalization**: Finalizing state and generating the block result

## Block Initialization

Before processing a block, REVM initializes the block environment.

### Setting Block Parameters

```rust
use revm::{
    context::Context,
    primitives::{address, U256},
    MainBuilder, MainContext,
};

// Create a context with block parameters
let ctx = Context::mainnet()
    .modify_block_chained(|block| {
        block.number = 15_000_000;
        block.timestamp = 1650000000;
        block.gas_limit = 30_000_000;
        block.basefee = 1_000_000_000; // 1 Gwei
        block.coinbase = address!("0x0000000000000000000000000000000000000000");
        block.difficulty = U256::from(2);
        block.prevrandao = Some([0; 32].into()); // Post-merge blocks use prevrandao
        block.blob_gasprice = Some(10); // For EIP-4844
    })
    .build_mainnet();
```

### Block Validation

REVM validates block parameters against protocol rules:

- Gas limit must be within allowed range (compared to parent block)
- Timestamp must be greater than parent block's timestamp
- Base fee must be calculated correctly based on parent block
- Post-merge blocks must use prevrandao instead of difficulty

REVM doesn't implement all block validation rules by default, as it's primarily focused on execution, but you can implement custom validation in extended implementations.

## Transaction Processing

The core of block processing is executing transactions and updating state.

### Transaction Ordering

Transactions in a block are ordered according to these rules:

1. **Base Order**: Transactions are initially ordered by their gas price (highest first)
2. **Equal Gas Price**: If gas prices are equal, transactions are ordered by their arrival time
3. **Same Sender**: For transactions from the same sender, they're ordered by nonce (lowest first)

In REVM, you typically process transactions in the order they appear in the block:

```rust
// Process transactions in the block
for tx in transactions {
    // Configure transaction parameters
    evm.modify_tx(|tx_env| {
        tx_env.caller = tx.sender;
        tx_env.kind = tx.kind.clone();
        tx_env.data = tx.data.clone();
        tx_env.value = tx.value;
        tx_env.gas_limit = tx.gas_limit;
        tx_env.gas_price = tx.gas_price;
        tx_env.nonce = tx.nonce;
        // Set other tx parameters...
    });
    
    // Execute the transaction
    match evm.transact_commit() {
        Ok(result) => {
            // Handle successful transaction
            println!("Transaction executed: gas_used={}", result.gas_used());
            
            // Add receipt to the block
            receipts.push(result);
            cumulative_gas_used += result.gas_used();
        },
        Err(error) => {
            // Handle failed transaction
            println!("Transaction failed: {:?}", error);
        },
    }
}
```

### Gas Tracking

During block processing, REVM tracks gas usage to ensure the block gas limit is not exceeded:

```rust
let mut total_gas_used = 0;

for tx in transactions {
    // Check if transaction would exceed block gas limit
    if total_gas_used + tx.gas_limit > block.gas_limit {
        println!("Skipping transaction: would exceed block gas limit");
        continue;
    }
    
    // Execute transaction
    if let Ok(result) = evm.transact_commit() {
        // Update total gas used
        total_gas_used += result.gas_used();
    }
}
```

### State Updates

As transactions are executed, they modify the blockchain state. REVM handles state updates through:

1. **Immediate Updates**: Each transaction immediately updates the state
2. **Transaction-Level Atomicity**: Each transaction is atomic (all-or-nothing)
3. **Cumulative Changes**: Changes from all transactions accumulate to form the block's state transition

## Block Mining and Finalization

In addition to executing transactions, REVM can simulate block mining and finalization.

### Block Mining

REVM supports different mining strategies:

#### 1. Auto-Mining

Every transaction is immediately mined in its own block:

```rust
// Configure auto-mining
let ctx = Context::mainnet()
    .modify_cfg_chained(|cfg| {
        cfg.mining_mode = MiningMode::Auto;
    })
    .build_mainnet();
```

#### 2. Manual Mining

Transactions are added to a pool and mined when explicitly requested:

```rust
// Configure manual mining
let ctx = Context::mainnet()
    .modify_cfg_chained(|cfg| {
        cfg.mining_mode = MiningMode::Manual;
    })
    .build_mainnet();

// Add transactions to the pool
for tx in transactions {
    evm.add_transaction(tx)?;
}

// Mine the transactions
evm.mine()?;
```

#### 3. Interval Mining

Transactions are mined at regular intervals:

```rust
// Configure interval mining
let ctx = Context::mainnet()
    .modify_cfg_chained(|cfg| {
        cfg.mining_mode = MiningMode::Interval(5); // Mine every 5 blocks
    })
    .build_mainnet();
```

### Block Finalization

Block finalization involves:

1. **State Root Calculation**: Computing the Merkle root of the state trie
2. **Receipt Root Calculation**: Computing the Merkle root of the receipts trie
3. **Block Header Finalization**: Setting final block header fields
4. **Block Sealing**: Creating the block hash

REVM focuses on execution rather than consensus, so some of these steps may be simplified or omitted in the default implementation.

## Block-Level State Transitions

Block processing in REVM involves a series of state transitions.

### Initial State

Before processing a block, REVM starts with an initial state:

- Account balances, nonces, and code
- Contract storage
- Previous block hashes

### Transitional States

As each transaction is processed, the state is updated incrementally:

1. **Sender Account Updates**:
   - Nonce incremented
   - Balance reduced by gas fee
   - Balance reduced by value transferred

2. **Recipient Account Updates**:
   - Balance increased by value transferred
   - Storage updated (for contract calls)
   - Code stored (for contract creation)

3. **Global State Updates**:
   - Block hash of previous block recorded
   - Cumulative gas used updated
   - Receipts generated

### Final State

After all transactions are processed, the final state includes:

- All account balance changes
- All nonce updates
- All storage changes
- All code deployments
- All logs generated

## Processing Multiple Transactions

REVM provides several approaches for processing multiple transactions in a block.

### Sequential Processing

The simplest approach is to process transactions sequentially:

```rust
// Process transactions one by one
for tx in transactions {
    // Configure the transaction
    evm.modify_tx(|tx_env| {
        // Set tx parameters from tx
        tx_env.caller = tx.sender;
        tx_env.kind = tx.kind;
        tx_env.data = tx.data;
        // Set other parameters...
    });
    
    // Execute the transaction
    match evm.transact_commit() {
        Ok(result) => {
            // Record successful execution
            println!("Transaction succeeded: gas_used={}", result.gas_used());
        },
        Err(error) => {
            // Record failed execution
            println!("Transaction failed: {:?}", error);
        },
    }
}
```

### Batch Processing

For improved performance, you can batch transaction processing:

```rust
// Prepare a batch of transactions
let mut transactions_batch = Vec::new();
for tx in transactions {
    let tx_env = TxEnv {
        caller: tx.sender,
        kind: tx.kind,
        data: tx.data,
        // Set other parameters...
    };
    transactions_batch.push(tx_env);
}

// Process the batch
let results = evm.batch_transact(transactions_batch)?;
for result in results {
    println!("Transaction result: {:?}", result);
}
```

### Parallel Processing (Simulation Only)

For simulation purposes, you can process transactions in parallel:

```rust
use rayon::prelude::*;

// Create a clone of the initial state
let initial_state = evm.db().unwrap().clone();

// Process transactions in parallel (for simulation only)
let results: Vec<_> = transactions.par_iter().map(|tx| {
    // Create a new EVM instance with a clone of the initial state
    let mut local_evm = Context::mainnet()
        .with_db(initial_state.clone())
        .build_mainnet();
    
    // Configure and execute the transaction
    local_evm.modify_tx(|tx_env| {
        // Set tx parameters from tx
        tx_env.caller = tx.sender;
        tx_env.kind = tx.kind;
        tx_env.data = tx.data;
        // Set other parameters...
    });
    
    local_evm.transact()
}).collect();

// Note: This is only for simulation, as it doesn't account for
// dependencies between transactions (e.g., nonce ordering)
```

## Block-Level Effects

Block processing in REVM includes several block-level effects.

### Block Rewards

In Ethereum, block producers receive rewards:

1. **Base Block Reward**: Fixed amount per block (2 ETH post-London)
2. **Uncle Rewards**: Rewards for uncle blocks (pre-merge)
3. **Transaction Fee Rewards**: Portion of the transaction fees

REVM can simulate these rewards:

```rust
// Calculate and apply block rewards
fn apply_block_rewards(evm: &mut Evm<CacheDB<EmptyDB>>, block_number: u64) {
    let beneficiary = evm.ctx().block().coinbase;
    
    // Base block reward (depends on hardfork)
    let base_reward = if block_number >= LONDON_BLOCK {
        U256::from(2_000_000_000_000_000_000u64) // 2 ETH post-London
    } else {
        U256::from(3_000_000_000_000_000_000u64) // 3 ETH pre-London
    };
    
    // Add the reward to the beneficiary's balance
    if let Ok(Some(mut account)) = evm.db().unwrap().basic(beneficiary) {
        account.balance += base_reward;
        evm.db().unwrap().insert_account_info(beneficiary, account);
    } else {
        // Create account if it doesn't exist
        let account = AccountInfo {
            nonce: 0,
            balance: base_reward,
            code_hash: KECCAK_EMPTY,
            code: None,
        };
        evm.db().unwrap().insert_account_info(beneficiary, account);
    }
}
```

### Block Metadata Updates

After processing a block, REVM updates block metadata:

1. **Block Hash**: Recorded for the processed block
2. **State Root**: Updated to reflect the new state
3. **Receipt Root**: Calculated from transaction receipts
4. **Logs Bloom**: Aggregated from all transaction receipts

```rust
// Update block metadata
fn update_block_metadata(evm: &mut Evm<CacheDB<EmptyDB>>, block_number: u64) {
    // Generate block hash
    let block_hash = generate_block_hash(evm);
    
    // Store the block hash
    evm.db().unwrap().insert_block_hash(block_number, block_hash);
    
    // Update block number and timestamp for the next block
    evm.modify_block(|block| {
        block.number += 1;
        block.timestamp += 12; // Assume 12-second block time
    });
}
```

## Example: Processing a Full Block

Let's put everything together to process a full block:

```rust
use revm::{
    context::Context,
    database::{CacheDB, EmptyDB},
    primitives::{address, BlockEnv, TxEnv, TxKind, U256},
    ExecuteCommitEvm, ExecuteEvm, MainBuilder, MainContext,
};

// Define a transaction structure
struct Transaction {
    sender: Address,
    recipient: Address,
    value: U256,
    data: Bytes,
    gas_limit: u64,
    gas_price: U256,
    nonce: u64,
}

// Process a full block
fn process_block(transactions: Vec<Transaction>, block_env: BlockEnv) -> Result<(), Box<dyn Error>> {
    // Create an EVM instance with the specified block environment
    let mut evm = Context::mainnet()
        .with_db(CacheDB::new(EmptyDB::default()))
        .with_block(block_env)
        .build_mainnet();
    
    // Initialize receipts collection
    let mut receipts = Vec::new();
    let mut cumulative_gas_used = 0;
    
    // Process each transaction
    for tx in transactions {
        // Configure the transaction
        evm.modify_tx(|tx_env| {
            tx_env.caller = tx.sender;
            tx_env.kind = TxKind::Call(tx.recipient);
            tx_env.value = tx.value;
            tx_env.data = tx.data;
            tx_env.gas_limit = tx.gas_limit;
            tx_env.gas_price = tx.gas_price;
            tx_env.nonce = tx.nonce;
        });
        
        // Execute the transaction
        match evm.transact_commit() {
            Ok(result) => {
                println!("Transaction executed successfully");
                println!("Gas used: {}", result.gas_used());
                
                // Update cumulative gas used
                cumulative_gas_used += result.gas_used();
                
                // Create and store receipt
                let receipt = Receipt {
                    status: 1, // Success
                    gas_used: result.gas_used(),
                    cumulative_gas_used,
                    logs: result.logs().cloned().unwrap_or_default(),
                    // Calculate logs bloom, etc.
                };
                receipts.push(receipt);
            },
            Err(error) => {
                println!("Transaction failed: {:?}", error);
                
                // Create and store receipt for failed transaction
                let receipt = Receipt {
                    status: 0, // Failure
                    gas_used: 0, // Or partial gas used if available
                    cumulative_gas_used,
                    logs: Vec::new(),
                    // Calculate logs bloom, etc.
                };
                receipts.push(receipt);
            },
        }
    }
    
    // Apply block rewards
    apply_block_rewards(&mut evm, block_env.number);
    
    // Update block metadata
    update_block_metadata(&mut evm, block_env.number);
    
    // Return the block result
    Ok(())
}
```

## Mining Modes in REVM

REVM supports different mining modes to simulate various blockchain behaviors.

### Mining Mode Configuration

Mining modes can be configured through the `CfgEnv`:

```rust
use revm::primitives::MiningMode;

// Configure mining mode
let ctx = Context::mainnet()
    .modify_cfg_chained(|cfg| {
        cfg.mining_mode = MiningMode::Manual;
    })
    .build_mainnet();
```

### Mining Mode Types

REVM provides several mining modes:

#### Auto Mining

In Auto mode, each transaction is immediately mined in its own block:

```rust
cfg.mining_mode = MiningMode::Auto;
```

This is useful for testing individual transactions.

#### Manual Mining

In Manual mode, transactions are added to a pool and mined when explicitly requested:

```rust
cfg.mining_mode = MiningMode::Manual;
```

This allows for greater control over block formation:

```rust
// Add transactions to the pool
for tx in transactions {
    evm.add_transaction(tx)?;
}

// Mine a block with the pooled transactions
evm.mine()?;

// Alternatively, mine a specific number of blocks
evm.mine_blocks(5)?;
```

#### Interval Mining

In Interval mode, blocks are mined at regular intervals:

```rust
cfg.mining_mode = MiningMode::Interval(5); // Mine every 5 blocks
```

This simulates periodic block creation:

```rust
// Add a transaction
evm.add_transaction(tx1)?;

// No mining yet (interval not reached)
assert_eq!(evm.pending_transactions().len(), 1);

// Add more transactions until interval is reached
evm.add_transaction(tx2)?;
evm.add_transaction(tx3)?;
evm.add_transaction(tx4)?;
evm.add_transaction(tx5)?;

// Now a block should be mined automatically
assert_eq!(evm.pending_transactions().len(), 0);
```

#### Gas Limit Mining

In Gas Limit mode, blocks are mined when the accumulated gas reaches a threshold:

```rust
cfg.mining_mode = MiningMode::GasLimit(1_000_000); // Mine when gas reaches 1M
```

This simulates gas-based block packing:

```rust
// Add transactions until gas limit is reached
evm.add_transaction(tx1)?; // gas: 300,000
evm.add_transaction(tx2)?; // gas: 400,000
// Total: 700,000 - No mining yet

evm.add_transaction(tx3)?; // gas: 400,000
// Total: 1,100,000 - Mining triggered
```

## Block-Level Optimizations

REVM implements several optimizations for efficient block processing.

### State Caching

REVM caches state data to minimize database access:

```rust
// Create a cache database
let mut db = CacheDB::new(underlying_db);

// Process a block with the cached database
let mut evm = Context::mainnet()
    .with_db(db)
    .build_mainnet();

// Process transactions...

// Commit all changes at once
if let Some(db) = evm.db() {
    db.commit_all();
}
```

### Transaction Pooling

REVM can pool and prioritize transactions before mining:

```rust
// Add transactions to the pool
evm.add_transaction(tx1)?;
evm.add_transaction(tx2)?;

// Get pending transactions
let pending = evm.pending_transactions();
println!("Pending transactions: {}", pending.len());

// Prioritize and select transactions for the next block
let next_block_txs = evm.select_transactions(block_gas_limit)?;
```

### Access List Generation

REVM can generate access lists to optimize gas usage:

```rust
// Generate an access list for a transaction
let access_list = evm.generate_access_list(tx)?;

// Apply the access list to the transaction
tx.access_list = access_list;

// Execute with the optimized access list
let result = evm.transact(tx)?;
```

## Common Block Processing Patterns

Here are some common patterns for block processing with REVM:

### Block Simulation

Simulating a block without persisting changes:

```rust
// Create a clone of the current state
let initial_state = db.clone();

// Create an EVM with the cloned state
let mut evm = Context::mainnet()
    .with_db(initial_state)
    .with_block(block_env)
    .build_mainnet();

// Process transactions
for tx in transactions {
    // Configure and execute transaction...
}

// The original state remains unchanged
```

### Block Replay

Replaying historical blocks for analysis:

```rust
// For each block to replay
for block_number in start_block..=end_block {
    // Fetch block data from an external source
    let block_data = fetch_block_data(block_number)?;
    
    // Configure the block environment
    let block_env = BlockEnv {
        number: block_data.number,
        timestamp: block_data.timestamp,
        // Set other block parameters...
    };
    
    // Create an EVM instance
    let mut evm = Context::mainnet()
        .with_db(db.clone())
        .with_block(block_env)
        .build_mainnet();
    
    // Process transactions
    for tx in block_data.transactions {
        // Configure and execute transaction...
    }
    
    // Analyze results
    analyze_block_execution(block_number, receipts);
}
```

### Block Building

Creating a new block with selected transactions:

```rust
// Create an EVM with the current state
let mut evm = Context::mainnet()
    .with_db(db)
    .with_block(block_env)
    .build_mainnet();

// Select transactions from the mempool
let transactions = select_transactions_from_mempool(mempool, block_gas_limit);

// Process selected transactions
let mut receipts = Vec::new();
for tx in transactions {
    // Configure and execute transaction...
    if let Ok(result) = evm.transact_commit() {
        receipts.push(create_receipt(result));
    }
}

// Build block header
let block_header = build_block_header(block_env, receipts);

// Return the new block
Block {
    header: block_header,
    transactions,
    uncles: Vec::new(),
}
```

## Summary

REVM's block processing capabilities provide a flexible and efficient way to work with Ethereum blocks:

- **Block Structure**: Representation of block parameters through `BlockEnv`
- **Transaction Processing**: Execution of transactions in a block context
- **State Transitions**: Management of state changes across multiple transactions
- **Mining Modes**: Different approaches for simulating block mining
- **Block-Level Effects**: Block rewards, metadata updates, and finalization
- **Optimizations**: State caching, transaction pooling, and access list generation

Understanding these concepts allows for effective use of REVM for block simulation, testing, and custom blockchain implementations.

## Next Steps

Now that you understand block processing in REVM, you might want to explore:

- [EVM Customization](#TODO): Learn how to customize REVM's behavior
- [Performance Considerations](#TODO): Understand performance aspects of block processing
- [Integration Patterns](#TODO): Discover how to integrate REVM with other systems

---

**Note**: Some of the examples in this document are simplified for clarity. In real applications, you would need more robust error handling, state management, and consensus integration.