---
title: Integration Patterns
description: Detailed guide about integration patterns in REVM (Rust Ethereum Virtual Machine)
---

# Integration Patterns

This document explores how to integrate REVM with other systems and frameworks. You'll learn how to integrate REVM with blockchain clients, web services, testing frameworks, and other tools in the Ethereum ecosystem.

## REVM Integration Overview

REVM is designed to be modular and flexible, making it suitable for integration in various environments. Common integration scenarios include:

1. **Ethereum Clients**: Using REVM as the execution engine in a full Ethereum node
2. **Testing Frameworks**: Integrating REVM for smart contract testing
3. **Development Tools**: Using REVM in development environments
4. **Web Services**: Exposing REVM functionality via APIs
5. **Layer 2 Solutions**: Building Layer 2 execution environments on REVM

## Integrating with Ethereum Clients

REVM can be integrated as the execution engine in a full Ethereum client.

### Basic Client Integration

Here's a simplified example of integrating REVM in an Ethereum client:

```rust
use revm::{Context, Database, Evm, EvmContext, ExecutionResult};
use client_types::{Block, Transaction};

struct EthereumClient<DB: Database> {
    database: DB,
    // Other client components: networking, consensus, etc.
}

impl<DB: Database> EthereumClient<DB> {
    fn new(database: DB) -> Self {
        Self {
            database,
            // Initialize other components
        }
    }
    
    fn execute_block(&mut self, block: Block) -> Result<ExecutionResult, Error> {
        // Create REVM context with block data
        let ctx = Context::mainnet()
            .with_db(&mut self.database)
            .modify_block_chained(|b| {
                b.number = block.number;
                b.beneficiary = block.header.coinbase;
                b.timestamp = block.header.timestamp;
                b.difficulty = block.header.difficulty;
                b.gas_limit = block.header.gas_limit;
                b.basefee = block.header.base_fee_per_gas;
            });
        
        // Create EVM instance
        let mut evm = ctx.build_mainnet();
        
        // Execute each transaction
        for transaction in block.transactions {
            // Convert client transaction to REVM transaction
            let tx = self.convert_transaction(transaction);
            
            // Execute transaction
            evm.modify_tx(|t| *t = tx);
            let result = evm.transact_commit()?;
            
            // Process execution result
            self.process_execution_result(result);
        }
        
        // Process block rewards
        self.process_block_rewards(block.header.coinbase);
        
        // Return final execution result
        Ok(evm.last_result)
    }
    
    fn convert_transaction(&self, tx: Transaction) -> TxEnv {
        // Convert client transaction format to REVM's TxEnv
        let mut tx_env = TxEnv::default();
        
        tx_env.caller = tx.from;
        tx_env.kind = match tx.to {
            Some(to) => TxKind::Call(to),
            None => TxKind::Create,
        };
        tx_env.data = tx.input;
        tx_env.value = tx.value;
        tx_env.gas_limit = tx.gas;
        tx_env.gas_price = tx.gas_price;
        tx_env.nonce = tx.nonce;
        
        tx_env
    }
    
    fn process_execution_result(&mut self, result: ExecutionResult) {
        // Process execution result: update state, emit events, etc.
        // ...
    }
    
    fn process_block_rewards(&mut self, coinbase: Address) {
        // Calculate and apply block rewards
        // ...
    }
}
```

### Synchronization Integration

For a full client, integrate REVM with blockchain synchronization:

```rust
impl<DB: Database> EthereumClient<DB> {
    fn sync_blockchain(&mut self, target_block: u64) -> Result<(), Error> {
        let current_block = self.get_current_block_number();
        
        for block_number in (current_block + 1)..=target_block {
            // Fetch block from network or storage
            let block = self.fetch_block(block_number)?;
            
            // Execute block
            let result = self.execute_block(block)?;
            
            // Validate block execution
            self.validate_block_execution(block, result)?;
            
            // Commit block to database
            self.commit_block(block, result)?;
            
            // Update chain state
            self.update_chain_state(block_number);
        }
        
        Ok(())
    }
    
    fn validate_block_execution(&self, block: Block, result: ExecutionResult) -> Result<(), Error> {
        // Validate that execution result matches expected block state
        if result.state_root != block.header.state_root {
            return Err(Error::InvalidStateRoot);
        }
        
        // Validate receipts root
        if self.calculate_receipts_root(result.receipts) != block.header.receipts_root {
            return Err(Error::InvalidReceiptsRoot);
        }
        
        // Validate logs bloom
        if self.calculate_logs_bloom(result.logs) != block.header.logs_bloom {
            return Err(Error::InvalidLogsBloom);
        }
        
        Ok(())
    }
    
    // Other helper methods...
}
```

### Database Integration

REVM's `Database` trait allows flexible integration with various storage backends:

```rust
use revm::database_interface::{Database, DatabaseCommit, DBErrorMarker};
use client_storage::Storage;

// Adapt client storage to REVM Database trait
struct ClientDatabase {
    storage: Storage,
}

#[derive(Debug)]
struct ClientDatabaseError(String);

impl std::fmt::Display for ClientDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Client database error: {}", self.0)
    }
}

impl std::error::Error for ClientDatabaseError {}
impl DBErrorMarker for ClientDatabaseError {}

impl Database for ClientDatabase {
    type Error = ClientDatabaseError;
    
    fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        // Retrieve account from client storage
        self.storage.get_account(address)
            .map_err(|e| ClientDatabaseError(e.to_string()))
            .map(|acc| acc.map(|a| AccountInfo {
                nonce: a.nonce,
                balance: a.balance,
                code_hash: a.code_hash,
                code: a.code.map(|c| Bytecode::new_raw(c)),
            }))
    }
    
    fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        // Retrieve code from client storage
        self.storage.get_code_by_hash(code_hash)
            .map_err(|e| ClientDatabaseError(e.to_string()))
            .map(|code| Bytecode::new_raw(code))
    }
    
    fn storage(&mut self, address: Address, key: U256) -> Result<U256, Self::Error> {
        // Retrieve storage from client storage
        self.storage.get_storage(address, key)
            .map_err(|e| ClientDatabaseError(e.to_string()))
    }
    
    fn block_hash(&mut self, number: u64) -> Result<B256, Self::Error> {
        // Retrieve block hash from client storage
        self.storage.get_block_hash(number)
            .map_err(|e| ClientDatabaseError(e.to_string()))
    }
}

impl DatabaseCommit for ClientDatabase {
    fn commit(&mut self, changes: HashMap<Address, Account>) {
        // Convert and commit changes to client storage
        let storage_changes = changes.into_iter()
            .map(|(addr, acc)| {
                // Convert REVM Account to client AccountDiff
                let account_diff = convert_account_to_diff(addr, acc);
                (addr, account_diff)
            })
            .collect();
            
        self.storage.commit_changes(storage_changes);
    }
}
```

## Web Services Integration

REVM can be exposed as a web service for transaction simulation, gas estimation, and more.

### JSON-RPC API

Here's how to integrate REVM in a JSON-RPC API server:

```rust
use actix_web::{web, App, HttpServer, Responder};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CallRequest {
    from: Option<String>,
    to: Option<String>,
    gas: Option<String>,
    gas_price: Option<String>,
    value: Option<String>,
    data: Option<String>,
}

#[derive(Serialize)]
struct CallResponse {
    return_data: String,
    gas_used: String,
    success: bool,
}

struct EvmService {
    evm: Mutex<Evm<MainContext, NoopInspector, EthInstructions<EthInterpreter, MainContext>, EthPrecompiles>>,
}

impl EvmService {
    fn new(db: impl Database) -> Self {
        let evm = Context::mainnet().with_db(db).build_mainnet();
        Self { evm: Mutex::new(evm) }
    }
    
    async fn call(&self, request: CallRequest) -> Result<CallResponse, Error> {
        let mut evm = self.evm.lock().await;
        
        // Convert request to TxEnv
        let tx_env = convert_request_to_tx_env(request)?;
        
        // Configure EVM
        evm.modify_tx(|tx| *tx = tx_env);
        
        // Execute call
        let result = evm.transact()?;
        
        // Convert result to response
        let response = CallResponse {
            return_data: hex::encode(result.result.output.to_vec()),
            gas_used: result.result.gas_used().to_string(),
            success: result.result.is_success(),
        };
        
        Ok(response)
    }
}

// JSON-RPC endpoint handler
async fn eth_call(
    service: web::Data<EvmService>,
    req: web::Json<CallRequest>,
) -> impl Responder {
    match service.call(req.into_inner()).await {
        Ok(response) => web::Json(response),
        Err(error) => {
            // Handle error
            // ...
        }
    }
}

// Server initialization
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize the database
    let db = initialize_database();
    
    // Create the EVM service
    let service = EvmService::new(db);
    
    // Start the JSON-RPC server
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(service.clone()))
            .route("/eth_call", web::post().to(eth_call))
            // Add more endpoints...
    })
    .bind("127.0.0.1:8545")?
    .run()
    .await
}
```

### REST API Integration

For a more REST-oriented API:

```rust
// REST endpoints for EVM operations
#[derive(Deserialize)]
struct SimulateTransactionRequest {
    from: String,
    to: String,
    value: String,
    data: String,
    gas_limit: String,
}

#[derive(Serialize)]
struct SimulateTransactionResponse {
    gas_used: String,
    return_data: String,
    success: bool,
    state_diff: HashMap<String, AccountDiff>,
    logs: Vec<LogEntry>,
}

// REST endpoint handler
async fn simulate_transaction(
    service: web::Data<EvmService>,
    req: web::Json<SimulateTransactionRequest>,
) -> impl Responder {
    match service.simulate_transaction(req.into_inner()).await {
        Ok(response) => web::Json(response),
        Err(error) => {
            // Handle error
            // ...
        }
    }
}

// API for gas estimation
#[derive(Deserialize)]
struct EstimateGasRequest {
    from: String,
    to: Option<String>,
    value: Option<String>,
    data: String,
}

#[derive(Serialize)]
struct EstimateGasResponse {
    gas: String,
}

// Gas estimation endpoint handler
async fn estimate_gas(
    service: web::Data<EvmService>,
    req: web::Json<EstimateGasRequest>,
) -> impl Responder {
    match service.estimate_gas(req.into_inner()).await {
        Ok(gas) => web::Json(EstimateGasResponse { gas: gas.to_string() }),
        Err(error) => {
            // Handle error
            // ...
        }
    }
}
```

### WebSocket Integration

For real-time updates and subscription-based services:

```rust
use actix_web_actors::ws;
use std::time::{Duration, Instant};

struct EvmWebsocketSession {
    evm: Evm<MainContext, NoopInspector, EthInstructions<EthInterpreter, MainContext>, EthPrecompiles>,
    subscriptions: HashMap<String, SubscriptionType>,
    last_heartbeat: Instant,
}

enum SubscriptionType {
    NewBlocks,
    PendingTransactions,
    Logs { address: Option<Address>, topics: Vec<H256> },
}

impl Actor for EvmWebsocketSession {
    type Context = ws::WebsocketContext<Self>;
    
    fn started(&mut self, ctx: &mut Self::Context) {
        // Set up heartbeat
        self.heartbeat(ctx);
    }
}

impl EvmWebsocketSession {
    fn heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(Duration::from_secs(5), |act, ctx| {
            if Instant::now().duration_since(act.last_heartbeat) > Duration::from_secs(10) {
                // Heartbeat timeout, disconnect
                ctx.stop();
                return;
            }
            
            // Send ping
            ctx.ping(b"");
        });
    }
    
    fn handle_subscription(&mut self, id: String, type_str: &str, params: Value) -> Result<(), Error> {
        let subscription_type = match type_str {
            "newHeads" => SubscriptionType::NewBlocks,
            "pendingTransactions" => SubscriptionType::PendingTransactions,
            "logs" => {
                // Parse logs subscription parameters
                let filter = params.get("filter").ok_or(Error::InvalidParams)?;
                let address = filter.get("address").map(|a| parse_address(a))?;
                let topics = filter.get("topics")
                    .map(|t| parse_topics(t))
                    .unwrap_or_else(|| Ok(vec![]))?;
                
                SubscriptionType::Logs { address, topics }
            },
            _ => return Err(Error::UnsupportedSubscription),
        };
        
        // Store subscription
        self.subscriptions.insert(id, subscription_type);
        
        Ok(())
    }
    
    fn notify_subscription(&self, ctx: &mut ws::WebsocketContext<Self>, id: &str, data: Value) {
        let notification = json!({
            "jsonrpc": "2.0",
            "method": "eth_subscription",
            "params": {
                "subscription": id,
                "result": data
            }
        });
        
        ctx.text(notification.to_string());
    }
}

// WebSocket handler implementation
impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for EvmWebsocketSession {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                self.last_heartbeat = Instant::now();
                ctx.pong(&msg);
            },
            Ok(ws::Message::Pong(_)) => {
                self.last_heartbeat = Instant::now();
            },
            Ok(ws::Message::Text(text)) => {
                // Parse JSON-RPC request
                let request: Result<JsonRpcRequest, _> = serde_json::from_str(&text);
                
                match request {
                    Ok(req) => {
                        // Handle JSON-RPC method
                        match req.method.as_str() {
                            "eth_subscribe" => {
                                // Parse subscription parameters
                                let subscription_type = req.params[0].as_str().unwrap_or("");
                                let params = req.params.get(1).cloned().unwrap_or(json!({}));
                                
                                // Generate subscription ID
                                let id = generate_subscription_id();
                                
                                // Set up subscription
                                match self.handle_subscription(id.clone(), subscription_type, params) {
                                    Ok(()) => {
                                        // Send successful subscription response
                                        let response = json!({
                                            "jsonrpc": "2.0",
                                            "id": req.id,
                                            "result": id
                                        });
                                        ctx.text(response.to_string());
                                    },
                                    Err(error) => {
                                        // Send error response
                                        let response = json!({
                                            "jsonrpc": "2.0",
                                            "id": req.id,
                                            "error": {
                                                "code": error.code(),
                                                "message": error.message()
                                            }
                                        });
                                        ctx.text(response.to_string());
                                    }
                                }
                            },
                            "eth_unsubscribe" => {
                                // Remove subscription
                                let subscription_id = req.params[0].as_str().unwrap_or("");
                                self.subscriptions.remove(subscription_id);
                                
                                // Send success response
                                let response = json!({
                                    "jsonrpc": "2.0",
                                    "id": req.id,
                                    "result": true
                                });
                                ctx.text(response.to_string());
                            },
                            // Handle other methods...
                            _ => {
                                // Send method not found error
                                let response = json!({
                                    "jsonrpc": "2.0",
                                    "id": req.id,
                                    "error": {
                                        "code": -32601,
                                        "message": "Method not found"
                                    }
                                });
                                ctx.text(response.to_string());
                            }
                        }
                    },
                    Err(_) => {
                        // Send parse error
                        let response = json!({
                            "jsonrpc": "2.0",
                            "id": null,
                            "error": {
                                "code": -32700,
                                "message": "Parse error"
                            }
                        });
                        ctx.text(response.to_string());
                    }
                }
            },
            Ok(ws::Message::Close(reason)) => {
                // Handle WebSocket close
                ctx.close(reason);
                ctx.stop();
            },
            _ => {}
        }
    }
}
```

## Testing Framework Integration

REVM is ideal for smart contract testing frameworks.

### Unit Testing Integration

Integrate REVM for unit testing smart contracts:

```rust
struct EvmTestContext {
    evm: Evm<MainContext, NoopInspector, EthInstructions<EthInterpreter, MainContext>, EthPrecompiles>,
    accounts: HashMap<String, Address>,
}

impl EvmTestContext {
    fn new() -> Self {
        // Create in-memory database
        let db = CacheDB::new(EmptyDB::default());
        
        // Create EVM instance
        let evm = Context::mainnet().with_db(db).build_mainnet();
        
        // Create and fund test accounts
        let accounts = generate_test_accounts(&mut evm);
        
        Self {
            evm,
            accounts,
        }
    }
    
    fn deploy_contract(&mut self, bytecode: Bytes, deployer: &str) -> Result<Address, Error> {
        let deployer_address = self.accounts.get(deployer)
            .ok_or(Error::AccountNotFound)?;
        
        // Configure deployment transaction
        self.evm.modify_tx(|tx| {
            tx.caller = *deployer_address;
            tx.kind = TxKind::Create;
            tx.data = bytecode;
            tx.value = U256::ZERO;
            tx.gas_limit = 10_000_000;
            tx.gas_price = U256::from(1);
        });
        
        // Execute deployment
        let result = self.evm.transact_commit()?;
        
        // Extract contract address
        match result.result.output {
            Output::Create(_, Some(address)) => Ok(address),
            _ => Err(Error::DeploymentFailed),
        }
    }
    
    fn call_contract(&mut self, contract: Address, data: Bytes, sender: &str) -> Result<Bytes, Error> {
        let sender_address = self.accounts.get(sender)
            .ok_or(Error::AccountNotFound)?;
        
        // Configure call transaction
        self.evm.modify_tx(|tx| {
            tx.caller = *sender_address;
            tx.kind = TxKind::Call(contract);
            tx.data = data;
            tx.value = U256::ZERO;
            tx.gas_limit = 10_000_000;
            tx.gas_price = U256::from(1);
        });
        
        // Execute call
        let result = self.evm.transact_commit()?;
        
        // Extract return data
        match result.result.output {
            Output::Call(data) => Ok(data),
            _ => Err(Error::CallFailed),
        }
    }
    
    fn assert_storage_eq(&mut self, contract: Address, slot: U256, expected: U256) -> Result<(), Error> {
        let value = self.evm.ctx().journal().sload(contract, slot)?.data;
        
        if value != expected {
            return Err(Error::StorageAssertionFailed {
                slot,
                expected,
                actual: value,
            });
        }
        
        Ok(())
    }
    
    // More test helpers...
}

// Generate test accounts with initial balance
fn generate_test_accounts(evm: &mut Evm<MainContext, NoopInspector, EthInstructions<EthInterpreter, MainContext>, EthPrecompiles>) -> HashMap<String, Address> {
    let mut accounts = HashMap::new();
    
    // Create accounts with predictable private keys
    let keys = [
        "owner",
        "user1",
        "user2",
        "attacker",
    ];
    
    for key in &keys {
        // Generate deterministic address
        let address = generate_address_from_string(key);
        
        // Fund account
        evm.ctx().journal().write().account_mut(address)
            .unwrap()
            .info
            .balance = U256::from(100_000_000_000_000_000_000u128);
        
        accounts.insert(key.to_string(), address);
    }
    
    accounts
}

// Example test using the EVM test context
#[test]
fn test_token_transfer() {
    // Initialize test context
    let mut ctx = EvmTestContext::new();
    
    // Deploy ERC20 token contract
    let bytecode = compile_contract("ERC20.sol");
    let token = ctx.deploy_contract(bytecode, "owner").unwrap();
    
    // Mint tokens to owner
    let mint_call = encode_function_call("mint(address,uint256)", &[
        Token::Address(ctx.accounts["owner"]),
        Token::Uint(U256::from(1000)),
    ]);
    ctx.call_contract(token, mint_call, "owner").unwrap();
    
    // Transfer tokens to user1
    let transfer_call = encode_function_call("transfer(address,uint256)", &[
        Token::Address(ctx.accounts["user1"]),
        Token::Uint(U256::from(500)),
    ]);
    ctx.call_contract(token, transfer_call, "owner").unwrap();
    
    // Check balances
    let balance_of_call = encode_function_call("balanceOf(address)", &[
        Token::Address(ctx.accounts["owner"]),
    ]);
    let owner_balance = decode_uint(ctx.call_contract(token, balance_of_call, "user2").unwrap());
    assert_eq!(owner_balance, U256::from(500));
    
    let balance_of_call = encode_function_call("balanceOf(address)", &[
        Token::Address(ctx.accounts["user1"]),
    ]);
    let user1_balance = decode_uint(ctx.call_contract(token, balance_of_call, "user2").unwrap());
    assert_eq!(user1_balance, U256::from(500));
}
```

### Property-Based Testing

Integrate REVM with property-based testing frameworks:

```rust
use proptest::prelude::*;

// Property-based test for token transfers
proptest! {
    #[test]
    fn token_transfer_preserves_total_supply(
        from_balance in 0u64..1_000_000_000u64,
        to_balance in 0u64..1_000_000_000u64,
        transfer_amount in 0u64..1_000_000_000u64,
    ) {
        // Only test valid transfers
        prop_assume!(from_balance >= transfer_amount);
        
        // Initialize test context
        let mut ctx = EvmTestContext::new();
        
        // Deploy ERC20 token contract
        let bytecode = compile_contract("ERC20.sol");
        let token = ctx.deploy_contract(bytecode, "owner").unwrap();
        
        // Set up initial balances
        ctx.call_contract(token, encode_function_call("mint(address,uint256)", &[
            Token::Address(ctx.accounts["user1"]),
            Token::Uint(U256::from(from_balance)),
        ]), "owner").unwrap();
        
        ctx.call_contract(token, encode_function_call("mint(address,uint256)", &[
            Token::Address(ctx.accounts["user2"]),
            Token::Uint(U256::from(to_balance)),
        ]), "owner").unwrap();
        
        // Get initial total supply
        let total_supply_call = encode_function_call("totalSupply()", &[]);
        let initial_total_supply = decode_uint(
            ctx.call_contract(token, total_supply_call.clone(), "owner").unwrap()
        );
        
        // Execute transfer
        ctx.call_contract(token, encode_function_call("transfer(address,uint256)", &[
            Token::Address(ctx.accounts["user2"]),
            Token::Uint(U256::from(transfer_amount)),
        ]), "user1").unwrap();
        
        // Get final total supply
        let final_total_supply = decode_uint(
            ctx.call_contract(token, total_supply_call, "owner").unwrap()
        );
        
        // Property: Total supply should not change after transfer
        prop_assert_eq!(initial_total_supply, final_total_supply);
    }
}
```

### Fuzzing Integration

Integrate REVM with fuzzing tools:

```rust
use honggfuzz::fuzz;

// Fuzzing test for token contract security
fn main() {
    // Fuzzing loop
    loop {
        fuzz!(|data: &[u8]| {
            // Minimum viable input size
            if data.len() < 32 {
                return;
            }
            
            // Initialize test context
            let mut ctx = EvmTestContext::new();
            
            // Deploy ERC20 token contract
            let bytecode = compile_contract("ERC20.sol");
            let token = match ctx.deploy_contract(bytecode, "owner") {
                Ok(address) => address,
                Err(_) => return,
            };
            
            // Initialize token
            let _ = ctx.call_contract(token, encode_function_call("mint(address,uint256)", &[
                Token::Address(ctx.accounts["owner"]),
                Token::Uint(U256::from(1000000)),
            ]), "owner");
            
            // Extract parameters from fuzz data
            let caller_idx = data[0] % 4; // 4 test accounts
            let caller = match caller_idx {
                0 => "owner",
                1 => "user1",
                2 => "user2",
                _ => "attacker",
            };
            
            // Execute random transaction using fuzz data
            let _ = ctx.call_contract(token, Bytes::from(&data[1..]), caller);
            
            // Check invariants regardless of whether the call succeeded or failed
            
            // Invariant 1: Total supply equals sum of balances
            let total_supply = match get_total_supply(&mut ctx, token) {
                Ok(supply) => supply,
                Err(_) => return,
            };
            
            let sum_of_balances = match get_sum_of_balances(&mut ctx, token) {
                Ok(sum) => sum,
                Err(_) => return,
            };
            
            assert_eq!(total_supply, sum_of_balances);
            
            // Invariant 2: Non-zero allowance required for transferFrom
            // ... additional invariant checks
        });
    }
}

fn get_total_supply(ctx: &mut EvmTestContext, token: Address) -> Result<U256, Error> {
    let total_supply_call = encode_function_call("totalSupply()", &[]);
    let result = ctx.call_contract(token, total_supply_call, "owner")?;
    Ok(decode_uint(result))
}

fn get_sum_of_balances(ctx: &mut EvmTestContext, token: Address) -> Result<U256, Error> {
    let mut sum = U256::ZERO;
    
    for account in ["owner", "user1", "user2", "attacker"] {
        let balance_call = encode_function_call("balanceOf(address)", &[
            Token::Address(ctx.accounts[account]),
        ]);
        let result = ctx.call_contract(token, balance_call, "owner")?;
        sum += decode_uint(result);
    }
    
    Ok(sum)
}
```

## Development Tool Integration

REVM can be integrated into development tools for local blockchain environments and debugging.

### Local Development Environment

Create a local development environment with REVM:

```rust
struct LocalBlockchain {
    evm: Evm<MainContext, NoopInspector, EthInstructions<EthInterpreter, MainContext>, EthPrecompiles>,
    private_keys: HashMap<Address, H256>,
    latest_block_number: u64,
    latest_block_timestamp: u64,
    mining_interval: Option<Duration>,
    pending_transactions: Vec<TxEnv>,
    tx_receipts: HashMap<B256, TransactionReceipt>,
}

impl LocalBlockchain {
    fn new() -> Self {
        // Create in-memory database
        let db = CacheDB::new(EmptyDB::default());
        
        // Create EVM instance
        let evm = Context::mainnet().with_db(db).build_mainnet();
        
        // Initialize test accounts with private keys
        let private_keys = generate_dev_accounts(&mut evm);
        
        Self {
            evm,
            private_keys,
            latest_block_number: 0,
            latest_block_timestamp: unix_timestamp(),
            mining_interval: None,
            pending_transactions: Vec::new(),
            tx_receipts: HashMap::new(),
        }
    }
    
    fn send_transaction(&mut self, tx: TransactionRequest) -> Result<B256, Error> {
        // Validate transaction
        self.validate_transaction(&tx)?;
        
        // Convert to TxEnv
        let tx_env = self.convert_to_tx_env(tx)?;
        
        // Generate transaction hash
        let tx_hash = self.generate_tx_hash(&tx_env);
        
        // Add to pending transactions
        self.pending_transactions.push(tx_env);
        
        // Auto-mine if enabled
        if self.mining_interval.is_none() {
            self.mine_block()?;
        }
        
        Ok(tx_hash)
    }
    
    fn mine_block(&mut self) -> Result<Block, Error> {
        if self.pending_transactions.is_empty() {
            return Err(Error::NoPendingTransactions);
        }
        
        // Update block info
        self.latest_block_number += 1;
        self.latest_block_timestamp = unix_timestamp();
        
        // Configure block info
        self.evm.modify_block(|b| {
            b.number = self.latest_block_number;
            b.timestamp = self.latest_block_timestamp;
        });
        
        // Execute pending transactions
        let mut block_transactions = Vec::new();
        let mut receipts = Vec::new();
        
        for tx_env in self.pending_transactions.drain(..) {
            // Configure transaction
            self.evm.modify_tx(|tx| *tx = tx_env.clone());
            
            // Generate transaction hash
            let tx_hash = self.generate_tx_hash(&tx_env);
            
            // Execute transaction
            let result = match self.evm.transact_commit() {
                Ok(result) => result,
                Err(e) => {
                    // Log failed transaction
                    println!("Transaction failed: {:?}", e);
                    continue;
                }
            };
            
            // Create transaction receipt
            let receipt = TransactionReceipt {
                transaction_hash: tx_hash,
                block_number: self.latest_block_number,
                gas_used: result.gas_used(),
                logs: result.logs().to_vec(),
                status: result.is_success(),
                // ... other receipt fields
            };
            
            // Store receipt
            self.tx_receipts.insert(tx_hash, receipt.clone());
            
            // Add to block transactions and receipts
            block_transactions.push(tx_env);
            receipts.push(receipt);
        }
        
        // Create block
        let block = Block {
            number: self.latest_block_number,
            timestamp: self.latest_block_timestamp,
            transactions: block_transactions,
            receipts,
            // ... other block fields
        };
        
        Ok(block)
    }
    
    fn get_transaction_receipt(&self, tx_hash: B256) -> Option<TransactionReceipt> {
        self.tx_receipts.get(&tx_hash).cloned()
    }
    
    // More blockchain functions...
}
```

### Debugging Integration

Integrate REVM for smart contract debugging:

```rust
use revm::inspector::{Inspector, InspectorEvmTr, JournalExt};

struct Debugger {
    breakpoints: HashMap<Address, HashSet<u64>>, // Contract address -> PC
    call_stack: Vec<Call>,
    logs: Vec<DebugLog>,
    execution_paused: bool,
}

struct Call {
    contract: Address,
    pc: u64,
    opcode: u8,
    stack: Vec<U256>,
    memory: Vec<u8>,
    storage: HashMap<U256, U256>,
    depth: usize,
}

enum DebugLog {
    Step {
        contract: Address,
        pc: u64,
        opcode: u8,
        opcode_name: String,
        stack: Vec<U256>,
        memory: Vec<u8>,
        depth: usize,
    },
    Call {
        from: Address,
        to: Address,
        value: U256,
        data: Bytes,
        depth: usize,
    },
    Return {
        from: Address,
        data: Bytes,
        depth: usize,
    },
    Storage {
        contract: Address,
        key: U256,
        old_value: U256,
        new_value: U256,
    },
}

impl Debugger {
    fn new() -> Self {
        Self {
            breakpoints: HashMap::new(),
            call_stack: Vec::new(),
            logs: Vec::new(),
            execution_paused: false,
        }
    }
    
    fn add_breakpoint(&mut self, contract: Address, pc: u64) {
        self.breakpoints
            .entry(contract)
            .or_insert_with(HashSet::new)
            .insert(pc);
    }
    
    fn remove_breakpoint(&mut self, contract: Address, pc: u64) {
        if let Some(breakpoints) = self.breakpoints.get_mut(&contract) {
            breakpoints.remove(&pc);
            if breakpoints.is_empty() {
                self.breakpoints.remove(&contract);
            }
        }
    }
    
    fn is_breakpoint_hit(&self, contract: Address, pc: u64) -> bool {
        self.breakpoints
            .get(&contract)
            .map(|breakpoints| breakpoints.contains(&pc))
            .unwrap_or(false)
    }
    
    fn continue_execution(&mut self) {
        self.execution_paused = false;
    }
    
    fn step_over(&mut self) {
        // Record current call depth
        let current_depth = self.call_stack.last().map(|call| call.depth).unwrap_or(0);
        
        // Step until we reach the same depth
        self.execution_paused = true;
        self.step_until(|debugger| {
            let depth = debugger.call_stack.last().map(|call| call.depth).unwrap_or(0);
            depth <= current_depth
        });
    }
    
    fn step_into(&mut self) {
        // Just execute one more step
        self.execution_paused = true;
    }
    
    fn step_out(&mut self) {
        // Record current call depth
        let current_depth = self.call_stack.last().map(|call| call.depth).unwrap_or(0);
        
        // Step until we reach a lower depth
        self.execution_paused = true;
        self.step_until(|debugger| {
            let depth = debugger.call_stack.last().map(|call| call.depth).unwrap_or(0);
            depth < current_depth
        });
    }
    
    fn step_until<F>(&mut self, condition: F)
    where
        F: Fn(&Self) -> bool,
    {
        self.execution_paused = true;
        // This function would normally include logic to resume execution
        // until the condition is met, but this is handled by the Inspector trait
        // in this example
    }
    
    fn get_current_state(&self) -> Option<&Call> {
        self.call_stack.last()
    }
    
    fn get_local_variables(&self, contract: Address) -> Result<HashMap<String, U256>, Error> {
        // This requires debug information for the contract
        // The implementation depends on the debug format used
        unimplemented!()
    }
}

impl<DB: DatabaseRef> Inspector<DB> for Debugger {
    fn step(&mut self, interpreter: &mut Interpreter, context: &mut EvmContext<'_, DB>) {
        // Get current execution state
        let contract = interpreter.shared.contract.address;
        let pc = interpreter.shared.pc;
        let opcode = interpreter.read_instruction();
        
        // Create a snapshot of the current state
        let call = Call {
            contract,
            pc,
            opcode,
            stack: interpreter.shared.stack.data().to_vec(),
            memory: interpreter.shared.memory.data().to_vec(),
            storage: HashMap::new(), // Would need to access storage
            depth: context.depth,
        };
        
        // Add to call stack
        self.call_stack.push(call);
        
        // Log the step
        self.logs.push(DebugLog::Step {
            contract,
            pc,
            opcode,
            opcode_name: opcode_name(opcode),
            stack: interpreter.shared.stack.data().to_vec(),
            memory: interpreter.shared.memory.data().to_vec(),
            depth: context.depth,
        });
        
        // Check if breakpoint is hit
        if self.is_breakpoint_hit(contract, pc) {
            println!("Breakpoint hit at contract {} pc {}", contract, pc);
            self.execution_paused = true;
        }
        
        // Handle paused execution
        if self.execution_paused {
            // In a real UI, this would pause execution and wait for user input
            // For this example, we just log the pause
            println!("Execution paused at contract {} pc {}", contract, pc);
        }
    }
    
    fn call(
        &mut self,
        inputs: &CallInputs,
        context: &mut EvmContext<'_, DB>,
    ) -> Option<InspectorResult> {
        // Log the call
        self.logs.push(DebugLog::Call {
            from: inputs.caller,
            to: inputs.contract,
            value: inputs.value,
            data: inputs.input.clone(),
            depth: context.depth,
        });
        
        None
    }
    
    fn call_end(
        &mut self,
        outputs: &CallOutputs,
        context: &mut EvmContext<'_, DB>,
    ) -> Option<InspectorResult> {
        // Log the return
        self.logs.push(DebugLog::Return {
            from: outputs.contract,
            data: outputs.output.clone(),
            depth: context.depth,
        });
        
        // Remove from call stack
        if !self.call_stack.is_empty() {
            self.call_stack.pop();
        }
        
        None
    }
    
    fn sstore(
        &mut self,
        contract: Address,
        key: U256,
        value: U256,
        context: &mut EvmContext<'_, DB>,
    ) -> Option<InspectorResult> {
        // Get old value
        let old_value = match context.journal.sload(contract, key) {
            Ok(slot) => slot.data,
            Err(_) => U256::ZERO,
        };
        
        // Log the storage change
        self.logs.push(DebugLog::Storage {
            contract,
            key,
            old_value,
            new_value: value,
        });
        
        None
    }
}
```

### IDE Plugin Integration

Integrate REVM with an IDE for smart contract development:

```rust
// Simplified example of IDE integration
struct RevmIdeIntegration {
    local_blockchain: LocalBlockchain,
    compiled_contracts: HashMap<String, CompiledContract>,
    active_debugger: Option<Debugger>,
}

struct CompiledContract {
    bytecode: Bytes,
    deployed_bytecode: Bytes,
    abi: Vec<AbiEntry>,
    source_map: SourceMap,
}

impl RevmIdeIntegration {
    fn new() -> Self {
        Self {
            local_blockchain: LocalBlockchain::new(),
            compiled_contracts: HashMap::new(),
            active_debugger: None,
        }
    }
    
    fn compile_contract(&mut self, source_path: &str, contract_name: &str) -> Result<(), Error> {
        // Call external compiler (e.g., solc)
        let compilation_result = compile_solidity_file(source_path, contract_name)?;
        
        // Store compiled contract
        self.compiled_contracts.insert(
            contract_name.to_string(),
            CompiledContract {
                bytecode: compilation_result.bytecode,
                deployed_bytecode: compilation_result.deployed_bytecode,
                abi: compilation_result.abi,
                source_map: compilation_result.source_map,
            },
        );
        
        Ok(())
    }
    
    fn deploy_contract(&mut self, contract_name: &str, constructor_args: &[Token], sender: Address) -> Result<Address, Error> {
        // Get compiled contract
        let contract = self.compiled_contracts.get(contract_name)
            .ok_or(Error::ContractNotCompiled)?;
        
        // Encode constructor arguments
        let encoded_args = encode_constructor_args(&contract.abi, constructor_args)?;
        
        // Combine bytecode with constructor args
        let bytecode_with_args = [&contract.bytecode[..], &encoded_args[..]].concat();
        
        // Create transaction
        let tx = TransactionRequest {
            from: sender,
            to: None, // Contract creation
            data: bytecode_with_args.into(),
            value: U256::ZERO,
            gas: 10_000_000,
            gas_price: U256::from(1),
            nonce: self.local_blockchain.get_nonce(sender)?,
        };
        
        // Send transaction
        let tx_hash = self.local_blockchain.send_transaction(tx)?;
        
        // Get receipt
        let receipt = self.local_blockchain.get_transaction_receipt(tx_hash)
            .ok_or(Error::TransactionNotFound)?;
        
        // Extract contract address
        receipt.contract_address.ok_or(Error::DeploymentFailed)
    }
    
    fn call_contract(&mut self, contract_address: Address, function_name: &str, args: &[Token], sender: Address) -> Result<Vec<Token>, Error> {
        // Find contract by address
        let contract = self.find_contract_by_address(contract_address)?;
        
        // Encode function call
        let data = encode_function_call(function_name, args, &contract.abi)?;
        
        // Create transaction
        let tx = TransactionRequest {
            from: sender,
            to: Some(contract_address),
            data,
            value: U256::ZERO,
            gas: 10_000_000,
            gas_price: U256::from(1),
            nonce: self.local_blockchain.get_nonce(sender)?,
        };
        
        // Send transaction
        let tx_hash = self.local_blockchain.send_transaction(tx)?;
        
        // Get receipt
        let receipt = self.local_blockchain.get_transaction_receipt(tx_hash)
            .ok_or(Error::TransactionNotFound)?;
        
        // Check status
        if !receipt.status {
            return Err(Error::TransactionFailed);
        }
        
        // Decode output
        decode_function_output(function_name, receipt.output.clone(), &contract.abi)
    }
    
    fn debug_transaction(&mut self, tx_hash: B256) -> Result<(), Error> {
        // Create debugger
        let mut debugger = Debugger::new();
        
        // Replay transaction with debugger
        self.local_blockchain.replay_transaction(tx_hash, &mut debugger)?;
        
        // Store active debugger
        self.active_debugger = Some(debugger);
        
        Ok(())
    }
    
    fn find_contract_by_address(&self, address: Address) -> Result<&CompiledContract, Error> {
        // This would normally check deployed contracts
        // For simplicity, we just return the first contract
        self.compiled_contracts.values().next().ok_or(Error::ContractNotFound)
    }
    
    // IDE commands
    
    fn step_over(&mut self) -> Result<(), Error> {
        if let Some(debugger) = &mut self.active_debugger {
            debugger.step_over();
            Ok(())
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
    
    fn step_into(&mut self) -> Result<(), Error> {
        if let Some(debugger) = &mut self.active_debugger {
            debugger.step_into();
            Ok(())
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
    
    fn step_out(&mut self) -> Result<(), Error> {
        if let Some(debugger) = &mut self.active_debugger {
            debugger.step_out();
            Ok(())
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
    
    fn continue_execution(&mut self) -> Result<(), Error> {
        if let Some(debugger) = &mut self.active_debugger {
            debugger.continue_execution();
            Ok(())
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
    
    fn add_breakpoint(&mut self, source_path: &str, line: u64) -> Result<(), Error> {
        if let Some(debugger) = &mut self.active_debugger {
            // Convert source line to contract address and PC
            let (contract, pc) = source_line_to_pc(source_path, line, &self.compiled_contracts)?;
            
            debugger.add_breakpoint(contract, pc);
            Ok(())
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
    
    fn get_local_variables(&self) -> Result<HashMap<String, String>, Error> {
        if let Some(debugger) = &self.active_debugger {
            // Get current call
            let call = debugger.get_current_state().ok_or(Error::NoActiveCall)?;
            
            // Find contract by address
            let contract = self.find_contract_by_address(call.contract)?;
            
            // Map PC to source location
            let source_location = pc_to_source_location(call.pc, &contract.source_map)?;
            
            // Get local variables at this location
            let variables = debugger.get_local_variables(call.contract)?;
            
            // Format variables for display
            let formatted = variables.into_iter()
                .map(|(name, value)| (name, format_value(value)))
                .collect();
                
            Ok(formatted)
        } else {
            Err(Error::NoActiveDebugger)
        }
    }
}
```

## Layer 2 Solution Integration

REVM can be used as the foundation for Layer 2 solutions:

```rust
// Simplified Optimistic Rollup implementation
struct OptimisticRollup {
    evm: Evm<MainContext, NoopInspector, OptimisticInstructions<EthInterpreter, MainContext>, OptimisticPrecompiles>,
    sequencer_address: Address,
    batch_queue: Vec<Batch>,
    confirmed_batches: Vec<Batch>,
    l1_bridge: L1Bridge,
}

struct Batch {
    batch_number: u64,
    transactions: Vec<TxEnv>,
    state_root: B256,
    timestamp: u64,
}

struct L1Bridge {
    l1_client: EthereumClient,
    rollup_contract_address: Address,
}

impl OptimisticRollup {
    fn new(db: impl Database, sequencer_address: Address, l1_client: EthereumClient, rollup_contract_address: Address) -> Self {
        // Create custom instructions for the rollup
        let instructions = OptimisticInstructions::new();
        
        // Create custom precompiles for the rollup
        let precompiles = OptimisticPrecompiles::new();
        
        // Create EVM instance
        let evm = Evm::new(Context::mainnet().with_db(db), NoopInspector, instructions, precompiles);
        
        Self {
            evm,
            sequencer_address,
            batch_queue: Vec::new(),
            confirmed_batches: Vec::new(),
            l1_bridge: L1Bridge {
                l1_client,
                rollup_contract_address,
            },
        }
    }
    
    fn submit_transaction(&mut self, tx: TxEnv) -> Result<B256, Error> {
        // Verify transaction
        self.verify_transaction(&tx)?;
        
        // Calculate transaction hash
        let tx_hash = calculate_transaction_hash(&tx);
        
        // Execute transaction
        self.evm.modify_tx(|t| *t = tx.clone());
        let result = self.evm.transact_commit()?;
        
        // If successful, add to current batch
        if result.is_success() {
            if self.batch_queue.is_empty() {
                // Create new batch
                self.batch_queue.push(Batch {
                    batch_number: self.confirmed_batches.len() as u64 + 1,
                    transactions: Vec::new(),
                    state_root: B256::zero(),
                    timestamp: unix_timestamp(),
                });
            }
            
            // Add transaction to current batch
            self.batch_queue.last_mut().unwrap().transactions.push(tx);
        }
        
        Ok(tx_hash)
    }
    
    fn finalize_batch(&mut self) -> Result<u64, Error> {
        // Ensure there's a batch to finalize
        if self.batch_queue.is_empty() {
            return Err(Error::NoBatchToFinalize);
        }
        
        // Get the current batch
        let mut batch = self.batch_queue.remove(0);
        
        // Calculate state root
        batch.state_root = self.calculate_state_root()?;
        
        // Submit batch to L1
        self.submit_batch_to_l1(&batch)?;
        
        // Add to confirmed batches
        let batch_number = batch.batch_number;
        self.confirmed_batches.push(batch);
        
        Ok(batch_number)
    }
    
    fn verify_transaction(&self, tx: &TxEnv) -> Result<(), Error> {
        // Perform L2-specific verification
        // ...
        
        Ok(())
    }
    
    fn calculate_state_root(&self) -> Result<B256, Error> {
        // Calculate state root based on EVM state
        // ...
        
        Ok(B256::zero()) // Placeholder
    }
    
    fn submit_batch_to_l1(&mut self, batch: &Batch) -> Result<(), Error> {
        // Encode batch data
        let batch_data = encode_batch_data(batch);
        
        // Create L1 transaction to submit batch
        let l1_tx = EthereumTransaction {
            to: self.l1_bridge.rollup_contract_address,
            data: batch_data,
            // ... other transaction fields
        };
        
        // Submit to L1
        self.l1_bridge.l1_client.send_transaction(l1_tx)?;
        
        Ok(())
    }
    
    fn process_l1_deposits(&mut self) -> Result<(), Error> {
        // Fetch deposit events from L1
        let deposits = self.l1_bridge.fetch_deposits()?;
        
        // Process each deposit
        for deposit in deposits {
            // Create deposit transaction
            let tx = TxEnv {
                caller: self.sequencer_address,
                kind: TxKind::Call(deposit.l2_recipient),
                value: deposit.amount,
                data: deposit.data,
                gas_limit: 1_000_000,
                gas_price: 0,
                nonce: 0, // Special nonce for deposits
                // ... other fields
            };
            
            // Execute deposit transaction
            self.evm.modify_tx(|t| *t = tx);
            let _ = self.evm.transact_commit()?;
        }
        
        Ok(())
    }
    
    // Process L2 to L1 messages (withdrawals)
    fn process_l2_to_l1_messages(&mut self) -> Result<(), Error> {
        // Fetch L2 to L1 messages from state
        let messages = self.fetch_l2_to_l1_messages()?;
        
        // Add messages to the next batch for L1 processing
        // ...
        
        Ok(())
    }
    
    fn fetch_l2_to_l1_messages(&self) -> Result<Vec<L2ToL1Message>, Error> {
        // Fetch messages from state
        // ...
        
        Ok(Vec::new()) // Placeholder
    }
}

// Custom instructions for Optimistic Rollup
struct OptimisticInstructions<I, CTX> {
    inner: EthInstructions<I, CTX>,
}

impl<CTX: ContextTr> OptimisticInstructions<EthInterpreter, CTX> {
    fn new() -> Self {
        let mut inner = EthInstructions::new_mainnet();
        
        // Modify gas costs for L2
        inner.gas_costs.sload = 100; // Reduced cost for storage reads
        inner.gas_costs.sstore_set = 1000; // Reduced cost for storage writes
        
        // Replace L1 block information opcodes
        inner.replace(
            opcode::BLOCKHASH,
            |interpreter, _| {
                // Custom L2 blockhash implementation
                // ...
                
                // Placeholder: Always return zero
                interpreter.stack.push(U256::ZERO)?;
                
                Ok(())
            },
        );
        
        // Add L2-specific opcodes
        inner.insert(
            0xF0, // Custom opcode for L2 to L1 messaging
            |interpreter, _| {
                // Pop message data from stack
                let data_len = interpreter.stack.pop()?;
                let data_offset = interpreter.stack.pop()?;
                let l1_recipient = interpreter.stack.pop()?;
                
                // Read message data from memory
                let data = interpreter.memory.get_slice(
                    data_offset.try_into().unwrap(),
                    data_len.try_into().unwrap(),
                );
                
                // Record L2 to L1 message
                // This would need to access context to store the message
                // ...
                
                Ok(())
            },
        );
        
        Self { inner }
    }
}

// Implementation of instruction provider trait
impl<CTX: ContextTr> InstructionProvider for OptimisticInstructions<EthInterpreter, CTX> {
    type Context = CTX;
    type InterpreterTypes = EthInterpreter;
    
    // Delegate to inner instructions
    // ...
}

// Custom precompiles for Optimistic Rollup
struct OptimisticPrecompiles;

impl OptimisticPrecompiles {
    fn new() -> Self {
        Self
    }
}

impl<CTX: ContextTr> PrecompileProvider<CTX> for OptimisticPrecompiles {
    type Output = InterpreterResult;
    
    fn execute(&self, address: Address, input: &[u8], gas_limit: u64, context: &mut CTX) -> Result<Self::Output, PrecompileError> {
        match address {
            // Standard Ethereum precompiles
            a if a == address!("0x0000000000000000000000000000000000000001") => {
                // ecrecover
                // ...
            },
            // ... other standard precompiles
            
            // L2-specific precompiles
            a if a == address!("0x4200000000000000000000000000000000000001") => {
                // L2 to L1 messenger
                // ...
            },
            a if a == address!("0x4200000000000000000000000000000000000002") => {
                // Gas price oracle
                // ...
            },
            _ => Err(PrecompileError::Unknown),
        }
    }
}
```

## Summary

REVM's flexible design allows for integration in various environments:

1. **Ethereum Clients**: Use REVM as the execution engine in a full node
2. **Web Services**: Build JSON-RPC APIs or REST services with REVM
3. **Testing Frameworks**: Leverage REVM for comprehensive smart contract testing
4. **Development Tools**: Create local development environments and debugging tools
5. **Layer 2 Solutions**: Build optimistic rollups and other scaling solutions

When integrating REVM, consider these best practices:

- **Database Integration**: Implement efficient database adapters for your storage backend
- **Extensibility**: Use REVM's trait-based design to extend functionality
- **Performance**: Apply appropriate caching and optimization strategies
- **Flexibility**: Leverage REVM's customization options for your specific use case

By following these patterns, you can effectively integrate REVM into your Ethereum-related projects.

## Next Steps

Now that you understand integration patterns for REVM, you might want to explore:

- [REVM Examples](../revm-examples/README.md): See real-world examples of REVM integration
- [Expert Reference: Database Components](../expert-reference/4.7-database-components.md): Learn about advanced database integration
- [Expert Reference: JSON-RPC API](../expert-reference/4.5-json-rpc-api.md): Explore detailed JSON-RPC implementation

---

**Note**: The examples in this document are simplified for clarity. Real-world implementations would include additional error handling, optimization, and integration with other components.