---
title: State Management
description: Detailed guide about state management in REVM (Rust Ethereum Virtual Machine)
---

# State Management

This tutorial covers how to work with Ethereum state in REVM. You'll learn about REVM's state model, reading and modifying account state, working with contract storage, and understanding state transitions.

## Understanding Ethereum State

Ethereum state consists of accounts, each with properties such as:

- **Balance**: The amount of Ether owned by the account
- **Nonce**: A counter of transactions sent from the account
- **Code**: Smart contract bytecode (for contract accounts)
- **Storage**: Key-value storage (for contract accounts)

In REVM, this state is managed through the database and journal components.

## State Components in REVM

REVM's state management involves several key components:

1. **Database Interface**: Provides access to external state data
2. **Journal**: Tracks state changes during execution
3. **Account**: Represents an Ethereum account with its properties
4. **Storage**: Key-value store for contract state

Let's explore how to work with each of these components.

## Setting Up the Environment

As with previous tutorials, we'll start by setting up our development environment:

```rust
use revm::{
    context::Context,
    database::{CacheDB, EmptyDB},
    primitives::{address, AccountInfo, Bytecode, TxKind, U256, B256, KECCAK_EMPTY},
    ExecuteEvm, MainBuilder, MainContext,
};

fn main() {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Now we can work with state...
}
```

## Working with Accounts

Accounts are the basic unit of state in Ethereum. Let's see how to create, read, and modify accounts.

### Creating Accounts

To create an account, we insert account information into the database:

```rust
// Define an address for the account
let account_addr = address!("0x1000000000000000000000000000000000000000");

// Create account information
let account_info = AccountInfo {
    nonce: 0,
    balance: U256::from(10000000000000000000u64), // 10 ETH
    code_hash: KECCAK_EMPTY,
    code: None, // No code for an EOA (Externally Owned Account)
};

// Insert the account into the database
db.insert_account_info(account_addr, account_info);

println!("Account created at: {}", account_addr);
```

### Reading Account State

To read account state, we query the database:

```rust
// Read account information
match db.basic_ref(account_addr) {
    Ok(Some(info)) => {
        println!("Account found:");
        println!("  Balance: {} wei", info.balance);
        println!("  Nonce: {}", info.nonce);
        println!("  Code hash: {}", info.code_hash);
        println!("  Has code: {}", info.code.is_some());
    },
    Ok(None) => println!("Account not found"),
    Err(error) => println!("Error reading account: {:?}", error),
}
```

### Modifying Account State

To modify an account, we can update its information in the database:

```rust
// Retrieve the current account info
if let Ok(Some(mut info)) = db.basic_ref(account_addr) {
    // Create an updated account with new balance and nonce
    let updated_info = AccountInfo {
        nonce: info.nonce + 1,
        balance: info.balance + U256::from(1000000000000000000u64), // Add 1 ETH
        code_hash: info.code_hash,
        code: info.code.clone(),
    };
    
    // Update the account in the database
    db.insert_account_info(account_addr, updated_info);
    
    println!("Account updated");
}
```

### Through Transaction Execution

More commonly, account state is modified through transaction execution:

```rust
// Define sender and recipient addresses
let sender = address!("0x1000000000000000000000000000000000000000");
let recipient = address!("0x2000000000000000000000000000000000000000");

// Create and execute a transaction
let mut evm = Context::mainnet()
    .with_db(db)
    .modify_tx_chained(|tx| {
        tx.caller = sender;
        tx.kind = TxKind::Call(recipient);
        tx.value = U256::from(1000000000000000000u64); // 1 ETH
        tx.gas_limit = 21000;
        tx.gas_price = U256::from(1000000000u64); // 1 Gwei
        tx.nonce = 0;
    })
    .build_mainnet();

// Execute the transaction
if let Ok(result) = evm.transact() {
    println!("Transaction executed successfully");
    
    // Examine state changes
    for (address, account) in result.state.iter() {
        println!("Changes for account: {}", address);
        
        // Check balance changes
        if let Some(balance_change) = account.balance_changed() {
            println!("  Balance change: {:+} wei", balance_change);
        }
        
        // Check nonce changes
        if account.nonce_changed() {
            println!("  New nonce: {}", account.info.nonce);
        }
    }
    
    // Get the updated database
    db = evm.db().unwrap();
}
```

## Working with Contract Storage

Contract storage is a key-value store where each contract can persist data. Let's explore how to work with storage.

### Reading Storage Values

To read a storage value:

```rust
// Define a contract address and storage slot
let contract_addr = address!("0x3000000000000000000000000000000000000000");
let storage_slot = U256::ZERO; // Storage slot 0

// Read the storage value
match db.storage_ref(contract_addr, storage_slot) {
    Ok(value) => println!("Storage value at slot {}: {}", storage_slot, value),
    Err(error) => println!("Error reading storage: {:?}", error),
}
```

### Writing Storage Values

To write a storage value directly:

```rust
// Define a value to store
let storage_value = U256::from(42);

// Insert the storage value
if let Err(error) = db.insert_account_storage(contract_addr, storage_slot, storage_value) {
    println!("Error writing storage: {:?}", error);
} else {
    println!("Storage value set at slot {}: {}", storage_slot, storage_value);
}
```

### Through Contract Execution

More commonly, storage is modified through contract execution:

```rust
// ABI-encoded call to setValue(42)
// Function selector: 0x55241077
// Argument: 0x000000000000000000000000000000000000000000000000000000000000002a (42 in hex)
let call_data = hex::decode("55241077000000000000000000000000000000000000000000000000000000000000002a").expect("Failed to decode call data");

// Execute a contract call that modifies storage
let mut evm = Context::mainnet()
    .with_db(db)
    .modify_tx_chained(|tx| {
        tx.caller = address!("0x1000000000000000000000000000000000000000");
        tx.kind = TxKind::Call(contract_addr);
        tx.data = call_data.into();
        tx.value = U256::ZERO;
        tx.gas_limit = 100000;
        tx.gas_price = U256::from(1000000000u64);
        tx.nonce = 1;
    })
    .build_mainnet();

// Execute the transaction
if let Ok(result) = evm.transact() {
    println!("Contract call executed successfully");
    
    // Examine storage changes
    for (address, account) in result.state.iter() {
        if address == &contract_addr && !account.storage.is_empty() {
            println!("Storage changes for contract: {}", address);
            for (slot, value) in account.storage.iter() {
                println!("  Slot: {}, Value: {}", slot, value.present_value());
            }
        }
    }
    
    // Get the updated database
    db = evm.db().unwrap();
}
```

## Understanding Storage Layout

Contract storage is a 2²⁵⁶-slot key-value store. Each slot is 32 bytes and can be accessed with a 256-bit key (U256).

### Simple Variable Storage

For simple variables, Solidity assigns sequential slot numbers:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {
    uint256 public value1; // Stored at slot 0
    uint256 public value2; // Stored at slot 1
    address public owner;  // Stored at slot 2
}
```

To read these values:

```rust
// Read value1 at slot 0
let slot0 = U256::ZERO;
let value1 = db.storage_ref(contract_addr, slot0).unwrap_or_default();
println!("value1: {}", value1);

// Read value2 at slot 1
let slot1 = U256::from(1);
let value2 = db.storage_ref(contract_addr, slot1).unwrap_or_default();
println!("value2: {}", value2);

// Read owner at slot 2
let slot2 = U256::from(2);
let owner_raw = db.storage_ref(contract_addr, slot2).unwrap_or_default();
// The address is padded in storage, so we need to extract it
let owner_bytes = owner_raw.to_be_bytes::<32>();
let owner = address!("0x0000000000000000000000000000000000000000")
    .with_slice(&owner_bytes[12..32]); // Last 20 bytes represent the address
println!("owner: {}", owner);
```

### Mappings

For mappings, Solidity uses a more complex scheme:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MappingStorage {
    mapping(address => uint256) public balances; // Declared at slot 0
}
```

To compute the storage slot for a mapping entry:

```rust
use revm::primitives::keccak256;

// Compute storage slot for mapping entry balances[user]
let mapping_slot = U256::ZERO; // Slot where the mapping is declared (0)
let user = address!("0x1000000000000000000000000000000000000000");

// Padding the address to 32 bytes and concatenating with the slot
let mut key_bytes = [0u8; 64];
user.to_word().to_be_bytes::<32>().iter().enumerate().for_each(|(i, b)| key_bytes[i] = *b);
mapping_slot.to_be_bytes::<32>().iter().enumerate().for_each(|(i, b)| key_bytes[32 + i] = *b);

// Hash the concatenated value to get the actual storage slot
let actual_slot = U256::from_be_bytes(keccak256(&key_bytes));

// Read the value
let balance = db.storage_ref(contract_addr, actual_slot).unwrap_or_default();
println!("balances[{}]: {}", user, balance);
```

### Arrays

For arrays, Solidity also uses hashing:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArrayStorage {
    uint256[] public values; // Declared at slot 0
}
```

To compute the storage slot for an array element:

```rust
// The length of the array is stored at the declared slot
let array_slot = U256::ZERO;
let array_length = db.storage_ref(contract_addr, array_slot).unwrap_or_default();
println!("Array length: {}", array_length);

// Compute storage slot for array element values[index]
let index = U256::from(3); // Element at index 3

// Hash the slot to get the starting position of the array data
let array_data_start = U256::from_be_bytes(keccak256(&array_slot.to_be_bytes::<32>()));

// Add the index to get the specific element's slot
let element_slot = array_data_start + index;

// Read the value
let element_value = db.storage_ref(contract_addr, element_slot).unwrap_or_default();
println!("values[{}]: {}", index, element_value);
```

## Working with Custom State Implementations

REVM allows you to implement custom state management through the `Database` trait. This is particularly useful for integrating with different storage backends or implementing specialized caching.

### Example: Custom In-Memory Database

Here's a simple example of a custom in-memory database:

```rust
use std::collections::HashMap;
use revm::database_interface::{Database, DatabaseRef, DBErrorMarker, Error as DatabaseError};
use revm::primitives::{Address, Bytecode, B256, U256};
use revm::state::AccountInfo;

// Custom error type
#[derive(Debug)]
struct CustomError;
impl std::fmt::Display for CustomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Custom database error")
    }
}
impl std::error::Error for CustomError {}
impl DBErrorMarker for CustomError {}

// Custom in-memory database
struct CustomDatabase {
    accounts: HashMap<Address, AccountInfo>,
    storage: HashMap<(Address, U256), U256>,
    blocks: HashMap<u64, B256>,
}

impl CustomDatabase {
    fn new() -> Self {
        Self {
            accounts: HashMap::new(),
            storage: HashMap::new(),
            blocks: HashMap::new(),
        }
    }
}

impl Database for CustomDatabase {
    type Error = CustomError;
    
    fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        Ok(self.accounts.get(&address).cloned())
    }
    
    fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        // For simplicity, we'll just return empty bytecode
        // In a real implementation, you would store and retrieve bytecode by hash
        Ok(Bytecode::default())
    }
    
    fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
        Ok(*self.storage.get(&(address, index)).unwrap_or(&U256::ZERO))
    }
    
    fn block_hash(&mut self, number: u64) -> Result<B256, Self::Error> {
        Ok(*self.blocks.get(&number).unwrap_or(&B256::default()))
    }
}

impl DatabaseRef for CustomDatabase {
    type Error = CustomError;
    
    fn basic_ref(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        Ok(self.accounts.get(&address).cloned())
    }
    
    fn code_by_hash_ref(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        Ok(Bytecode::default())
    }
    
    fn storage_ref(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        Ok(*self.storage.get(&(address, index)).unwrap_or(&U256::ZERO))
    }
    
    fn block_hash_ref(&self, number: u64) -> Result<B256, Self::Error> {
        Ok(*self.blocks.get(&number).unwrap_or(&B256::default()))
    }
}

// Using the custom database
fn main() {
    let mut custom_db = CustomDatabase::new();
    
    // Add an account
    let account = AccountInfo {
        nonce: 0,
        balance: U256::from(10000000000000000000u64), // 10 ETH
        code_hash: KECCAK_EMPTY,
        code: None,
    };
    custom_db.accounts.insert(address!("0x1000000000000000000000000000000000000000"), account);
    
    // Set storage
    custom_db.storage.insert((
        address!("0x1000000000000000000000000000000000000000"),
        U256::ZERO
    ), U256::from(42));
    
    // Create EVM with custom database
    let mut evm = Context::mainnet()
        .with_db(custom_db)
        .build_mainnet();
    
    // Now you can use the EVM with your custom database...
}
```

## Understanding the Journal

The Journal is REVM's mechanism for tracking state changes during execution. It allows for:

1. Tracking changes to account state
2. Tracking changes to storage
3. Reverts when execution fails

While you don't usually interact with the Journal directly, understanding it helps explain how REVM manages state transitions.

### The Journal Workflow

1. **Transaction starts**: Initial state is loaded from the database
2. **Execution proceeds**: Changes are recorded in the Journal
3. **Execution succeeds**: Changes are applied to the state
4. **Execution fails**: Journal is used to revert changes

## State Transitions and Committing Changes

After executing a transaction, you may want to commit the state changes. This is done implicitly when using the `transact_commit` method:

```rust
// Execute a transaction and commit the changes
if let Ok(result) = evm.transact_commit() {
    println!("Transaction executed and changes committed");
    println!("Gas used: {}", result.gas_used());
}
```

Alternatively, you can manually commit changes after a regular `transact` call:

```rust
// Execute a transaction
if let Ok(result) = evm.transact() {
    println!("Transaction executed successfully");
    
    // Manually commit the changes to the database
    evm.db().unwrap().commit(result.state);
    
    println!("Changes committed to the database");
}
```

## Forking State from External Sources

REVM can fork state from an external source, such as a live Ethereum network. This is useful for testing against real-world state without modifying the actual blockchain.

### Example: Forking from a JSON-RPC Provider

```rust
use revm::providers::alloy_provider::{AlloyProvider, RpcProvider};

// Create a provider for Ethereum mainnet
let provider_url = "https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY";
let provider = RpcProvider::new(provider_url);

// Create a database that forks from mainnet
let fork_db = AlloyProvider::new(provider);

// Create an EVM instance with the forked state
let mut evm = Context::mainnet()
    .with_db(fork_db)
    .build_mainnet();

// Now you can execute transactions against mainnet state
// Changes will only affect your local fork, not the actual mainnet
```

## Database Caching and Optimization

REVM provides several database wrappers to optimize state access:

### 1. CacheDB

`CacheDB` adds a caching layer over any database implementation:

```rust
// Create a cached database over the empty database
let mut db = CacheDB::new(EmptyDB::default());

// Add some state to the cache
let account = AccountInfo {
    nonce: 0,
    balance: U256::from(10000000000000000000u64), // 10 ETH
    code_hash: KECCAK_EMPTY,
    code: None,
};
db.insert_account_info(address!("0x1000000000000000000000000000000000000000"), account);

// The account is now cached and won't require an underlying database access
```

### 2. DatabaseRef Optimizations

For read-only operations, use the `DatabaseRef` trait to avoid unnecessary cloning:

```rust
// Using DatabaseRef for read-only operations
fn check_account_exists(db: &impl DatabaseRef, address: Address) -> bool {
    match db.basic_ref(address) {
        Ok(Some(_)) => true,
        _ => false,
    }
}

// Check if an account exists
let exists = check_account_exists(&db, address!("0x1000000000000000000000000000000000000000"));
println!("Account exists: {}", exists);
```

## Implementing a Custom StateManager

One of the most powerful customization points in REVM is implementing a custom StateManager. This allows you to completely control how state is accessed and modified.

Here's a simplified example of a custom StateManager implementation:

```rust
use revm::primitives::{Address, Bytecode, B256, U256};
use revm::state::AccountInfo;
use revm::database_interface::{Database, DatabaseRef, DBErrorMarker, Error as DatabaseError};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// Custom StateManager with logging
struct LoggingStateManager {
    inner_db: Arc<Mutex<CacheDB<EmptyDB>>>,
}

impl LoggingStateManager {
    fn new() -> Self {
        Self {
            inner_db: Arc::new(Mutex::new(CacheDB::new(EmptyDB::default()))),
        }
    }
    
    fn log(&self, message: &str) {
        println!("[StateManager] {}", message);
    }
}

// Custom error type
#[derive(Debug)]
struct LoggingError;
impl std::fmt::Display for LoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Logging state manager error")
    }
}
impl std::error::Error for LoggingError {}
impl DBErrorMarker for LoggingError {}

impl Database for LoggingStateManager {
    type Error = LoggingError;
    
    fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        self.log(&format!("Reading account: {}", address));
        match self.inner_db.lock().unwrap().basic(address) {
            Ok(info) => Ok(info),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        self.log(&format!("Reading code by hash: {}", code_hash));
        match self.inner_db.lock().unwrap().code_by_hash(code_hash) {
            Ok(code) => Ok(code),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
        self.log(&format!("Reading storage: {}:{}", address, index));
        match self.inner_db.lock().unwrap().storage(address, index) {
            Ok(value) => Ok(value),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn block_hash(&mut self, number: u64) -> Result<B256, Self::Error> {
        self.log(&format!("Reading block hash for block: {}", number));
        match self.inner_db.lock().unwrap().block_hash(number) {
            Ok(hash) => Ok(hash),
            Err(_) => Err(LoggingError),
        }
    }
}

impl DatabaseRef for LoggingStateManager {
    type Error = LoggingError;
    
    fn basic_ref(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        self.log(&format!("Reading account (ref): {}", address));
        match self.inner_db.lock().unwrap().basic_ref(address) {
            Ok(info) => Ok(info),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn code_by_hash_ref(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        self.log(&format!("Reading code by hash (ref): {}", code_hash));
        match self.inner_db.lock().unwrap().code_by_hash_ref(code_hash) {
            Ok(code) => Ok(code),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn storage_ref(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        self.log(&format!("Reading storage (ref): {}:{}", address, index));
        match self.inner_db.lock().unwrap().storage_ref(address, index) {
            Ok(value) => Ok(value),
            Err(_) => Err(LoggingError),
        }
    }
    
    fn block_hash_ref(&self, number: u64) -> Result<B256, Self::Error> {
        self.log(&format!("Reading block hash for block (ref): {}", number));
        match self.inner_db.lock().unwrap().block_hash_ref(number) {
            Ok(hash) => Ok(hash),
            Err(_) => Err(LoggingError),
        }
    }
}

// Using the custom StateManager
fn main() {
    let mut state_manager = LoggingStateManager::new();
    
    // Initialize some state
    {
        let mut db = state_manager.inner_db.lock().unwrap();
        
        // Add an account
        let account = AccountInfo {
            nonce: 0,
            balance: U256::from(10000000000000000000u64), // 10 ETH
            code_hash: KECCAK_EMPTY,
            code: None,
        };
        db.insert_account_info(address!("0x1000000000000000000000000000000000000000"), account);
    }
    
    // Create EVM with custom state manager
    let mut evm = Context::mainnet()
        .with_db(state_manager)
        .build_mainnet();
    
    // Execute a transaction, which will log all state accesses
    evm.modify_tx(|tx| {
        tx.caller = address!("0x1000000000000000000000000000000000000000");
        tx.kind = TxKind::Call(address!("0x2000000000000000000000000000000000000000"));
        tx.value = U256::from(1000000000000000000u64); // 1 ETH
        tx.gas_limit = 21000;
        tx.gas_price = U256::from(1000000000u64);
        tx.nonce = 0;
    });
    
    match evm.transact() {
        Ok(_) => println!("Transaction executed successfully with logging"),
        Err(error) => println!("Transaction failed: {:?}", error),
    }
}
```

## Intercepting Calls to Specific Addresses

A common use case is intercepting calls to specific addresses to run custom logic or precompiles. This can be achieved by implementing a custom StateManager that detects and handles these calls.

### Example: Call Interception

```rust
use revm::primitives::{Address, Bytecode, B256, U256, TransactTo};
use revm::context_interface::Result;
use revm::inspector::{Inspector, InspectorExecutionResult};
use revm::interpreter::interpreter_types::CreateInputs;
use revm::interpret::InstructionResultEnum;

// Custom inspector that intercepts calls to specific addresses
struct CallInterceptor {
    intercept_address: Address,
}

impl<DB: DatabaseRef> Inspector<DB> for CallInterceptor {
    // Called before each call
    fn call(
        &mut self,
        inputs: &CallInputs,
        context: &mut EvmContext<'_, DB>,
    ) -> Option<InspectorExecutionResult> {
        // Check if the call is to our target address
        if inputs.contract == self.intercept_address {
            println!("Intercepted call to: {}", self.intercept_address);
            
            // Extract the function selector (first 4 bytes of call data)
            if inputs.input.len() >= 4 {
                let selector = &inputs.input[0..4];
                println!("Function selector: 0x{}", hex::encode(selector));
                
                // Handle specific function calls
                if selector == [0x55, 0x24, 0x10, 0x77] { // selector for setValue(uint256)
                    // Custom logic for setValue
                    println!("Intercepted setValue function call");
                    
                    // You can either:
                    // 1. Let the call proceed normally
                    return None;
                    
                    // 2. Override the execution with a custom result
                    // return Some(InspectorExecutionResult {
                    //     result: InstructionResultEnum::Return,
                    //     gas: inputs.gas_limit,
                    //     output: vec![].into(),
                    // });
                }
            }
        }
        
        // Let any other calls proceed normally
        None
    }
    
    // Other inspector methods...
}

// Using the call interceptor
fn main() {
    // Create a database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up the target address we want to intercept
    let intercept_address = address!("0x3000000000000000000000000000000000000000");
    
    // Create an inspector that intercepts calls to our target
    let inspector = CallInterceptor {
        intercept_address,
    };
    
    // Create an EVM with the inspector
    let mut evm = Context::mainnet()
        .with_db(db)
        .build_mainnet()
        .with_inspector(inspector);
    
    // Set up a transaction that calls the target address
    evm.modify_tx(|tx| {
        tx.caller = address!("0x1000000000000000000000000000000000000000");
        tx.kind = TxKind::Call(intercept_address);
        
        // Call data for setValue(42)
        let call_data = hex::decode("55241077000000000000000000000000000000000000000000000000000000000000002a").expect("Failed to decode call data");
        tx.data = call_data.into();
        
        tx.value = U256::ZERO;
        tx.gas_limit = 100000;
        tx.gas_price = U256::from(1000000000u64);
        tx.nonce = 0;
    });
    
    // Execute the transaction with our inspector
    match evm.inspect_replay() {
        Ok(result) => println!("Transaction executed with interception"),
        Err(error) => println!("Transaction failed: {:?}", error),
    }
}
```

## Custom Precompiles

REVM allows you to implement custom precompiled contracts. Precompiles are special contracts that execute native code instead of EVM bytecode.

### Example: Custom Precompile

```rust
use revm::primitives::{Address, Bytes, U256};
use revm::precompile::{PrecompileError, PrecompileOutput, PrecompileResult, Precompiles};

// Define a custom precompile that doubles the input value
struct DoublerPrecompile;

impl DoublerPrecompile {
    fn execute(input: &Bytes, gas_limit: u64) -> PrecompileResult {
        // Calculate gas cost (fixed cost for this example)
        let gas_cost = 100;
        if gas_limit < gas_cost {
            return Err(PrecompileError::OutOfGas);
        }
        
        // Parse input as a U256 value
        if input.len() < 32 {
            return Err(PrecompileError::UserError);
        }
        
        let mut input_bytes = [0u8; 32];
        input_bytes.copy_from_slice(&input[0..32]);
        let value = U256::from_be_bytes(input_bytes);
        
        // Double the value
        let result = value * U256::from(2);
        
        // Return the result
        let output = Bytes::from(result.to_be_bytes::<32>().to_vec());
        
        Ok(PrecompileOutput {
            output,
            gas_used: gas_cost,
        })
    }
}

// Custom precompiles set
struct CustomPrecompiles;

impl Precompiles for CustomPrecompiles {
    fn execute(&self, address: Address, input: &Bytes, gas_limit: u64) -> PrecompileResult {
        // Check if the address matches our custom precompile
        if address == address!("0x0000000000000000000000000000000000000009") {
            return DoublerPrecompile::execute(input, gas_limit);
        }
        
        // Fall back to standard Ethereum precompiles
        let standard_precompiles = revm::precompile::EthPrecompiles::default();
        standard_precompiles.execute(address, input, gas_limit)
    }
}

// Using the custom precompile
fn main() {
    // Create a database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Create an EVM with custom precompiles
    let mut evm = revm::Evm {
        context: Context::mainnet().with_db(db),
        instructions: revm::instructions::InstructionTable::new(),
        precompiles: CustomPrecompiles,
    };
    
    // Set up a transaction that calls our custom precompile
    evm.modify_tx(|tx| {
        tx.caller = address!("0x1000000000000000000000000000000000000000");
        tx.kind = TxKind::Call(address!("0x0000000000000000000000000000000000000009")); // Our custom precompile address
        
        // Input data: a U256 value of 21
        let input_value = U256::from(21);
        tx.data = Bytes::from(input_value.to_be_bytes::<32>().to_vec());
        
        tx.value = U256::ZERO;
        tx.gas_limit = 100000;
        tx.gas_price = U256::from(1000000000u64);
        tx.nonce = 0;
    });
    
    // Execute the transaction
    match evm.transact() {
        Ok(result) => {
            println!("Precompile executed successfully");
            
            // Parse the result
            if let revm::primitives::context_interface::result::Output::Call(output) = &result.result.output {
                if output.len() == 32 {
                    let mut result_bytes = [0u8; 32];
                    result_bytes.copy_from_slice(&output[0..32]);
                    let result_value = U256::from_be_bytes(result_bytes);
                    
                    println!("Input: 21, Output: {}", result_value); // Should be 42
                }
            }
        },
        Err(error) => println!("Precompile execution failed: {:?}", error),
    }
}
```

## Summary

In this tutorial, you've learned how to:

1. Work with Ethereum account state
   - Create and read accounts
   - Modify account balances and nonces
   - Understand state changes from transactions

2. Work with contract storage
   - Read and write storage values
   - Understand storage layout for different data types
   - Track storage changes during execution

3. Implement custom state management
   - Create custom database implementations
   - Implement logging and monitoring
   - Fork state from external sources

4. Intercept calls and implement custom precompiles
   - Detect calls to specific addresses
   - Implement custom logic for intercepted calls
   - Create custom precompiled contracts

These skills provide a solid foundation for working with Ethereum state in REVM. With this knowledge, you can build complex applications that interact with and modify Ethereum state.

## Next Steps

Continue to [Next Steps](/beginner-tutorial/1.6-next-steps) to learn about additional resources and more advanced topics for working with REVM.

---

**Note:** The code examples in this tutorial are simplified for educational purposes. In production applications, you would typically need more robust error handling, optimization, and integration with other systems.