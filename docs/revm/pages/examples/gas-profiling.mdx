---
title: 3.4 Gas Profiling and Optimization
description: Detailed guide about 3.4 gas profiling and optimization in REVM (Rust Ethereum Virtual Machine)
---

# 3.4 Gas Profiling and Optimization

This example demonstrates how to profile gas usage in REVM and optimize Ethereum transactions and smart contracts for gas efficiency.

## Overview

Gas is the computational cost unit in Ethereum, and optimizing gas usage is critical for building efficient and cost-effective applications. In this example, we'll explore:

1. Measuring gas consumption for transactions and contract deployments
2. Analyzing gas usage at the operation level
3. Identifying gas optimization opportunities
4. Implementing gas-saving techniques
5. Comparing different implementation approaches

These techniques are valuable for both contract developers and tools that estimate gas costs.

## Prerequisites

To run this example, you'll need:

- Rust and Cargo installed
- Basic understanding of Ethereum gas mechanics
- Familiarity with Solidity and EVM opcodes
- The REVM crate added to your project

Add REVM and necessary dependencies to your `Cargo.toml`:

```toml
[dependencies]
revm = "4.0.0"
primitive-types = "0.12.1"
hex = "0.4.3"
ethabi = "18.0.0"
```

## Example 1: Basic Gas Measurement

Let's start by measuring gas consumption for basic transactions:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Bytes, ExecutionResult, 
        SpecId, TransactTo, TxEnv, U256 as rU256,
    },
    EVM, EvmBuilder,
};
use std::str::FromStr;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create addresses for test accounts
    let sender = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    let recipient = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up sender account with some ETH
    let sender_account = AccountInfo {
        balance: rU256::from(100_000_000_000_000_000_000u64), // 100 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    
    // Set up recipient account
    let recipient_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(recipient, recipient_account);
    
    // Create an EVM instance
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    println!("Gas Usage Measurements:\n");
    
    // 1. Measure gas for a simple ETH transfer
    let tx_env = TxEnv {
        caller: sender,
        gas_limit: 21000,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Call(recipient),
        value: rU256::from(1_000_000_000_000_000_000u64), // 1 ETH
        data: Bytes::default(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx_env;
    
    let result = evm.transact()?;
    
    match result {
        ExecutionResult::Success { gas_used, gas_refunded, .. } => {
            println!("ETH Transfer Gas Analysis:");
            println!("  Gas used: {}", gas_used);
            println!("  Gas refunded: {}", gas_refunded);
            println!("  Net gas consumption: {}", gas_used - gas_refunded);
        },
        _ => println!("ETH transfer failed"),
    }
    
    // 2. Measure gas for a contract deployment
    // Simple counter contract bytecode
    let contract_bytecode = hex::decode(
        "608060405234801561001057600080fd5b5060b28061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd146037578063d09de08a146051575b600080fd5b603d6059565b6040516048919060a2565b60405180910390f35b6057605f565b005b60005481565b60016000808282546071919060bb565b92505081905550565b6000819050919050565b609c81607f565b82525050565b600060208201905060b5600083018460a1565b92915050565b600060b58260b7565b9190505600a264697066735822122032db577b146795a0c7cb6b2f4e6fb1814b1ccdfc1234be5d10d2e56348a2fb8b64736f6c63430008110033"
    ).unwrap();
    
    let tx_env = TxEnv {
        caller: sender,
        gas_limit: 1_000_000,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Create(Bytes::default()),
        value: rU256::ZERO,
        data: contract_bytecode.into(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx_env;
    
    let result = evm.transact()?;
    
    let contract_address = match &result {
        ExecutionResult::Success { output, .. } => {
            if let revm::primitives::Output::Create(_, Some(addr)) = output {
                Some(*addr)
            } else {
                None
            }
        },
        _ => None,
    };
    
    match result {
        ExecutionResult::Success { gas_used, gas_refunded, .. } => {
            println!("\nContract Deployment Gas Analysis:");
            println!("  Gas used: {}", gas_used);
            println!("  Gas refunded: {}", gas_refunded);
            println!("  Net gas consumption: {}", gas_used - gas_refunded);
            
            // Calculate approximate cost at current gas prices
            let gas_price_gwei = 20; // Assume 20 gwei gas price
            let cost_in_eth = (gas_used as f64 - gas_refunded as f64) * gas_price_gwei as f64 * 1e-9;
            println!("  Approximate cost at {} gwei: {:.8} ETH", gas_price_gwei, cost_in_eth);
        },
        _ => println!("Contract deployment failed"),
    }
    
    // 3. Measure gas for a contract call (if deployment succeeded)
    if let Some(addr) = contract_address {
        // Call increment() on the counter contract
        // Function selector for increment()
        let increment_selector = hex::decode("d09de08a").unwrap(); // keccak256("increment()")[0:4]
        
        let tx_env = TxEnv {
            caller: sender,
            gas_limit: 100_000,
            gas_price: rU256::from(1_000_000_000u64), // 1 gwei
            transact_to: TransactTo::Call(addr),
            value: rU256::ZERO,
            data: increment_selector.into(),
            chain_id: None,
            nonce: None,
            gas_priority_fee: None,
            access_list: Vec::new(),
        };
        
        evm.env.tx = tx_env;
        
        let result = evm.transact()?;
        
        match result {
            ExecutionResult::Success { gas_used, gas_refunded, .. } => {
                println!("\nContract Call (increment) Gas Analysis:");
                println!("  Gas used: {}", gas_used);
                println!("  Gas refunded: {}", gas_refunded);
                println!("  Net gas consumption: {}", gas_used - gas_refunded);
            },
            _ => println!("Contract call failed"),
        }
    }
    
    Ok(())
}
```

This example demonstrates:

1. How to measure gas consumption for different types of transactions
2. The differences in gas costs between ETH transfers, contract deployments, and contract calls
3. How to calculate approximate costs based on gas prices

When run, this example will output something like:

```
Gas Usage Measurements:

ETH Transfer Gas Analysis:
  Gas used: 21000
  Gas refunded: 0
  Net gas consumption: 21000

Contract Deployment Gas Analysis:
  Gas used: 113182
  Gas refunded: 0
  Net gas consumption: 113182
  Approximate cost at 20 gwei: 0.00226364 ETH

Contract Call (increment) Gas Analysis:
  Gas used: 43724
  Gas refunded: 0
  Net gas consumption: 43724
```

## Example 2: Detailed Gas Analysis with an Inspector

To understand gas usage at a more granular level, we can use a custom Inspector to track gas consumption per operation:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Bytes, ExecutionResult, 
        SpecId, TransactTo, TxEnv, U256 as rU256,
    },
    Inspector, EVM, EvmBuilder,
};
use std::{collections::HashMap, str::FromStr};

// Custom inspector to track gas usage by opcode
struct GasProfiler {
    opcode_gas: HashMap<u8, u64>,
    current_opcode: Option<u8>,
    current_gas: u64,
}

impl GasProfiler {
    fn new() -> Self {
        Self {
            opcode_gas: HashMap::new(),
            current_opcode: None,
            current_gas: 0,
        }
    }
    
    fn gas_by_opcode(&self) -> &HashMap<u8, u64> {
        &self.opcode_gas
    }
    
    fn get_opcode_name(opcode: u8) -> &'static str {
        match opcode {
            0x00 => "STOP",
            0x01 => "ADD",
            0x02 => "MUL",
            0x03 => "SUB",
            0x04 => "DIV",
            0x05 => "SDIV",
            0x06 => "MOD",
            0x07 => "SMOD",
            0x08 => "ADDMOD",
            0x09 => "MULMOD",
            0x0a => "EXP",
            0x0b => "SIGNEXTEND",
            0x10 => "LT",
            0x11 => "GT",
            0x12 => "SLT",
            0x13 => "SGT",
            0x14 => "EQ",
            0x15 => "ISZERO",
            0x16 => "AND",
            0x17 => "OR",
            0x18 => "XOR",
            0x19 => "NOT",
            0x1a => "BYTE",
            0x1b => "SHL",
            0x1c => "SHR",
            0x1d => "SAR",
            0x20 => "SHA3",
            0x30 => "ADDRESS",
            0x31 => "BALANCE",
            0x32 => "ORIGIN",
            0x33 => "CALLER",
            0x34 => "CALLVALUE",
            0x35 => "CALLDATALOAD",
            0x36 => "CALLDATASIZE",
            0x37 => "CALLDATACOPY",
            0x38 => "CODESIZE",
            0x39 => "CODECOPY",
            0x3a => "GASPRICE",
            0x3b => "EXTCODESIZE",
            0x3c => "EXTCODECOPY",
            0x3d => "RETURNDATASIZE",
            0x3e => "RETURNDATACOPY",
            0x3f => "EXTCODEHASH",
            0x40 => "BLOCKHASH",
            0x41 => "COINBASE",
            0x42 => "TIMESTAMP",
            0x43 => "NUMBER",
            0x44 => "DIFFICULTY",
            0x45 => "GASLIMIT",
            0x46 => "CHAINID",
            0x47 => "SELFBALANCE",
            0x48 => "BASEFEE",
            0x50 => "POP",
            0x51 => "MLOAD",
            0x52 => "MSTORE",
            0x53 => "MSTORE8",
            0x54 => "SLOAD",
            0x55 => "SSTORE",
            0x56 => "JUMP",
            0x57 => "JUMPI",
            0x58 => "PC",
            0x59 => "MSIZE",
            0x5a => "GAS",
            0x5b => "JUMPDEST",
            0x60 => "PUSH1",
            0x61 => "PUSH2",
            0x62 => "PUSH3",
            0x63 => "PUSH4",
            0x64 => "PUSH5",
            0x65 => "PUSH6",
            0x66 => "PUSH7",
            0x67 => "PUSH8",
            0x68 => "PUSH9",
            0x69 => "PUSH10",
            0x6a => "PUSH11",
            0x6b => "PUSH12",
            0x6c => "PUSH13",
            0x6d => "PUSH14",
            0x6e => "PUSH15",
            0x6f => "PUSH16",
            0x70 => "PUSH17",
            0x71 => "PUSH18",
            0x72 => "PUSH19",
            0x73 => "PUSH20",
            0x74 => "PUSH21",
            0x75 => "PUSH22",
            0x76 => "PUSH23",
            0x77 => "PUSH24",
            0x78 => "PUSH25",
            0x79 => "PUSH26",
            0x7a => "PUSH27",
            0x7b => "PUSH28",
            0x7c => "PUSH29",
            0x7d => "PUSH30",
            0x7e => "PUSH31",
            0x7f => "PUSH32",
            0x80 => "DUP1",
            0x81 => "DUP2",
            0x82 => "DUP3",
            0x83 => "DUP4",
            0x84 => "DUP5",
            0x85 => "DUP6",
            0x86 => "DUP7",
            0x87 => "DUP8",
            0x88 => "DUP9",
            0x89 => "DUP10",
            0x8a => "DUP11",
            0x8b => "DUP12",
            0x8c => "DUP13",
            0x8d => "DUP14",
            0x8e => "DUP15",
            0x8f => "DUP16",
            0x90 => "SWAP1",
            0x91 => "SWAP2",
            0x92 => "SWAP3",
            0x93 => "SWAP4",
            0x94 => "SWAP5",
            0x95 => "SWAP6",
            0x96 => "SWAP7",
            0x97 => "SWAP8",
            0x98 => "SWAP9",
            0x99 => "SWAP10",
            0x9a => "SWAP11",
            0x9b => "SWAP12",
            0x9c => "SWAP13",
            0x9d => "SWAP14",
            0x9e => "SWAP15",
            0x9f => "SWAP16",
            0xa0 => "LOG0",
            0xa1 => "LOG1",
            0xa2 => "LOG2",
            0xa3 => "LOG3",
            0xa4 => "LOG4",
            0xf0 => "CREATE",
            0xf1 => "CALL",
            0xf2 => "CALLCODE",
            0xf3 => "RETURN",
            0xf4 => "DELEGATECALL",
            0xf5 => "CREATE2",
            0xfa => "STATICCALL",
            0xfd => "REVERT",
            0xfe => "INVALID",
            0xff => "SELFDESTRUCT",
            _ => "UNKNOWN",
        }
    }
}

impl Inspector for GasProfiler {
    fn step(&mut self, interp: &mut revm::interpreter::Interpreter, _data: &mut dyn revm::inspector::Host) -> revm::interpreter::InstructionResult {
        // Record the current opcode and gas before execution
        let opcode = interp.current_opcode();
        self.current_opcode = Some(opcode);
        self.current_gas = interp.gas().remaining();
        
        revm::interpreter::InstructionResult::Continue
    }
    
    fn step_end(&mut self, interp: &mut revm::interpreter::Interpreter, _data: &mut dyn revm::inspector::Host, _res: revm::interpreter::InstructionResult) {
        // Calculate gas used by comparing before and after
        if let Some(opcode) = self.current_opcode {
            let gas_after = interp.gas().remaining();
            let gas_used = self.current_gas - gas_after;
            
            // Add to the total for this opcode
            *self.opcode_gas.entry(opcode).or_insert(0) += gas_used;
            
            // Clear current opcode
            self.current_opcode = None;
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Set up accounts as before
    let sender = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up sender account with some ETH
    let sender_account = AccountInfo {
        balance: rU256::from(100_000_000_000_000_000_000u64), // 100 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    
    // Create an EVM instance
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    // Contract bytecode for a more complex example
    // Contract with various operations to analyze
    let contract_bytecode = hex::decode(
        // Example contract with various operations:
        // - Storage operations
        // - Math operations
        // - Memory operations
        // - Control flow
        "608060405234801561001057600080fd5b5061015c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea2646970667358221220ec607d669b36f5c89ec6d8b26f61133e56344a055055f4694ace95de36e8795464736f6c63430008120033"
    ).unwrap();
    
    let tx_env = TxEnv {
        caller: sender,
        gas_limit: 1_000_000,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Create(Bytes::default()),
        value: rU256::ZERO,
        data: contract_bytecode.into(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx_env;
    
    // Create and use the gas profiler
    let mut profiler = GasProfiler::new();
    let result = evm.inspect_commit(&mut profiler)?;
    
    match result {
        ExecutionResult::Success { gas_used, gas_refunded, .. } => {
            println!("Contract Deployment Gas Analysis:");
            println!("  Total gas used: {}", gas_used);
            println!("  Gas refunded: {}", gas_refunded);
            println!("  Net gas consumption: {}", gas_used - gas_refunded);
            
            println!("\nGas usage breakdown by opcode:");
            
            // Sort opcodes by gas used (highest first)
            let mut opcodes: Vec<(u8, u64)> = profiler.gas_by_opcode().iter()
                .map(|(&opcode, &gas)| (opcode, gas))
                .collect();
            opcodes.sort_by(|a, b| b.1.cmp(&a.1));
            
            println!("{:<12} {:<12} {:<8}", "OPCODE", "GAS USED", "% OF TOTAL");
            println!("{:-<35}", "");
            
            let mut total_accounted = 0u64;
            for (opcode, gas) in opcodes {
                let percentage = (gas as f64 / gas_used as f64) * 100.0;
                println!("{:<12} {:<12} {:.2}%", 
                    GasProfiler::get_opcode_name(opcode), 
                    gas,
                    percentage
                );
                total_accounted += gas;
            }
            
            println!("{:-<35}", "");
            let percentage = (total_accounted as f64 / gas_used as f64) * 100.0;
            println!("{:<12} {:<12} {:.2}%", "TOTAL", total_accounted, percentage);
            
            // Report gas not accounted for by opcode profiling
            let remaining = gas_used - total_accounted;
            if remaining > 0 {
                let percentage = (remaining as f64 / gas_used as f64) * 100.0;
                println!("{:<12} {:<12} {:.2}%", "OTHER", remaining, percentage);
            }
            
            // Print gas optimization recommendations
            println!("\nGas Optimization Recommendations:");
            
            // Check for expensive storage operations
            if let Some(&sstore_gas) = profiler.gas_by_opcode().get(&0x55) { // SSTORE
                if sstore_gas > 5000 {
                    println!("- High storage usage detected: {} gas for SSTORE operations", sstore_gas);
                    println!("  Consider optimizing storage patterns to reduce gas costs");
                }
            }
            
            // Check for expensive operations like SHA3
            if let Some(&sha3_gas) = profiler.gas_by_opcode().get(&0x20) { // SHA3
                if sha3_gas > 1000 {
                    println!("- High hashing costs: {} gas for SHA3 operations", sha3_gas);
                    println!("  Consider caching hash results when possible");
                }
            }
        },
        _ => println!("Contract deployment failed"),
    }
    
    Ok(())
}
```

This example demonstrates:

1. Creating a custom `Inspector` to track gas usage per opcode
2. Recording the gas used for each EVM operation
3. Analyzing which opcodes consume the most gas
4. Providing optimization recommendations based on the gas profile

When run, this example will produce a detailed breakdown of gas usage by opcode, which is valuable for identifying optimization opportunities.

## Example 3: Comparing Gas Efficiency of Different Implementations

Let's compare the gas efficiency of different implementation approaches:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Bytes, ExecutionResult, 
        SpecId, TransactTo, TxEnv, U256 as rU256,
    },
    EVM, EvmBuilder,
};
use std::str::FromStr;

fn deploy_contract(
    evm: &mut EVM<CacheDB<EmptyDB>>,
    bytecode: Vec<u8>,
    sender: H160
) -> Result<H160, Box<dyn std::error::Error>> {
    let tx_env = TxEnv {
        caller: sender,
        gas_limit: 2_000_000,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Create(Bytes::default()),
        value: rU256::ZERO,
        data: bytecode.into(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx_env;
    
    let result = evm.transact_commit()?;
    
    match result {
        ExecutionResult::Success { output, gas_used, .. } => {
            println!("Contract deployed. Gas used: {}", gas_used);
            
            match output {
                revm::primitives::Output::Create(_, Some(addr)) => Ok(addr),
                _ => Err("Failed to extract contract address".into()),
            }
        },
        _ => Err("Contract deployment failed".into()),
    }
}

fn call_contract(
    evm: &mut EVM<CacheDB<EmptyDB>>,
    contract_address: H160,
    call_data: Vec<u8>,
    sender: H160
) -> Result<(u64, Bytes), Box<dyn std::error::Error>> {
    let tx_env = TxEnv {
        caller: sender,
        gas_limit: 1_000_000,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Call(contract_address),
        value: rU256::ZERO,
        data: call_data.into(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx_env;
    
    let result = evm.transact()?;
    
    match result {
        ExecutionResult::Success { output, gas_used, .. } => {
            match output {
                revm::primitives::Output::Call(data) => Ok((gas_used, data)),
                _ => Err("Unexpected output type".into()),
            }
        },
        ExecutionResult::Revert { output, gas_used } => {
            println!("Contract call reverted. Gas used: {}", gas_used);
            println!("Revert reason: 0x{}", hex::encode(&output));
            Err("Contract call reverted".into())
        },
        ExecutionResult::Halt { reason, gas_used } => {
            println!("Contract call halted: {:?}. Gas used: {}", reason, gas_used);
            Err("Contract call halted".into())
        },
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let sender = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up sender account with some ETH
    let sender_account = AccountInfo {
        balance: rU256::from(100_000_000_000_000_000_000u64), // 100 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    
    // Create an EVM instance
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    println!("Gas Efficiency Comparison\n");
    
    // First implementation: using storage for intermediate values
    println!("Implementation 1: Using Storage");
    
    // Bytecode for a contract that uses storage for intermediate values:
    // pragma solidity ^0.8.0;
    // contract StorageHeavy {
    //     uint256 private a;
    //     uint256 private b;
    //     uint256 private c;
    //     
    //     function calculate(uint256 x, uint256 y) public returns (uint256) {
    //         a = x * x;
    //         b = y * y;
    //         c = a + b;
    //         return c;
    //     }
    // }
    let storage_heavy_bytecode = hex::decode("608060405234801561001057600080fd5b50610195806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80639a7841f514610030575b600080fd5b61004a600480360381019061004591906100f8565b610060565b60405161005791906100d1565b60405180910390f35b60008160026000828254610074919061012a565b92505081905550806001600082825461008d919061012a565b92505081905550600260005461010260026101029190610160565b600160008282546100b3919061012a565b925050819055506000549050919050565b6000819050919050565b6100cb816100b8565b82525050565b60006020820190506100e660008301846100c2565b92915050565b600080fd5b610109816100b8565b811461011457600080fd5b50565b60008135905061012681610100565b92915050565b60006002820360b08413156101445761014361018f565b5b60008313156101575761015661018f565b5b80915050919050565b6000610115826101ac565b915060008201836101295761012961018f565b5b81915050919050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b60006101b7826100b8565b91506101c2836100b8565b92508282026101d0816100b8565b91506000821480156101ed57506000905083600082146101e88561018f565b8214905061012756fea2646970667358221220eab229c5ee32c88c3bb55f5a87e5b1e0bc0d3e1a9c5bf8d2f29ea1c2fb4fd84864736f6c63430008120033").unwrap();
    
    let storage_contract = deploy_contract(&mut evm, storage_heavy_bytecode, sender)?;
    
    // Call the calculate function with parameters
    let calculate_signature = "9a7841f5"; // keccak256("calculate(uint256,uint256)")[0:4]
    let x = U256::from(123u64);
    let y = U256::from(456u64);
    
    // Encode parameters (x and y padded to 32 bytes each)
    let mut call_data = hex::decode(calculate_signature).unwrap();
    let mut x_encoded = vec![0u8; 32];
    let mut y_encoded = vec![0u8; 32];
    x.to_big_endian(&mut x_encoded);
    y.to_big_endian(&mut y_encoded);
    call_data.extend_from_slice(&x_encoded);
    call_data.extend_from_slice(&y_encoded);
    
    let (gas_used_storage, _) = call_contract(&mut evm, storage_contract, call_data, sender)?;
    println!("  Gas used: {}", gas_used_storage);
    
    // Second implementation: using memory for intermediate values
    println!("\nImplementation 2: Using Memory");
    
    // Bytecode for a contract that uses memory for intermediate values:
    // pragma solidity ^0.8.0;
    // contract MemoryEfficient {
    //     function calculate(uint256 x, uint256 y) public pure returns (uint256) {
    //         uint256 a = x * x;
    //         uint256 b = y * y;
    //         uint256 c = a + b;
    //         return c;
    //     }
    // }
    let memory_efficient_bytecode = hex::decode("608060405234801561001057600080fd5b50610107806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80639a7841f514602d575b600080fd5b603c603836600460ae565b604e565b60405160479190608d565b60405180910390f35b600082820a82820a01905092915050565b60007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8213606e5760916089565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f80543f565b634e487b7160e01b600052601160045260246000fd5b600060a08284031215609f57609e5760c5565b5b5050600080fd5b60006001820360085360c65760c55760c5565b5b809150509291505056fea2646970667358221220d23f4e6e51fbc2ce6c4c69d85ed5fc0c9b75b09a2a4da17a66ad6f23e5b9c5c464736f6c63430008120033").unwrap();
    
    let memory_contract = deploy_contract(&mut evm, memory_efficient_bytecode, sender)?;
    
    // Call with the same parameters
    let (gas_used_memory, _) = call_contract(&mut evm, memory_contract, call_data, sender)?;
    println!("  Gas used: {}", gas_used_memory);
    
    // Third implementation: using bitwise operations
    println!("\nImplementation 3: Using Bitwise Operations");
    
    // Bytecode for a contract that uses bitshifts for powers of 2:
    // pragma solidity ^0.8.0;
    // contract BitwiseOptimized {
    //     function calculate(uint256 x, uint256 y) public pure returns (uint256) {
    //         // Assuming x and y are powers of 2, we can use shifts
    //         // This only works for specific cases, but shows optimization potential
    //         uint256 log2x = log2(x);
    //         uint256 log2y = log2(y);
    //         uint256 a = 1 << (log2x * 2); // x^2
    //         uint256 b = 1 << (log2y * 2); // y^2
    //         return a + b;
    //     }
    //     
    //     function log2(uint256 value) internal pure returns (uint256) {
    //         uint256 result = 0;
    //         uint256 temp = value;
    //         while (temp >>= 1 > 0) {
    //             result += 1;
    //         }
    //         return result;
    //     }
    // }
    let bitwise_bytecode = hex::decode("608060405234801561001057600080fd5b50610176806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80639a7841f514610030575b600080fd5b61004a600480360381019061004591906100c4565b610060565b60405161005791906100fc565b60405180910390f35b600061006c83836100ad565b61007591610117565b1061007e57fe5b60008214801561008c57508183145b9050600080fd5b634e487b7160e01b600052601160045260246000fd5b6000819050919050565b6100be816100ab565b81146100c957600080fd5b50565b6000813590506100db816100b5565b92915050565b6100ea816100ab565b82525050565b600061010a6040820184604063ffffffff1b038286335af13d5f565b92915050565b600061012382610122565b6000610149826100ab565b91506101548361006c565b92508282036101625782610159565b5b5060010190506100c957fe5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220ab0e2a9af4a5e5ae33d8a0c8d3ffc74d3e39e20a0e1ac07a64d9f64dbecc7efd64736f6c63430008120033").unwrap();
    
    // This implementation works only for powers of 2, so we'll use different values
    // We'll use x=8, y=16 which are powers of 2
    let x_power2 = U256::from(8u64);
    let y_power2 = U256::from(16u64);
    
    let mut call_data_power2 = hex::decode(calculate_signature).unwrap();
    let mut x_power2_encoded = vec![0u8; 32];
    let mut y_power2_encoded = vec![0u8; 32];
    x_power2.to_big_endian(&mut x_power2_encoded);
    y_power2.to_big_endian(&mut y_power2_encoded);
    call_data_power2.extend_from_slice(&x_power2_encoded);
    call_data_power2.extend_from_slice(&y_power2_encoded);
    
    let bitwise_contract = deploy_contract(&mut evm, bitwise_bytecode, sender)?;
    
    match call_contract(&mut evm, bitwise_contract, call_data_power2.clone(), sender) {
        Ok((gas_used_bitwise, _)) => {
            println!("  Gas used: {}", gas_used_bitwise);
            
            // Calculate gas savings
            println!("\nGas Savings Comparison:");
            println!("  Storage vs. Memory: {} gas ({:.2}% reduction)", 
                     gas_used_storage - gas_used_memory,
                     ((gas_used_storage - gas_used_memory) as f64 / gas_used_storage as f64) * 100.0);
            
            println!("  Storage vs. Bitwise: {} gas ({:.2}% reduction)", 
                     gas_used_storage - gas_used_bitwise,
                     ((gas_used_storage - gas_used_bitwise) as f64 / gas_used_storage as f64) * 100.0);
        },
        Err(e) => {
            println!("  Bitwise implementation failed: {}", e);
            println!("  Note: The bitwise implementation only works for powers of 2");
            
            // Compare just the first two implementations
            println!("\nGas Savings Comparison:");
            println!("  Storage vs. Memory: {} gas ({:.2}% reduction)", 
                     gas_used_storage - gas_used_memory,
                     ((gas_used_storage - gas_used_memory) as f64 / gas_used_storage as f64) * 100.0);
        }
    }
    
    Ok(())
}
```

This example demonstrates:

1. Comparing different implementation approaches for gas efficiency
2. Deploying and calling multiple contract implementations
3. Measuring and comparing gas usage between implementations
4. Calculating percentage savings from optimizations

The example compares three implementations of the same functionality:
- Using storage variables (most expensive)
- Using memory variables (more efficient)
- Using bitwise operations (most efficient for specific cases)

## Gas Optimization Strategies

Based on the examples above, here are some key gas optimization strategies:

### 1. Storage Optimization

The most expensive operations in Ethereum are related to storage:

```rust
// Helper function to analyze storage costs
fn analyze_storage_costs(profiler: &GasProfiler) {
    let sload_gas = profiler.gas_by_opcode().get(&0x54).cloned().unwrap_or(0); // SLOAD
    let sstore_gas = profiler.gas_by_opcode().get(&0x55).cloned().unwrap_or(0); // SSTORE
    
    println!("Storage Operation Costs:");
    println!("  SLOAD operations: {} gas", sload_gas);
    println!("  SSTORE operations: {} gas", sstore_gas);
    println!("  Total storage gas: {} gas", sload_gas + sstore_gas);
    
    // Tips for storage optimization
    println!("\nStorage Optimization Tips:");
    println!("1. Use memory instead of storage for intermediate values");
    println!("2. Pack multiple values into a single storage slot (e.g., using uint128 instead of uint256)");
    println!("3. Cache storage values in memory when accessed multiple times");
    println!("4. Use immutable variables for constants");
    println!("5. Remove unnecessary storage variables");
}
```

### 2. Computation Optimization

Complex computations can also consume significant gas:

```rust
// Helper function to analyze computation costs
fn analyze_computation_costs(profiler: &GasProfiler) {
    // Math operations
    let add_gas = profiler.gas_by_opcode().get(&0x01).cloned().unwrap_or(0); // ADD
    let mul_gas = profiler.gas_by_opcode().get(&0x02).cloned().unwrap_or(0); // MUL
    let div_gas = profiler.gas_by_opcode().get(&0x04).cloned().unwrap_or(0); // DIV
    let exp_gas = profiler.gas_by_opcode().get(&0x0a).cloned().unwrap_or(0); // EXP
    
    println!("Computation Costs:");
    println!("  ADD operations: {} gas", add_gas);
    println!("  MUL operations: {} gas", mul_gas);
    println!("  DIV operations: {} gas", div_gas);
    println!("  EXP operations: {} gas", exp_gas);
    
    // Tips for computation optimization
    println!("\nComputation Optimization Tips:");
    println!("1. Use bitwise operations instead of arithmetic when possible");
    println!("2. Cache results of expensive calculations");
    println!("3. Minimize the use of exponentiation (very expensive)");
    println!("4. Use pre-computed values for known constants");
    println!("5. Batch calculations to reduce redundant operations");
}
```

### 3. Memory and Stack Optimization

Memory operations are cheaper than storage but still have costs:

```rust
// Helper function to analyze memory usage
fn analyze_memory_usage(profiler: &GasProfiler) {
    let mload_gas = profiler.gas_by_opcode().get(&0x51).cloned().unwrap_or(0); // MLOAD
    let mstore_gas = profiler.gas_by_opcode().get(&0x52).cloned().unwrap_or(0); // MSTORE
    
    println!("Memory Operation Costs:");
    println!("  MLOAD operations: {} gas", mload_gas);
    println!("  MSTORE operations: {} gas", mstore_gas);
    
    // Tips for memory optimization
    println!("\nMemory Optimization Tips:");
    println!("1. Reuse memory space rather than allocating new memory");
    println!("2. Minimize the amount of data passed between functions");
    println!("3. Use stack variables for single-use values rather than memory");
    println!("4. Be careful with dynamic arrays which can expand memory usage");
}
```

### 4. Contract Size Optimization

The deployment cost is directly proportional to the contract size:

```rust
// Helper function to analyze code size costs
fn analyze_contract_size(bytecode: &[u8]) {
    let size = bytecode.len();
    
    println!("Contract Size Analysis:");
    println!("  Bytecode size: {} bytes", size);
    
    // Rough gas cost estimate
    let base_cost = 32000; // Base cost for contract creation
    let byte_cost = 200; // Gas per byte of code
    let estimated_gas = base_cost + (size * byte_cost);
    
    println!("  Estimated deployment gas (code only): {}", estimated_gas);
    
    // Tips for size optimization
    println!("\nContract Size Optimization Tips:");
    println!("1. Use libraries for common functionality");
    println!("2. Remove unused functions and variables");
    println!("3. Simplify complex logic where possible");
    println!("4. Use modifiers carefully (they copy code)");
    println!("5. Consider contract factoring for very large contracts");
}
```

## Best Practices for Gas Optimization

Based on the analysis in the examples, here are some best practices for gas optimization:

1. **Avoid Unnecessary Storage Operations**
   - Storage operations (SLOAD, SSTORE) are the most expensive
   - Use memory for intermediate values
   - Cache storage values when accessed multiple times

2. **Optimize Data Types**
   - Use the smallest data type that can hold your value
   - Pack multiple values into a single storage slot
   - Use bytes32 instead of string when possible

3. **Use Efficient Algorithms**
   - Prefer linear algorithms over quadratic ones
   - Use bitwise operations instead of arithmetic when possible
   - Avoid loops with unpredictable length

4. **Minimize Contract Size**
   - Remove unused functions and variables
   - Use libraries for common functionality
   - Compress recurring patterns

5. **Use Gas Profiling for Targeted Optimization**
   - Profile your contracts to identify gas hotspots
   - Focus optimization efforts on the most expensive operations
   - Benchmark different implementations for comparison

## Conclusion

This example has demonstrated various techniques for gas profiling and optimization with REVM, including:

1. Measuring gas consumption for different types of transactions
2. Analyzing gas usage at the opcode level
3. Comparing gas efficiency of different implementation approaches
4. Strategies for optimizing storage, computation, and memory usage

By applying these techniques, you can significantly reduce the gas costs of your Ethereum transactions and smart contracts.

## Next Steps

- Explore [Custom Tracing and Debugging](/examples/3.5-tracing-debugging) for deeper execution analysis
- Learn about [Block Explorer Implementation](/examples/3.6-block-explorer) for analyzing transactions
- Try [Forking from a Live Network](/examples/3.7-forking-network) to test optimizations against real network states