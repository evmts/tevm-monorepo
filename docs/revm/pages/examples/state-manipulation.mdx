---
title: 3.3 EVM State Manipulation
description: Detailed guide about 3.3 evm state manipulation in REVM (Rust Ethereum Virtual Machine)
---

# 3.3 EVM State Manipulation

This example demonstrates how to directly manipulate the Ethereum state using REVM. We'll cover modifying accounts, storage, and handling state snapshots and rollbacks.

## Overview

Direct state manipulation is a powerful feature of REVM that allows you to:

1. Create and modify accounts (balance, nonce, code)
2. Modify contract storage values
3. Take snapshots of the state and roll back when needed
4. Create custom state implementations

These capabilities are particularly useful for testing, debugging, and creating specialized blockchain environments.

## Prerequisites

To run this example, you'll need:

- Rust and Cargo installed
- Basic understanding of Ethereum state model
- The REVM crate added to your project

Add REVM and necessary dependencies to your `Cargo.toml`:

```toml
[dependencies]
revm = "4.0.0"
primitive-types = "0.12.1"
hex = "0.4.3"
```

## Example 1: Account Management

First, let's explore how to create and modify accounts:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Env, SpecId, U256 as rU256,
    },
    Database, EVM, EvmBuilder,
};
use std::str::FromStr;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // 1. Create a new EOA (Externally Owned Account)
    let eoa_address = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    
    println!("Creating EOA account: {:?}", eoa_address);
    
    let eoa_account = AccountInfo {
        balance: rU256::from(10_000_000_000_000_000_000u64), // 10 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    
    db.insert_account_info(eoa_address, eoa_account.clone());
    
    // Verify account was created
    if let Some(account) = db.basic(eoa_address)? {
        println!("EOA created successfully:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
        println!("  Has code: {}", account.code.is_some());
    } else {
        println!("Error: Failed to retrieve account");
    }
    
    // 2. Create a contract account
    let contract_address = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    println!("\nCreating contract account: {:?}", contract_address);
    
    // Simple storage contract bytecode
    let contract_bytecode = hex::decode("608060405234801561001057600080fd5b50600436106100365760003560e01c80633fa4f2451461003b5780635524107714610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea2646970667358221220bae4769072803a54cc38051cd304f8940ffbe1dc057c5a1ff4da16ca9f4fbb7364736f6c634300080d0033").unwrap();
    
    let contract_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ONE, // Contracts are usually created with a transaction, so nonce = 1
        code_hash: H256::random(), // In a real scenario, you would compute the keccak256 hash of the code
        code: Some(Bytecode::new_raw(contract_bytecode.into())),
    };
    
    db.insert_account_info(contract_address, contract_account.clone());
    
    // Verify contract was created
    if let Some(account) = db.basic(contract_address)? {
        println!("Contract created successfully:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
        println!("  Has code: {}", account.code.is_some());
        if let Some(code) = &account.code {
            println!("  Code size: {} bytes", code.len());
        }
    } else {
        println!("Error: Failed to retrieve contract account");
    }
    
    // 3. Modify account properties
    println!("\nModifying EOA account:");
    
    // Increase balance
    let mut updated_eoa = eoa_account.clone();
    updated_eoa.balance = rU256::from(20_000_000_000_000_000_000u64); // 20 ETH
    updated_eoa.nonce = rU256::from(5u64); // Increase nonce as if 5 transactions were sent
    
    db.insert_account_info(eoa_address, updated_eoa);
    
    // Verify changes
    if let Some(account) = db.basic(eoa_address)? {
        println!("EOA updated successfully:");
        println!("  New balance: {} wei", account.balance);
        println!("  New nonce: {}", account.nonce);
    }
    
    // 4. Delete an account
    println!("\nDeleting an account:");
    
    // Create a temporary account to delete
    let temp_address = H160::from_str("0x3000000000000000000000000000000000000000").unwrap();
    let temp_account = AccountInfo {
        balance: rU256::from(1_000_000_000_000_000_000u64), // 1 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    
    db.insert_account_info(temp_address, temp_account);
    
    println!("Created temporary account: {:?}", temp_address);
    
    // Verify it exists
    println!("Account exists: {}", db.basic(temp_address)?.is_some());
    
    // Delete by setting to None
    db.insert_account_info(temp_address, None);
    
    // Verify it's gone
    println!("Account exists after deletion: {}", db.basic(temp_address)?.is_some());
    
    println!("Account state manipulation complete!");
    
    Ok(())
}
```

This example demonstrates:

1. Creating regular (EOA) accounts
2. Creating contract accounts with code
3. Modifying existing accounts (balance, nonce)
4. Deleting accounts from the state

## Example 2: Contract Storage Manipulation

Now let's manipulate contract storage directly:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Env, SpecId, U256 as rU256,
    },
    Database, StateDB, EVM, EvmBuilder,
};
use std::str::FromStr;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // 1. Create a contract account
    let contract_address = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    println!("Creating contract account: {:?}", contract_address);
    
    // Simple storage contract bytecode (same as previous example)
    let contract_bytecode = hex::decode("608060405234801561001057600080fd5b50600436106100365760003560e01c80633fa4f2451461003b5780635524107714610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea2646970667358221220bae4769072803a54cc38051cd304f8940ffbe1dc057c5a1ff4da16ca9f4fbb7364736f6c634300080d0033").unwrap();
    
    let contract_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ONE,
        code_hash: H256::random(),
        code: Some(Bytecode::new_raw(contract_bytecode.into())),
    };
    
    db.insert_account_info(contract_address, contract_account);
    
    // 2. Set storage values directly
    
    // In this SimpleStorage contract, the "value" is stored at slot 0
    let storage_slot = U256::zero();
    let storage_value = U256::from(42u64);
    
    println!("\nSetting storage value:");
    println!("  Contract: {:?}", contract_address);
    println!("  Slot: {}", storage_slot);
    println!("  Value: {}", storage_value);
    
    // Set the storage value directly
    db.insert_account_storage(contract_address, storage_slot, storage_value)?;
    
    // 3. Read storage values
    
    println!("\nReading storage values:");
    
    // Read the value we just set
    if let Some(value) = db.storage(contract_address, storage_slot)? {
        println!("  Read value from slot {}: {}", storage_slot, value);
    } else {
        println!("  No value found in slot {}", storage_slot);
    }
    
    // Try reading a slot we haven't set (should be zero)
    let empty_slot = U256::from(1u64);
    if let Some(value) = db.storage(contract_address, empty_slot)? {
        println!("  Read value from slot {}: {}", empty_slot, value);
    } else {
        println!("  No value found in slot {}", empty_slot);
    }
    
    // 4. Update an existing storage value
    
    println!("\nUpdating storage value:");
    
    let new_value = U256::from(100u64);
    println!("  Changing slot {} from {} to {}", storage_slot, storage_value, new_value);
    
    db.insert_account_storage(contract_address, storage_slot, new_value)?;
    
    // Verify the update
    if let Some(value) = db.storage(contract_address, storage_slot)? {
        println!("  Updated value in slot {}: {}", storage_slot, value);
    }
    
    // 5. Clear a storage slot (set to zero)
    
    println!("\nClearing storage value:");
    
    db.insert_account_storage(contract_address, storage_slot, U256::zero())?;
    
    // Verify the slot is cleared
    if let Some(value) = db.storage(contract_address, storage_slot)? {
        println!("  Value in slot {} after clearing: {}", storage_slot, value);
    }
    
    println!("Storage manipulation complete!");
    
    Ok(())
}
```

This example demonstrates:

1. Creating a contract account
2. Setting storage values directly
3. Reading storage values
4. Updating storage values
5. Clearing storage slots

## Example 3: State Snapshots and Rollbacks

REVM allows you to create snapshots of the state and roll back changes:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Env, SpecId, U256 as rU256,
    },
    DatabaseCommit, Database, EVM, EvmBuilder,
};
use std::str::FromStr;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // 1. Initial account setup
    let account_address = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    
    println!("Creating initial account: {:?}", account_address);
    
    let initial_account = AccountInfo {
        balance: rU256::from(10_000_000_000_000_000_000u64), // 10 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    
    db.insert_account_info(account_address, initial_account);
    
    // Verify initial state
    if let Some(account) = db.basic(account_address)? {
        println!("Initial account state:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
    }
    
    // 2. Create a snapshot of the current state
    println!("\nCreating snapshot...");
    
    // In CacheDB, we can clone the database to create a snapshot
    let snapshot_db = db.clone();
    
    // 3. Make changes to the state
    println!("Making changes to the state...");
    
    // Update the account (increase balance and nonce)
    let updated_account = AccountInfo {
        balance: rU256::from(20_000_000_000_000_000_000u64), // 20 ETH
        nonce: rU256::from(5u64),
        code_hash: H256::zero(),
        code: None,
    };
    
    db.insert_account_info(account_address, updated_account);
    
    // Create a new account
    let new_address = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    let new_account = AccountInfo {
        balance: rU256::from(5_000_000_000_000_000_000u64), // 5 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    
    db.insert_account_info(new_address, new_account);
    
    // Verify changed state
    if let Some(account) = db.basic(account_address)? {
        println!("Modified account state:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
    }
    
    println!("New account exists: {}", db.basic(new_address)?.is_some());
    
    // 4. Roll back to the snapshot
    println!("\nRolling back to snapshot...");
    
    // Replace the current DB with the snapshot
    db = snapshot_db;
    
    // Verify state after rollback
    if let Some(account) = db.basic(account_address)? {
        println!("Account state after rollback:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
    }
    
    println!("New account exists after rollback: {}", db.basic(new_address)?.is_some());
    
    // 5. Demonstrate snapshot and rollback within EVM execution
    println!("\nDemonstrating EVM snapshot and rollback...");
    
    // Create an EVM instance
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    // Get the inner database for manipulation
    let db_mut = evm.db_mut().unwrap();
    
    // Take a snapshot using EVM's state manager
    let snapshot_id = db_mut.take_snapshot();
    println!("Created EVM snapshot: {}", snapshot_id);
    
    // Make changes
    let account_address = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    let updated_account = AccountInfo {
        balance: rU256::from(30_000_000_000_000_000_000u64), // 30 ETH
        nonce: rU256::from(10u64),
        code_hash: H256::zero(),
        code: None,
    };
    
    db_mut.insert_account_info(account_address, updated_account);
    
    // Verify changes
    if let Some(account) = db_mut.basic(account_address)? {
        println!("Account state after changes:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
    }
    
    // Revert to the snapshot
    println!("Reverting to EVM snapshot...");
    db_mut.revert_to_snapshot(snapshot_id);
    
    // Verify state after revert
    if let Some(account) = db_mut.basic(account_address)? {
        println!("Account state after revert:");
        println!("  Balance: {} wei", account.balance);
        println!("  Nonce: {}", account.nonce);
    }
    
    println!("Snapshot and rollback demonstration complete!");
    
    Ok(())
}
```

This example demonstrates:

1. Creating a manual snapshot by cloning the database
2. Making state changes after the snapshot
3. Rolling back to the snapshot state
4. Using REVM's built-in snapshot and revert functionality

## Example 4: Custom State Database Implementation

For advanced use cases, you can create custom database implementations:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB},
    primitives::{AccountInfo, Bytecode, Address},
    Database, DatabaseCommit,
};
use std::{collections::HashMap, str::FromStr};

// Define a custom in-memory database with logging
struct LoggingDatabase {
    // Inner real database
    inner: CacheDB<EmptyDB>,
    // Log of all operations
    operation_log: Vec<String>,
}

impl LoggingDatabase {
    fn new() -> Self {
        Self {
            inner: CacheDB::new(EmptyDB::default()),
            operation_log: Vec::new(),
        }
    }
    
    fn get_logs(&self) -> &Vec<String> {
        &self.operation_log
    }
}

// Implement Database trait for our custom database
impl Database for LoggingDatabase {
    type Error = revm::db::DbError;
    
    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        self.operation_log.push(format!("Read account: {:?}", address));
        self.inner.basic(address)
    }
    
    fn code_by_hash(&self, code_hash: H256) -> Result<Bytecode, Self::Error> {
        self.operation_log.push(format!("Read code by hash: {:?}", code_hash));
        self.inner.code_by_hash(code_hash)
    }
    
    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        self.operation_log.push(format!("Read storage: {:?}[{}]", address, index));
        self.inner.storage(address, index)
    }
    
    fn block_hash(&self, number: U256) -> Result<H256, Self::Error> {
        self.operation_log.push(format!("Read block hash: {}", number));
        self.inner.block_hash(number)
    }
}

// Implement database commit functionality
impl DatabaseCommit for LoggingDatabase {
    fn commit(&mut self, changes: revm::primitives::HashMap<Address, revm::primitives::Account>) {
        self.operation_log.push(format!("Commit changes: {} accounts", changes.len()));
        self.inner.commit(changes);
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create our custom database
    let mut db = LoggingDatabase::new();
    
    println!("Using custom database with logging...");
    
    // Perform some operations
    let account_address = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    
    // Read (should be None initially)
    let account = db.basic(account_address)?;
    println!("Initial account exists: {}", account.is_some());
    
    // Create an account
    let account_info = AccountInfo {
        balance: rU256::from(10_000_000_000_000_000_000u64), // 10 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    
    // Insert the account
    db.inner.insert_account_info(account_address, account_info);
    db.operation_log.push(format!("Insert account: {:?}", account_address));
    
    // Read again
    let account = db.basic(account_address)?;
    println!("Account exists after insert: {}", account.is_some());
    
    // Set a storage value
    let storage_slot = U256::zero();
    let storage_value = U256::from(42u64);
    
    db.inner.insert_account_storage(account_address, storage_slot, storage_value)?;
    db.operation_log.push(format!("Insert storage: {:?}[{}] = {}", account_address, storage_slot, storage_value));
    
    // Read the storage
    let value = db.storage(account_address, storage_slot)?;
    println!("Storage value: {}", value);
    
    // Display operation log
    println!("\nOperation log:");
    for (i, log) in db.get_logs().iter().enumerate() {
        println!("  {}: {}", i + 1, log);
    }
    
    println!("Custom database demonstration complete!");
    
    Ok(())
}
```

This example demonstrates:

1. Creating a custom database implementation that logs all operations
2. Implementing the required Database trait methods
3. Adding custom functionality (operation logging)
4. Using the custom database for state operations

## Best Practices for State Manipulation

When manipulating EVM state, consider these best practices:

1. **Use Snapshots for Atomic Operations**: Take snapshots before complex operations to allow rollbacks
2. **Validate State Changes**: Verify state changes after operations to ensure correctness
3. **Custom Databases**: Use custom database implementations for specialized requirements
4. **Error Handling**: Handle database errors properly, especially when using external storage
5. **Batching Changes**: Batch related changes for better performance
6. **Balance Management**: Be careful with account balance modifications to maintain consistency
7. **Cleanup**: Remove temporary state changes after tests or simulations

## Conclusion

This example has demonstrated various techniques for manipulating EVM state using REVM, including:

1. Creating and modifying accounts
2. Manipulating contract storage
3. Using snapshots and rollbacks
4. Implementing custom database adapters

These techniques are powerful tools for testing, debugging, and developing custom blockchain applications.

## Next Steps

- Learn about [Gas Profiling and Optimization](#TODO)
- Explore [Custom Tracing and Debugging](#TODO)
- Understand [Block Explorer Implementation](#TODO)