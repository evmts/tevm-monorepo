---
title: 3.6 Building a Block Explorer with REVM
description: Detailed guide about 3.6 building a block explorer with revm in REVM (Rust Ethereum Virtual Machine)
---

# 3.6 Building a Block Explorer with REVM

In this guide, we'll demonstrate how to use REVM to build a simple block explorer. While not a full-featured explorer like Etherscan, our implementation will show how REVM can be used to index and analyze blockchain data, decode transactions, and provide insights into contract interactions.

## Overview

Block explorers are essential tools for blockchain developers and users, providing visibility into:

1. Block information and statistics
2. Transaction details and execution results
3. Contract state and interactions
4. Account balances and history

REVM can be used to process historical blockchain data, replay transactions, decode inputs and outputs, and extract meaningful information from raw blockchain data.

## Prerequisites

- Understanding of REVM basics
- Familiarity with Ethereum structures (blocks, transactions, receipts)
- Access to Ethereum node data (local or via RPC)
- Rust programming knowledge

## Basic Block Explorer Architecture

Our block explorer will consist of these key components:

1. **Blockchain Data Ingestion**: Retrieving blocks, transactions, and receipts
2. **Transaction Processor**: Using REVM to replay and analyze transactions
3. **State Tracker**: Maintaining a database of accounts and contract state
4. **Data Model**: Structures to represent indexed blockchain data
5. **API Layer**: Endpoints to query the indexed data

Let's implement each component:

## 1. Data Model

First, let's define the data structures for our explorer:

```rust
use revm::primitives::{Address, Bytes, TransactionAction, U256};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockInfo {
    pub number: u64,
    pub hash: [u8; 32],
    pub parent_hash: [u8; 32],
    pub timestamp: u64,
    pub author: Address,
    pub transactions: Vec<TransactionInfo>,
    pub gas_used: u64,
    pub gas_limit: u64,
    pub base_fee_per_gas: Option<U256>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransactionInfo {
    pub hash: [u8; 32],
    pub from: Address,
    pub to: Option<Address>,
    pub value: U256,
    pub gas_limit: u64,
    pub gas_used: u64,
    pub gas_price: U256,
    pub nonce: u64,
    pub input: Bytes,
    pub status: TransactionStatus,
    pub contract_address: Option<Address>,
    pub logs: Vec<LogInfo>,
    pub decoded_input: Option<DecodedCalldata>,
    pub internal_transactions: Vec<InternalTransaction>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransactionStatus {
    Success,
    Reverted(Option<String>), // Optional revert reason
    Failed(String),           // Error message
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogInfo {
    pub address: Address,
    pub topics: Vec<[u8; 32]>,
    pub data: Bytes,
    pub decoded: Option<DecodedEvent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodedCalldata {
    pub method_id: [u8; 4],
    pub method_name: Option<String>,
    pub parameters: Vec<Parameter>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodedEvent {
    pub name: Option<String>,
    pub parameters: Vec<Parameter>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Parameter {
    pub name: Option<String>,
    pub type_name: String,
    pub value: ParameterValue,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParameterValue {
    Address(Address),
    Uint(U256),
    Int(i128),
    Bool(bool),
    String(String),
    Bytes(Bytes),
    Array(Vec<ParameterValue>),
    Tuple(Vec<Parameter>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InternalTransaction {
    pub from: Address,
    pub to: Option<Address>,
    pub value: U256,
    pub input: Bytes,
    pub gas_limit: u64,
    pub call_type: CallType,
    pub decoded_input: Option<DecodedCalldata>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CallType {
    Call,
    StaticCall,
    DelegateCall,
    CallCode,
    Create,
    Create2,
    SelfDestruct,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountInfo {
    pub address: Address,
    pub balance: U256,
    pub nonce: u64,
    pub code_hash: Option<[u8; 32]>,
    pub is_contract: bool,
    pub first_seen_block: u64,
    pub transaction_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractInfo {
    pub address: Address,
    pub creator: Address,
    pub creation_transaction: [u8; 32],
    pub creation_block: u64,
    pub bytecode: Bytes,
    pub verified: bool,
    pub name: Option<String>,
    pub abi: Option<String>,
}
```

## 2. Blockchain Data Ingestion

Next, let's create a component to retrieve blockchain data:

```rust
use ethers_core::types::{Block, Transaction, TransactionReceipt, H256, U64};
use ethers_providers::{Http, Provider};
use revm::primitives::{Address, Bytes, B256, U256};
use revm::db::EthersDB;
use std::sync::Arc;
use std::error::Error;

struct BlockchainIngester {
    provider: Arc<Provider<Http>>,
    last_processed_block: u64,
}

impl BlockchainIngester {
    pub fn new(rpc_url: &str) -> Result<Self, Box<dyn Error>> {
        let provider = Arc::new(Provider::<Http>::try_from(rpc_url)?);
        Ok(Self {
            provider,
            last_processed_block: 0,
        })
    }
    
    pub async fn get_latest_block_number(&self) -> Result<u64, Box<dyn Error>> {
        let block_number = self.provider.get_block_number().await?;
        Ok(block_number.as_u64())
    }
    
    pub async fn get_block_with_txs(&self, block_number: u64) -> Result<Block<Transaction>, Box<dyn Error>> {
        let block = self.provider
            .get_block_with_txs(block_number)
            .await?
            .ok_or_else(|| format!("Block {} not found", block_number))?;
        
        Ok(block)
    }
    
    pub async fn get_transaction_receipt(&self, tx_hash: H256) -> Result<TransactionReceipt, Box<dyn Error>> {
        let receipt = self.provider
            .get_transaction_receipt(tx_hash)
            .await?
            .ok_or_else(|| format!("Receipt for transaction {} not found", tx_hash))?;
        
        Ok(receipt)
    }
    
    pub async fn get_code(&self, address: Address, block_number: Option<u64>) -> Result<Bytes, Box<dyn Error>> {
        let code = self.provider
            .get_code(
                ethers_core::types::Address::from_slice(address.as_bytes()),
                block_number.map(U64::from),
            )
            .await?;
        
        Ok(Bytes::from(code.to_vec()))
    }
    
    pub async fn create_ethers_db(&self, block_number: u64) -> Result<EthersDB<Provider<Http>>, Box<dyn Error>> {
        let provider_clone = Arc::clone(&self.provider);
        let db = EthersDB::new(provider_clone, Some(U64::from(block_number))).unwrap();
        Ok(db)
    }
    
    // Process a range of blocks and convert to our internal format
    pub async fn process_blocks(&mut self, start_block: u64, end_block: u64) -> Result<Vec<BlockInfo>, Box<dyn Error>> {
        let mut blocks = Vec::new();
        
        for block_number in start_block..=end_block {
            println!("Processing block {}", block_number);
            
            let block_with_txs = self.get_block_with_txs(block_number).await?;
            let mut transactions = Vec::new();
            
            for tx in block_with_txs.transactions {
                let receipt = self.get_transaction_receipt(tx.hash).await?;
                
                let tx_info = self.convert_to_transaction_info(tx, receipt).await?;
                transactions.push(tx_info);
            }
            
            let block_info = BlockInfo {
                number: block_number,
                hash: block_with_txs.hash.to_fixed_bytes(),
                parent_hash: block_with_txs.parent_hash.to_fixed_bytes(),
                timestamp: block_with_txs.timestamp.as_u64(),
                author: Address::from_slice(block_with_txs.author.unwrap_or_default().as_bytes()),
                transactions,
                gas_used: block_with_txs.gas_used.as_u64(),
                gas_limit: block_with_txs.gas_limit.as_u64(),
                base_fee_per_gas: block_with_txs.base_fee_per_gas.map(|fee| U256::from_be_bytes(fee.to_be_bytes::<32>())),
            };
            
            blocks.push(block_info);
            self.last_processed_block = block_number;
        }
        
        Ok(blocks)
    }
    
    async fn convert_to_transaction_info(
        &self,
        tx: Transaction,
        receipt: TransactionReceipt,
    ) -> Result<TransactionInfo, Box<dyn Error>> {
        let mut logs = Vec::new();
        
        for log in receipt.logs {
            let topics: Vec<[u8; 32]> = log.topics
                .iter()
                .map(|topic| topic.to_fixed_bytes())
                .collect();
            
            logs.push(LogInfo {
                address: Address::from_slice(log.address.as_bytes()),
                topics,
                data: Bytes::from(log.data.to_vec()),
                decoded: None, // Will be populated in the transaction processing step
            });
        }
        
        let status = match receipt.status {
            Some(s) if s.as_u64() == 1 => TransactionStatus::Success,
            Some(_) => {
                // We'll populate this with more information during transaction replay
                TransactionStatus::Reverted(None)
            },
            None => TransactionStatus::Failed("Status not available".to_string()),
        };
        
        Ok(TransactionInfo {
            hash: tx.hash.to_fixed_bytes(),
            from: Address::from_slice(tx.from.as_bytes()),
            to: tx.to.map(|addr| Address::from_slice(addr.as_bytes())),
            value: U256::from_be_bytes(tx.value.to_be_bytes::<32>()),
            gas_limit: tx.gas.as_u64(),
            gas_used: receipt.gas_used.unwrap_or_default().as_u64(),
            gas_price: U256::from_be_bytes(tx.gas_price.unwrap_or_default().to_be_bytes::<32>()),
            nonce: tx.nonce.as_u64(),
            input: Bytes::from(tx.input.to_vec()),
            status,
            contract_address: receipt.contract_address.map(|addr| Address::from_slice(addr.as_bytes())),
            logs,
            decoded_input: None, // Will be populated during transaction processing
            internal_transactions: Vec::new(), // Will be populated during transaction processing
        })
    }
}
```

## 3. Transaction Processor with REVM

Now, let's use REVM to replay transactions and extract additional information:

```rust
use revm::{
    db::CacheDB,
    EVM, Inspector, InspectorData, CallInputs, CreateInputs, InterpreterResult,
    primitives::{Bytes, Eval, ExecutionResult, Gas, TransactTo, TxEnv},
};
use revm::inspector::{InspectorStack, TracerEip3155};
use std::collections::{HashMap, HashSet};
use std::error::Error;

// Custom inspector to track internal transactions
struct InternalTxTracer {
    internal_txs: Vec<InternalTransaction>,
    revert_reason: Option<String>,
}

impl Default for InternalTxTracer {
    fn default() -> Self {
        Self {
            internal_txs: Vec::new(),
            revert_reason: None,
        }
    }
}

impl Inspector for InternalTxTracer {
    fn call(
        &mut self,
        _data: InspectorData,
        inputs: &CallInputs,
        _is_static: bool,
    ) -> (Eval, Gas) {
        let call_type = match inputs.context.scheme {
            revm::interpreter::CallScheme::Call => CallType::Call,
            revm::interpreter::CallScheme::StaticCall => CallType::StaticCall,
            revm::interpreter::CallScheme::CallCode => CallType::CallCode,
            revm::interpreter::CallScheme::DelegateCall => CallType::DelegateCall,
        };
        
        self.internal_txs.push(InternalTransaction {
            from: inputs.context.caller,
            to: Some(inputs.contract),
            value: inputs.transfer.value,
            input: inputs.input.clone(),
            gas_limit: inputs.gas_limit,
            call_type,
            decoded_input: None, // Will decode later
        });
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }
    
    fn create(
        &mut self,
        _data: InspectorData,
        inputs: &CreateInputs,
    ) -> (Eval, Gas) {
        self.internal_txs.push(InternalTransaction {
            from: inputs.caller,
            to: None, // Contract creation
            value: inputs.value,
            input: inputs.init_code.clone(),
            gas_limit: inputs.gas_limit,
            call_type: CallType::Create,
            decoded_input: None,
        });
        
        (Eval::Continue, Gas::new(inputs.gas_limit))
    }
    
    fn call_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CallInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
        _is_static: bool,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, revert_data) = &ret {
            if self.revert_reason.is_none() {
                self.revert_reason = decode_revert_reason(revert_data);
            }
        }
        
        (Eval::Continue, remaining_gas)
    }
    
    fn create_end(
        &mut self,
        _data: InspectorData,
        _inputs: &CreateInputs,
        remaining_gas: Gas,
        ret: InterpreterResult,
    ) -> (Eval, Gas) {
        if let InterpreterResult::Revert(_, revert_data) = &ret {
            if self.revert_reason.is_none() {
                self.revert_reason = decode_revert_reason(revert_data);
            }
        }
        
        (Eval::Continue, remaining_gas)
    }
}

// Helper function to decode revert reasons
fn decode_revert_reason(data: &Bytes) -> Option<String> {
    if data.len() < 4 {
        return None;
    }
    
    // Check for Error(string) selector: 0x08c379a0
    if data[0] == 0x08 && data[1] == 0xc3 && data[2] == 0x79 && data[3] == 0xa0 {
        if data.len() >= 68 {
            // Parse the string length
            let offset = 4 + 32; // Skip selector and offset word
            let str_len = U256::from_be_bytes(data[offset..offset+32].try_into().unwrap()).as_usize();
            
            if offset + 32 + str_len <= data.len() {
                if let Ok(reason) = String::from_utf8(data[offset+32..offset+32+str_len].to_vec()) {
                    return Some(reason);
                }
            }
        }
    }
    
    // Try custom revert string
    if data.len() > 0 {
        if let Ok(reason) = String::from_utf8(data.to_vec()) {
            return Some(reason);
        }
    }
    
    None
}

struct TransactionProcessor {
    abi_cache: HashMap<Address, ethabi::Contract>,
    known_functions: HashMap<[u8; 4], (String, Vec<ethabi::ParamType>)>,
    known_events: HashMap<[u8; 32], (String, Vec<ethabi::ParamType>, bool)>, // Topic -> (name, params, anonymous)
    contracts: HashMap<Address, ContractInfo>,
}

impl TransactionProcessor {
    pub fn new() -> Self {
        Self {
            abi_cache: HashMap::new(),
            known_functions: HashMap::new(),
            known_events: HashMap::new(),
            contracts: HashMap::new(),
        }
    }
    
    // Load a contract ABI to improve decoding
    pub fn load_contract_abi(&mut self, address: Address, abi_json: &str) -> Result<(), Box<dyn Error>> {
        let contract = ethabi::Contract::load(abi_json.as_bytes())?;
        
        // Index function selectors
        for function in contract.functions() {
            let selector = function.short_signature();
            let params = function.inputs.clone();
            self.known_functions.insert(selector, (function.name.clone(), params.iter().map(|p| p.kind.clone()).collect()));
        }
        
        // Index event topics
        for event in contract.events() {
            let topic = event.signature();
            let params = event.inputs.clone();
            self.known_events.insert(
                topic,
                (
                    event.name.clone(),
                    params.iter().map(|p| p.kind.clone()).collect(),
                    event.anonymous,
                ),
            );
        }
        
        self.abi_cache.insert(address, contract);
        
        Ok(())
    }
    
    // Process a block using REVM
    pub async fn process_block(
        &mut self,
        block: &mut BlockInfo,
        db: &mut CacheDB<EthersDB<Provider<Http>>>,
    ) -> Result<(), Box<dyn Error>> {
        let mut evm = EVM::new();
        evm.database(db);
        
        // Set block environment
        evm.env.block.number = U256::from(block.number);
        evm.env.block.timestamp = U256::from(block.timestamp);
        if let Some(base_fee) = block.base_fee_per_gas {
            evm.env.block.basefee = base_fee;
        }
        
        // Process each transaction
        for tx_info in &mut block.transactions {
            self.process_transaction(&mut evm, tx_info).await?;
        }
        
        Ok(())
    }
    
    // Process a single transaction
    async fn process_transaction(
        &mut self,
        evm: &mut EVM,
        tx_info: &mut TransactionInfo,
    ) -> Result<(), Box<dyn Error>> {
        // Configure transaction environment
        let mut tx_env = TxEnv::default();
        tx_env.caller = tx_info.from;
        tx_env.gas_limit = tx_info.gas_limit;
        tx_env.gas_price = tx_info.gas_price;
        tx_env.value = tx_info.value;
        tx_env.data = tx_info.input.clone();
        tx_env.nonce = Some(tx_info.nonce as u64);
        
        match tx_info.to {
            Some(to) => tx_env.transact_to = TransactTo::Call(to),
            None => tx_env.transact_to = TransactTo::Create(revm::primitives::CreateScheme::Create),
        }
        
        // Set up our inspectors
        let tracer = TracerEip3155::new();
        let internal_tx_tracer = InternalTxTracer::default();
        let inspector_stack = InspectorStack::new()
            .with_inspector(tracer)
            .with_inspector(internal_tx_tracer);
        
        evm.env.tx = tx_env;
        evm.inspect(inspector_stack);
        
        // Execute the transaction
        let result = evm.transact()?;
        
        // Extract inspector data
        let inspector_stack = evm.take_inspector().unwrap();
        let (tracer, internal_tx_tracer) = inspector_stack.inner();
        
        // Update transaction status with more detailed information
        match result.result {
            ExecutionResult::Success { .. } => {
                tx_info.status = TransactionStatus::Success;
            }
            ExecutionResult::Revert { .. } => {
                tx_info.status = TransactionStatus::Reverted(internal_tx_tracer.revert_reason);
            }
            ExecutionResult::Halt { reason, .. } => {
                tx_info.status = TransactionStatus::Failed(format!("Execution halted: {:?}", reason));
            }
        }
        
        // Populate gas information
        tx_info.gas_used = result.gas_used();
        
        // Try to decode the transaction input
        if tx_info.to.is_some() {
            tx_info.decoded_input = self.decode_calldata(&tx_info.input);
        }
        
        // Save internal transactions
        let mut internal_txs = internal_tx_tracer.internal_txs;
        
        // Try to decode internal transaction inputs
        for tx in &mut internal_txs {
            if tx.to.is_some() {
                tx.decoded_input = self.decode_calldata(&tx.input);
            }
        }
        
        tx_info.internal_transactions = internal_txs;
        
        // For contract creations, store contract information
        if let Some(contract_addr) = tx_info.contract_address {
            if !self.contracts.contains_key(&contract_addr) {
                // Get the contract bytecode
                if let Ok(code) = evm.db().basic(contract_addr) {
                    if code.code.is_some() {
                        let contract_info = ContractInfo {
                            address: contract_addr,
                            creator: tx_info.from,
                            creation_transaction: tx_info.hash,
                            creation_block: evm.env.block.number.as_u64(),
                            bytecode: code.code.unwrap().bytecode().clone(),
                            verified: false,
                            name: None,
                            abi: None,
                        };
                        
                        self.contracts.insert(contract_addr, contract_info);
                    }
                }
            }
        }
        
        // Decode logs/events
        for log in &mut tx_info.logs {
            if !log.topics.is_empty() {
                let event_topic = log.topics[0];
                log.decoded = self.decode_event_log(&event_topic, &log.topics[1..], &log.data);
            }
        }
        
        Ok(())
    }
    
    // Try to decode function calldata
    fn decode_calldata(&self, input: &Bytes) -> Option<DecodedCalldata> {
        if input.len() < 4 {
            return None;
        }
        
        let mut method_id = [0u8; 4];
        method_id.copy_from_slice(&input[0..4]);
        
        if let Some((name, param_types)) = self.known_functions.get(&method_id) {
            // Try to decode parameters
            if input.len() > 4 {
                let param_data = &input[4..];
                if let Ok(tokens) = ethabi::decode(param_types, param_data) {
                    let parameters = tokens.into_iter()
                        .zip(param_types.iter())
                        .enumerate()
                        .map(|(i, (token, param_type))| {
                            Parameter {
                                name: Some(format!("param{}", i)),
                                type_name: format!("{:?}", param_type),
                                value: convert_token_to_parameter_value(token),
                            }
                        })
                        .collect();
                    
                    return Some(DecodedCalldata {
                        method_id,
                        method_name: Some(name.clone()),
                        parameters,
                    });
                }
            }
            
            // Return just the method name if parameter decoding fails
            return Some(DecodedCalldata {
                method_id,
                method_name: Some(name.clone()),
                parameters: Vec::new(),
            });
        }
        
        // Return just the method ID if we don't know the function
        Some(DecodedCalldata {
            method_id,
            method_name: None,
            parameters: Vec::new(),
        })
    }
    
    // Try to decode event logs
    fn decode_event_log(
        &self,
        topic: &[u8; 32],
        indexed_topics: &[[u8; 32]],
        data: &Bytes,
    ) -> Option<DecodedEvent> {
        if let Some((name, param_types, anonymous)) = self.known_events.get(topic) {
            // Try to decode data
            if let Ok(tokens) = ethabi::decode(&param_types, data) {
                let parameters = tokens.into_iter()
                    .zip(param_types.iter())
                    .enumerate()
                    .map(|(i, (token, param_type))| {
                        Parameter {
                            name: Some(format!("param{}", i)),
                            type_name: format!("{:?}", param_type),
                            value: convert_token_to_parameter_value(token),
                        }
                    })
                    .collect();
                
                return Some(DecodedEvent {
                    name: Some(name.clone()),
                    parameters,
                });
            }
            
            // Return just the event name if data decoding fails
            return Some(DecodedEvent {
                name: Some(name.clone()),
                parameters: Vec::new(),
            });
        }
        
        None
    }
}

// Helper to convert ethabi tokens to our parameter values
fn convert_token_to_parameter_value(token: ethabi::Token) -> ParameterValue {
    match token {
        ethabi::Token::Address(addr) => {
            ParameterValue::Address(Address::from_slice(addr.as_bytes()))
        },
        ethabi::Token::Uint(val) => {
            ParameterValue::Uint(U256::from_be_bytes(val.to_be_bytes::<32>()))
        },
        ethabi::Token::Int(val) => {
            ParameterValue::Int(val.as_u128() as i128)
        },
        ethabi::Token::Bool(val) => {
            ParameterValue::Bool(val)
        },
        ethabi::Token::String(val) => {
            ParameterValue::String(val)
        },
        ethabi::Token::Bytes(val) => {
            ParameterValue::Bytes(Bytes::from(val))
        },
        ethabi::Token::FixedBytes(val) => {
            ParameterValue::Bytes(Bytes::from(val))
        },
        ethabi::Token::Array(tokens) => {
            ParameterValue::Array(tokens.into_iter().map(convert_token_to_parameter_value).collect())
        },
        ethabi::Token::FixedArray(tokens) => {
            ParameterValue::Array(tokens.into_iter().map(convert_token_to_parameter_value).collect())
        },
        ethabi::Token::Tuple(tokens) => {
            let params = tokens.into_iter()
                .enumerate()
                .map(|(i, token)| Parameter {
                    name: Some(format!("element{}", i)),
                    type_name: "unknown".to_string(),
                    value: convert_token_to_parameter_value(token),
                })
                .collect();
            ParameterValue::Tuple(params)
        },
    }
}
```

## 4. State Tracker for Accounts and Contracts

Now, let's implement a component to track account and contract state:

```rust
use revm::db::{CacheDB, EthersDB};
use revm::primitives::{Account, Address, Bytes, U256};
use ethers_providers::{Http, Provider};
use std::collections::HashMap;
use std::error::Error;
use std::sync::Arc;

struct StateTracker {
    accounts: HashMap<Address, AccountInfo>,
    contracts: HashMap<Address, ContractInfo>,
    storage_slots: HashMap<(Address, U256), U256>,
}

impl StateTracker {
    pub fn new() -> Self {
        Self {
            accounts: HashMap::new(),
            contracts: HashMap::new(),
            storage_slots: HashMap::new(),
        }
    }
    
    // Update account information based on current state
    pub async fn update_accounts(
        &mut self,
        db: &CacheDB<EthersDB<Provider<Http>>>,
        block_number: u64,
    ) -> Result<(), Box<dyn Error>> {
        // Get the accounts in the database
        for (address, _) in db.accounts() {
            if let Ok(account_info) = db.basic(address) {
                let is_contract = account_info.code.is_some() && 
                                 !account_info.code.as_ref().unwrap().is_empty();
                
                let acc_info = self.accounts
                    .entry(address)
                    .or_insert_with(|| AccountInfo {
                        address,
                        balance: U256::ZERO,
                        nonce: 0,
                        code_hash: None,
                        is_contract,
                        first_seen_block: block_number,
                        transaction_count: 0,
                    });
                
                // Update account information
                acc_info.balance = account_info.balance;
                acc_info.nonce = account_info.nonce as u64;
                
                if is_contract {
                    let code = account_info.code.unwrap();
                    let code_hash = tiny_keccak::keccak256(code.bytecode().as_ref());
                    acc_info.code_hash = Some(code_hash);
                    
                    // Create contract info if it doesn't exist
                    if !self.contracts.contains_key(&address) {
                        self.contracts.insert(address, ContractInfo {
                            address,
                            creator: Address::zero(), // Unknown creator
                            creation_transaction: [0u8; 32],
                            creation_block: block_number,
                            bytecode: code.bytecode().clone(),
                            verified: false,
                            name: None,
                            abi: None,
                        });
                    }
                }
            }
        }
        
        Ok(())
    }
    
    // Track a specific storage slot
    pub async fn track_storage_slot(
        &mut self,
        db: &CacheDB<EthersDB<Provider<Http>>>,
        address: Address,
        slot: U256,
    ) -> Result<U256, Box<dyn Error>> {
        if let Ok(value) = db.storage(address, slot) {
            self.storage_slots.insert((address, slot), value);
            Ok(value)
        } else {
            Err("Failed to read storage slot".into())
        }
    }
    
    // Update contract info after verification
    pub fn update_contract_info(
        &mut self,
        address: Address,
        name: String,
        abi_json: String,
    ) -> Result<(), Box<dyn Error>> {
        if let Some(contract) = self.contracts.get_mut(&address) {
            contract.verified = true;
            contract.name = Some(name);
            contract.abi = Some(abi_json);
            Ok(())
        } else {
            Err("Contract not found".into())
        }
    }
}
```

## 5. Database Layer for Storage

Now, let's implement a simple storage layer using SQLite:

```rust
use rusqlite::{Connection, params, Result};
use std::error::Error;
use serde_json;

struct BlockExplorerDb {
    conn: Connection,
}

impl BlockExplorerDb {
    pub fn new(db_path: &str) -> Result<Self, Box<dyn Error>> {
        let conn = Connection::open(db_path)?;
        
        // Create tables
        conn.execute(
            "CREATE TABLE IF NOT EXISTS blocks (
                number INTEGER PRIMARY KEY,
                hash BLOB NOT NULL,
                parent_hash BLOB NOT NULL,
                timestamp INTEGER NOT NULL,
                author BLOB NOT NULL,
                gas_used INTEGER NOT NULL,
                gas_limit INTEGER NOT NULL,
                base_fee_per_gas TEXT
            )",
            params![],
        )?;
        
        conn.execute(
            "CREATE TABLE IF NOT EXISTS transactions (
                hash BLOB PRIMARY KEY,
                block_number INTEGER NOT NULL,
                tx_index INTEGER NOT NULL,
                from_address BLOB NOT NULL,
                to_address BLOB,
                value TEXT NOT NULL,
                gas_limit INTEGER NOT NULL,
                gas_used INTEGER NOT NULL,
                gas_price TEXT NOT NULL,
                nonce INTEGER NOT NULL,
                input BLOB NOT NULL,
                status TEXT NOT NULL,
                contract_address BLOB,
                data JSON NOT NULL,
                FOREIGN KEY (block_number) REFERENCES blocks(number)
            )",
            params![],
        )?;
        
        conn.execute(
            "CREATE TABLE IF NOT EXISTS logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tx_hash BLOB NOT NULL,
                log_index INTEGER NOT NULL,
                address BLOB NOT NULL,
                data BLOB NOT NULL,
                topic0 BLOB,
                topic1 BLOB,
                topic2 BLOB,
                topic3 BLOB,
                decoded JSON,
                FOREIGN KEY (tx_hash) REFERENCES transactions(hash)
            )",
            params![],
        )?;
        
        conn.execute(
            "CREATE TABLE IF NOT EXISTS accounts (
                address BLOB PRIMARY KEY,
                balance TEXT NOT NULL,
                nonce INTEGER NOT NULL,
                code_hash BLOB,
                is_contract INTEGER NOT NULL,
                first_seen_block INTEGER NOT NULL,
                transaction_count INTEGER NOT NULL
            )",
            params![],
        )?;
        
        conn.execute(
            "CREATE TABLE IF NOT EXISTS contracts (
                address BLOB PRIMARY KEY,
                creator BLOB NOT NULL,
                creation_tx BLOB NOT NULL,
                creation_block INTEGER NOT NULL,
                bytecode BLOB NOT NULL,
                verified INTEGER NOT NULL,
                name TEXT,
                abi TEXT,
                FOREIGN KEY (address) REFERENCES accounts(address)
            )",
            params![],
        )?;
        
        conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_transactions_block ON transactions (block_number)",
            params![],
        )?;
        
        conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_logs_tx ON logs (tx_hash)",
            params![],
        )?;
        
        Ok(Self { conn })
    }
    
    // Store a processed block
    pub fn store_block(&self, block: &BlockInfo) -> Result<(), Box<dyn Error>> {
        self.conn.execute(
            "INSERT OR REPLACE INTO blocks 
             (number, hash, parent_hash, timestamp, author, gas_used, gas_limit, base_fee_per_gas) 
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
            params![
                block.number as i64,
                &block.hash[..],
                &block.parent_hash[..],
                block.timestamp as i64,
                &block.author.as_bytes(),
                block.gas_used as i64,
                block.gas_limit as i64,
                block.base_fee_per_gas.map(|fee| fee.to_string()),
            ],
        )?;
        
        // Store transactions
        for (i, tx) in block.transactions.iter().enumerate() {
            let status_str = match &tx.status {
                TransactionStatus::Success => "success",
                TransactionStatus::Reverted(reason) => {
                    if let Some(reason) = reason {
                        &reason
                    } else {
                        "reverted"
                    }
                },
                TransactionStatus::Failed(msg) => msg,
            };
            
            // Serialize the extended transaction data
            let tx_data = serde_json::to_string(&json!({
                "decoded_input": tx.decoded_input,
                "internal_transactions": tx.internal_transactions,
            }))?;
            
            self.conn.execute(
                "INSERT OR REPLACE INTO transactions 
                 (hash, block_number, tx_index, from_address, to_address, value, gas_limit, gas_used, 
                 gas_price, nonce, input, status, contract_address, data) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                params![
                    &tx.hash[..],
                    block.number as i64,
                    i as i64,
                    &tx.from.as_bytes(),
                    tx.to.map(|addr| addr.as_bytes().to_vec()),
                    tx.value.to_string(),
                    tx.gas_limit as i64,
                    tx.gas_used as i64,
                    tx.gas_price.to_string(),
                    tx.nonce as i64,
                    &tx.input.as_ref(),
                    status_str,
                    tx.contract_address.map(|addr| addr.as_bytes().to_vec()),
                    tx_data,
                ],
            )?;
            
            // Store logs
            for (log_idx, log) in tx.logs.iter().enumerate() {
                let decoded_json = if let Some(decoded) = &log.decoded {
                    serde_json::to_string(decoded)?
                } else {
                    "null".to_string()
                };
                
                // Extract up to 4 topics
                let topic0 = log.topics.get(0).map(|t| t.to_vec());
                let topic1 = log.topics.get(1).map(|t| t.to_vec());
                let topic2 = log.topics.get(2).map(|t| t.to_vec());
                let topic3 = log.topics.get(3).map(|t| t.to_vec());
                
                self.conn.execute(
                    "INSERT INTO logs 
                     (tx_hash, log_index, address, data, topic0, topic1, topic2, topic3, decoded) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    params![
                        &tx.hash[..],
                        log_idx as i64,
                        &log.address.as_bytes(),
                        &log.data.as_ref(),
                        topic0,
                        topic1,
                        topic2,
                        topic3,
                        decoded_json,
                    ],
                )?;
            }
        }
        
        Ok(())
    }
    
    // Store account information
    pub fn store_account(&self, account: &AccountInfo) -> Result<(), Box<dyn Error>> {
        self.conn.execute(
            "INSERT OR REPLACE INTO accounts 
             (address, balance, nonce, code_hash, is_contract, first_seen_block, transaction_count) 
             VALUES (?, ?, ?, ?, ?, ?, ?)",
            params![
                &account.address.as_bytes(),
                account.balance.to_string(),
                account.nonce as i64,
                account.code_hash.map(|hash| hash.to_vec()),
                account.is_contract as i64,
                account.first_seen_block as i64,
                account.transaction_count as i64,
            ],
        )?;
        
        Ok(())
    }
    
    // Store contract information
    pub fn store_contract(&self, contract: &ContractInfo) -> Result<(), Box<dyn Error>> {
        self.conn.execute(
            "INSERT OR REPLACE INTO contracts 
             (address, creator, creation_tx, creation_block, bytecode, verified, name, abi) 
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
            params![
                &contract.address.as_bytes(),
                &contract.creator.as_bytes(),
                &contract.creation_transaction[..],
                contract.creation_block as i64,
                &contract.bytecode.as_ref(),
                contract.verified as i64,
                contract.name.as_deref(),
                contract.abi.as_deref(),
            ],
        )?;
        
        Ok(())
    }
    
    // Query methods for retrieving data
    
    pub fn get_latest_block(&self) -> Result<Option<u64>, Box<dyn Error>> {
        let result: Result<Option<i64>, rusqlite::Error> = self.conn.query_row(
            "SELECT MAX(number) FROM blocks",
            params![],
            |row| row.get(0),
        );
        
        match result {
            Ok(Some(number)) => Ok(Some(number as u64)),
            Ok(None) => Ok(None),
            Err(err) => Err(Box::new(err)),
        }
    }
    
    pub fn get_block_by_number(&self, block_number: u64) -> Result<Option<BlockInfo>, Box<dyn Error>> {
        let row = self.conn.query_row(
            "SELECT number, hash, parent_hash, timestamp, author, gas_used, gas_limit, base_fee_per_gas 
             FROM blocks WHERE number = ?",
            params![block_number as i64],
            |row| {
                let number: i64 = row.get(0)?;
                let hash: Vec<u8> = row.get(1)?;
                let parent_hash: Vec<u8> = row.get(2)?;
                let timestamp: i64 = row.get(3)?;
                let author: Vec<u8> = row.get(4)?;
                let gas_used: i64 = row.get(5)?;
                let gas_limit: i64 = row.get(6)?;
                let base_fee_str: Option<String> = row.get(7)?;
                
                let mut hash_bytes = [0u8; 32];
                let mut parent_hash_bytes = [0u8; 32];
                
                hash_bytes.copy_from_slice(&hash);
                parent_hash_bytes.copy_from_slice(&parent_hash);
                
                let base_fee_per_gas = base_fee_str.map(|s| s.parse::<U256>().unwrap_or_default());
                
                Ok(BlockInfo {
                    number: number as u64,
                    hash: hash_bytes,
                    parent_hash: parent_hash_bytes,
                    timestamp: timestamp as u64,
                    author: Address::from_slice(&author),
                    transactions: Vec::new(), // Will be populated later
                    gas_used: gas_used as u64,
                    gas_limit: gas_limit as u64,
                    base_fee_per_gas,
                })
            },
        );
        
        match row {
            Ok(mut block) => {
                // Get the transactions for this block
                let mut stmt = self.conn.prepare(
                    "SELECT hash, from_address, to_address, value, gas_limit, gas_used, gas_price, 
                     nonce, input, status, contract_address, data
                     FROM transactions WHERE block_number = ? ORDER BY tx_index ASC"
                )?;
                
                let tx_rows = stmt.query_map(params![block_number as i64], |row| {
                    let hash: Vec<u8> = row.get(0)?;
                    let from_addr: Vec<u8> = row.get(1)?;
                    let to_addr: Option<Vec<u8>> = row.get(2)?;
                    let value_str: String = row.get(3)?;
                    let gas_limit: i64 = row.get(4)?;
                    let gas_used: i64 = row.get(5)?;
                    let gas_price_str: String = row.get(6)?;
                    let nonce: i64 = row.get(7)?;
                    let input: Vec<u8> = row.get(8)?;
                    let status_str: String = row.get(9)?;
                    let contract_addr: Option<Vec<u8>> = row.get(10)?;
                    let data_json: String = row.get(11)?;
                    
                    let mut hash_bytes = [0u8; 32];
                    hash_bytes.copy_from_slice(&hash);
                    
                    let value = value_str.parse::<U256>().unwrap_or_default();
                    let gas_price = gas_price_str.parse::<U256>().unwrap_or_default();
                    
                    let status = if status_str == "success" {
                        TransactionStatus::Success
                    } else if status_str.starts_with("reverted") {
                        TransactionStatus::Reverted(Some(status_str))
                    } else {
                        TransactionStatus::Failed(status_str)
                    };
                    
                    // Parse the extended data
                    let extra_data: serde_json::Value = serde_json::from_str(&data_json).unwrap_or_default();
                    
                    let decoded_input: Option<DecodedCalldata> = if extra_data["decoded_input"].is_null() {
                        None
                    } else {
                        serde_json::from_value(extra_data["decoded_input"].clone()).unwrap_or_default()
                    };
                    
                    let internal_transactions: Vec<InternalTransaction> = 
                        serde_json::from_value(extra_data["internal_transactions"].clone()).unwrap_or_default();
                    
                    // Get logs for this transaction
                    let logs = self.get_logs_for_transaction(&hash_bytes).unwrap_or_default();
                    
                    Ok(TransactionInfo {
                        hash: hash_bytes,
                        from: Address::from_slice(&from_addr),
                        to: to_addr.map(|addr| Address::from_slice(&addr)),
                        value,
                        gas_limit: gas_limit as u64,
                        gas_used: gas_used as u64,
                        gas_price,
                        nonce: nonce as u64,
                        input: Bytes::from(input),
                        status,
                        contract_address: contract_addr.map(|addr| Address::from_slice(&addr)),
                        logs,
                        decoded_input,
                        internal_transactions,
                    })
                })?;
                
                for tx_result in tx_rows {
                    block.transactions.push(tx_result?);
                }
                
                Ok(Some(block))
            },
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(err) => Err(Box::new(err)),
        }
    }
    
    fn get_logs_for_transaction(&self, tx_hash: &[u8; 32]) -> Result<Vec<LogInfo>, Box<dyn Error>> {
        let mut stmt = self.conn.prepare(
            "SELECT log_index, address, data, topic0, topic1, topic2, topic3, decoded 
             FROM logs WHERE tx_hash = ? ORDER BY log_index ASC"
        )?;
        
        let log_rows = stmt.query_map(params![tx_hash], |row| {
            let _log_index: i64 = row.get(0)?;
            let address: Vec<u8> = row.get(1)?;
            let data: Vec<u8> = row.get(2)?;
            let topic0: Option<Vec<u8>> = row.get(3)?;
            let topic1: Option<Vec<u8>> = row.get(4)?;
            let topic2: Option<Vec<u8>> = row.get(5)?;
            let topic3: Option<Vec<u8>> = row.get(6)?;
            let decoded_json: String = row.get(7)?;
            
            // Collect topics
            let mut topics = Vec::new();
            if let Some(t) = topic0 {
                let mut topic_bytes = [0u8; 32];
                topic_bytes.copy_from_slice(&t);
                topics.push(topic_bytes);
            }
            if let Some(t) = topic1 {
                let mut topic_bytes = [0u8; 32];
                topic_bytes.copy_from_slice(&t);
                topics.push(topic_bytes);
            }
            if let Some(t) = topic2 {
                let mut topic_bytes = [0u8; 32];
                topic_bytes.copy_from_slice(&t);
                topics.push(topic_bytes);
            }
            if let Some(t) = topic3 {
                let mut topic_bytes = [0u8; 32];
                topic_bytes.copy_from_slice(&t);
                topics.push(topic_bytes);
            }
            
            // Parse the decoded event
            let decoded: Option<DecodedEvent> = if decoded_json == "null" {
                None
            } else {
                serde_json::from_str(&decoded_json).ok()
            };
            
            Ok(LogInfo {
                address: Address::from_slice(&address),
                topics,
                data: Bytes::from(data),
                decoded,
            })
        })?;
        
        let mut logs = Vec::new();
        for log_result in log_rows {
            logs.push(log_result?);
        }
        
        Ok(logs)
    }
    
    pub fn get_transaction_by_hash(&self, hash: &[u8; 32]) -> Result<Option<TransactionInfo>, Box<dyn Error>> {
        let result = self.conn.query_row(
            "SELECT block_number, from_address, to_address, value, gas_limit, gas_used, gas_price, 
             nonce, input, status, contract_address, data
             FROM transactions WHERE hash = ?",
            params![hash],
            |row| {
                let _block_number: i64 = row.get(0)?;
                let from_addr: Vec<u8> = row.get(1)?;
                let to_addr: Option<Vec<u8>> = row.get(2)?;
                let value_str: String = row.get(3)?;
                let gas_limit: i64 = row.get(4)?;
                let gas_used: i64 = row.get(5)?;
                let gas_price_str: String = row.get(6)?;
                let nonce: i64 = row.get(7)?;
                let input: Vec<u8> = row.get(8)?;
                let status_str: String = row.get(9)?;
                let contract_addr: Option<Vec<u8>> = row.get(10)?;
                let data_json: String = row.get(11)?;
                
                let value = value_str.parse::<U256>().unwrap_or_default();
                let gas_price = gas_price_str.parse::<U256>().unwrap_or_default();
                
                let status = if status_str == "success" {
                    TransactionStatus::Success
                } else if status_str.starts_with("reverted") {
                    TransactionStatus::Reverted(Some(status_str))
                } else {
                    TransactionStatus::Failed(status_str)
                };
                
                // Parse the extended data
                let extra_data: serde_json::Value = serde_json::from_str(&data_json).unwrap_or_default();
                
                let decoded_input: Option<DecodedCalldata> = if extra_data["decoded_input"].is_null() {
                    None
                } else {
                    serde_json::from_value(extra_data["decoded_input"].clone()).unwrap_or_default()
                };
                
                let internal_transactions: Vec<InternalTransaction> = 
                    serde_json::from_value(extra_data["internal_transactions"].clone()).unwrap_or_default();
                
                // Get logs for this transaction
                let logs = self.get_logs_for_transaction(hash).unwrap_or_default();
                
                Ok(TransactionInfo {
                    hash: *hash,
                    from: Address::from_slice(&from_addr),
                    to: to_addr.map(|addr| Address::from_slice(&addr)),
                    value,
                    gas_limit: gas_limit as u64,
                    gas_used: gas_used as u64,
                    gas_price,
                    nonce: nonce as u64,
                    input: Bytes::from(input),
                    status,
                    contract_address: contract_addr.map(|addr| Address::from_slice(&addr)),
                    logs,
                    decoded_input,
                    internal_transactions,
                })
            },
        );
        
        match result {
            Ok(tx) => Ok(Some(tx)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(err) => Err(Box::new(err)),
        }
    }
    
    pub fn get_account_by_address(&self, address: &Address) -> Result<Option<AccountInfo>, Box<dyn Error>> {
        let result = self.conn.query_row(
            "SELECT balance, nonce, code_hash, is_contract, first_seen_block, transaction_count 
             FROM accounts WHERE address = ?",
            params![address.as_bytes()],
            |row| {
                let balance_str: String = row.get(0)?;
                let nonce: i64 = row.get(1)?;
                let code_hash: Option<Vec<u8>> = row.get(2)?;
                let is_contract: i64 = row.get(3)?;
                let first_seen_block: i64 = row.get(4)?;
                let transaction_count: i64 = row.get(5)?;
                
                let balance = balance_str.parse::<U256>().unwrap_or_default();
                
                let code_hash_bytes = code_hash.map(|hash| {
                    let mut bytes = [0u8; 32];
                    bytes.copy_from_slice(&hash);
                    bytes
                });
                
                Ok(AccountInfo {
                    address: *address,
                    balance,
                    nonce: nonce as u64,
                    code_hash: code_hash_bytes,
                    is_contract: is_contract != 0,
                    first_seen_block: first_seen_block as u64,
                    transaction_count: transaction_count as u64,
                })
            },
        );
        
        match result {
            Ok(account) => Ok(Some(account)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(err) => Err(Box::new(err)),
        }
    }
    
    pub fn get_contract_by_address(&self, address: &Address) -> Result<Option<ContractInfo>, Box<dyn Error>> {
        let result = self.conn.query_row(
            "SELECT creator, creation_tx, creation_block, bytecode, verified, name, abi 
             FROM contracts WHERE address = ?",
            params![address.as_bytes()],
            |row| {
                let creator: Vec<u8> = row.get(0)?;
                let creation_tx: Vec<u8> = row.get(1)?;
                let creation_block: i64 = row.get(2)?;
                let bytecode: Vec<u8> = row.get(3)?;
                let verified: i64 = row.get(4)?;
                let name: Option<String> = row.get(5)?;
                let abi: Option<String> = row.get(6)?;
                
                let mut tx_hash = [0u8; 32];
                tx_hash.copy_from_slice(&creation_tx);
                
                Ok(ContractInfo {
                    address: *address,
                    creator: Address::from_slice(&creator),
                    creation_transaction: tx_hash,
                    creation_block: creation_block as u64,
                    bytecode: Bytes::from(bytecode),
                    verified: verified != 0,
                    name,
                    abi,
                })
            },
        );
        
        match result {
            Ok(contract) => Ok(Some(contract)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(err) => Err(Box::new(err)),
        }
    }
}
```

## 6. Simple Block Explorer Application

Now, let's put everything together into a main application:

```rust
use tokio::time::{sleep, Duration};
use std::error::Error;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

async fn run_block_explorer(
    rpc_url: &str,
    db_path: &str,
    start_block: Option<u64>,
    real_time: bool,
) -> Result<(), Box<dyn Error>> {
    println!("Starting block explorer indexer...");
    
    // Initialize components
    let mut ingester = BlockchainIngester::new(rpc_url)?;
    let mut processor = TransactionProcessor::new();
    let mut state_tracker = StateTracker::new();
    let db = Arc::new(BlockExplorerDb::new(db_path)?);
    
    // Determine starting block
    let mut current_block = match start_block {
        Some(block) => block,
        None => {
            match db.get_latest_block()? {
                Some(block) => block + 1,
                None => 0,
            }
        }
    };
    
    // Get the latest block from the network
    let latest_block = ingester.get_latest_block_number().await?;
    println!("Latest block on network: {}", latest_block);
    println!("Starting indexing from block: {}", current_block);
    
    // Add known contract ABIs to improve decoding
    // This is just an example - in a real application, you'd load these from a database
    let erc20_abi = r#"[
        {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},
        {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},
        {"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
        {"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},
        {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},
        {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
        {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},
        {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},
        {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
        {"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]"#;
    
    processor.load_contract_abi(Address::zero(), erc20_abi)?; // This will register the ABI for all contracts
    
    // Set up signal handling for graceful shutdown
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();
    
    ctrlc::set_handler(move || {
        println!("Shutting down gracefully...");
        r.store(false, Ordering::SeqCst);
    })?;
    
    // Main indexing loop
    while running.load(Ordering::SeqCst) {
        if current_block > latest_block && !real_time {
            println!("Indexing complete!");
            break;
        }
        
        // Process blocks in batches of 10
        let end_block = std::cmp::min(current_block + 9, latest_block);
        
        if current_block <= end_block {
            println!("Processing blocks {} to {}", current_block, end_block);
            
            // Ingest blocks from the network
            let mut blocks = ingester.process_blocks(current_block, end_block).await?;
            
            // Create a database that can access state at the current block
            let mut ethers_db = ingester.create_ethers_db(end_block).await?;
            let mut cache_db = CacheDB::new(ethers_db);
            
            // Process each block with REVM
            for block in &mut blocks {
                println!("Processing block {} with {} transactions", 
                    block.number, block.transactions.len());
                
                processor.process_block(block, &mut cache_db).await?;
                
                // Update state tracker
                state_tracker.update_accounts(&cache_db, block.number).await?;
                
                // Store block in database
                db.store_block(block)?;
            }
            
            // Store updated accounts and contracts
            for (addr, account) in &state_tracker.accounts {
                db.store_account(account)?;
            }
            
            for (addr, contract) in &state_tracker.contracts {
                db.store_contract(contract)?;
            }
            
            // Move to the next batch
            current_block = end_block + 1;
        } else if real_time {
            // In real-time mode, wait for new blocks
            sleep(Duration::from_secs(5)).await;
            let new_latest_block = ingester.get_latest_block_number().await?;
            
            if new_latest_block > latest_block {
                println!("New blocks detected! Latest is now {}", new_latest_block);
                latest_block = new_latest_block;
            }
        }
    }
    
    println!("Block explorer indexer shutdown complete");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Load configuration
    let rpc_url = std::env::var("ETH_RPC_URL")
        .unwrap_or_else(|_| "http://localhost:8545".to_string());
    
    let db_path = std::env::var("EXPLORER_DB_PATH")
        .unwrap_or_else(|_| "explorer.db".to_string());
    
    let start_block = std::env::var("START_BLOCK")
        .ok()
        .and_then(|s| s.parse::<u64>().ok());
    
    let real_time = std::env::var("REAL_TIME")
        .map(|v| v == "1" || v.to_lowercase() == "true")
        .unwrap_or(true);
    
    run_block_explorer(&rpc_url, &db_path, start_block, real_time).await
}
```

## 7. API for Block Explorer

Finally, let's create a simple REST API to query our block explorer:

```rust
use warp::{Filter, Rejection, Reply};
use serde_json::{json, Value};
use std::sync::Arc;
use std::convert::Infallible;

// Create HTTP API routes
async fn create_api_server(db: Arc<BlockExplorerDb>, port: u16) {
    let db_filter = warp::any().map(move || db.clone());
    
    // GET /api/blocks/latest
    let latest_block = warp::path!("api" / "blocks" / "latest")
        .and(db_filter.clone())
        .and_then(handle_latest_block);
    
    // GET /api/blocks/:number
    let block_by_number = warp::path!("api" / "blocks" / u64)
        .and(db_filter.clone())
        .and_then(handle_block_by_number);
    
    // GET /api/txs/:hash
    let tx_by_hash = warp::path!("api" / "txs" / String)
        .and(db_filter.clone())
        .and_then(handle_tx_by_hash);
    
    // GET /api/accounts/:address
    let account_by_address = warp::path!("api" / "accounts" / String)
        .and(db_filter.clone())
        .and_then(handle_account_by_address);
    
    // GET /api/contracts/:address
    let contract_by_address = warp::path!("api" / "contracts" / String)
        .and(db_filter.clone())
        .and_then(handle_contract_by_address);
    
    // Combine all routes
    let routes = latest_block
        .or(block_by_number)
        .or(tx_by_hash)
        .or(account_by_address)
        .or(contract_by_address)
        .with(warp::cors().allow_any_origin());
    
    println!("Starting API server on port {}", port);
    warp::serve(routes).run(([127, 0, 0, 1], port)).await;
}

async fn handle_latest_block(db: Arc<BlockExplorerDb>) -> Result<impl Reply, Rejection> {
    match db.get_latest_block() {
        Ok(Some(block_number)) => {
            match db.get_block_by_number(block_number) {
                Ok(Some(block)) => Ok(warp::reply::json(&block)),
                Ok(None) => Ok(warp::reply::json(&json!({"error": "Block not found"}))),
                Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
            }
        },
        Ok(None) => Ok(warp::reply::json(&json!({"error": "No blocks indexed yet"}))),
        Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
    }
}

async fn handle_block_by_number(number: u64, db: Arc<BlockExplorerDb>) -> Result<impl Reply, Infallible> {
    match db.get_block_by_number(number) {
        Ok(Some(block)) => Ok(warp::reply::json(&block)),
        Ok(None) => Ok(warp::reply::json(&json!({"error": "Block not found"}))),
        Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
    }
}

async fn handle_tx_by_hash(hash_str: String, db: Arc<BlockExplorerDb>) -> Result<impl Reply, Infallible> {
    // Convert hex string to bytes
    let hash_bytes = match hex::decode(hash_str.trim_start_matches("0x")) {
        Ok(bytes) => {
            if bytes.len() != 32 {
                return Ok(warp::reply::json(&json!({"error": "Invalid transaction hash length"})));
            }
            let mut hash = [0u8; 32];
            hash.copy_from_slice(&bytes);
            hash
        },
        Err(_) => {
            return Ok(warp::reply::json(&json!({"error": "Invalid transaction hash format"})));
        }
    };
    
    match db.get_transaction_by_hash(&hash_bytes) {
        Ok(Some(tx)) => Ok(warp::reply::json(&tx)),
        Ok(None) => Ok(warp::reply::json(&json!({"error": "Transaction not found"}))),
        Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
    }
}

async fn handle_account_by_address(addr_str: String, db: Arc<BlockExplorerDb>) -> Result<impl Reply, Infallible> {
    // Convert hex string to address
    let address = match hex::decode(addr_str.trim_start_matches("0x")) {
        Ok(bytes) => {
            if bytes.len() != 20 {
                return Ok(warp::reply::json(&json!({"error": "Invalid address length"})));
            }
            Address::from_slice(&bytes)
        },
        Err(_) => {
            return Ok(warp::reply::json(&json!({"error": "Invalid address format"})));
        }
    };
    
    match db.get_account_by_address(&address) {
        Ok(Some(account)) => Ok(warp::reply::json(&account)),
        Ok(None) => Ok(warp::reply::json(&json!({"error": "Account not found"}))),
        Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
    }
}

async fn handle_contract_by_address(addr_str: String, db: Arc<BlockExplorerDb>) -> Result<impl Reply, Infallible> {
    // Convert hex string to address
    let address = match hex::decode(addr_str.trim_start_matches("0x")) {
        Ok(bytes) => {
            if bytes.len() != 20 {
                return Ok(warp::reply::json(&json!({"error": "Invalid address length"})));
            }
            Address::from_slice(&bytes)
        },
        Err(_) => {
            return Ok(warp::reply::json(&json!({"error": "Invalid address format"})));
        }
    };
    
    match db.get_contract_by_address(&address) {
        Ok(Some(contract)) => {
            // Create a sanitized version without binary data
            let sanitized = json!({
                "address": format!("0x{}", hex::encode(contract.address.as_bytes())),
                "creator": format!("0x{}", hex::encode(contract.creator.as_bytes())),
                "creation_transaction": format!("0x{}", hex::encode(&contract.creation_transaction)),
                "creation_block": contract.creation_block,
                "bytecode_length": contract.bytecode.len(),
                "verified": contract.verified,
                "name": contract.name,
                "has_abi": contract.abi.is_some(),
            });
            Ok(warp::reply::json(&sanitized))
        },
        Ok(None) => Ok(warp::reply::json(&json!({"error": "Contract not found"}))),
        Err(e) => Ok(warp::reply::json(&json!({"error": e.to_string()}))),
    }
}

// Add this to your main function
async fn start_api_and_indexer() -> Result<(), Box<dyn Error>> {
    let rpc_url = std::env::var("ETH_RPC_URL")
        .unwrap_or_else(|_| "http://localhost:8545".to_string());
    
    let db_path = std::env::var("EXPLORER_DB_PATH")
        .unwrap_or_else(|_| "explorer.db".to_string());
    
    let api_port = std::env::var("API_PORT")
        .unwrap_or_else(|_| "3000".to_string())
        .parse::<u16>()?;
    
    let db = Arc::new(BlockExplorerDb::new(&db_path)?);
    
    // Start the API server and indexer concurrently
    let api_server = tokio::spawn(create_api_server(db.clone(), api_port));
    let indexer = tokio::spawn(run_block_explorer(&rpc_url, &db_path, None, true));
    
    // Wait for both tasks to complete (they shouldn't unless there's an error)
    let _ = tokio::try_join!(
        async { api_server.await.map_err(|e| Box::new(e) as Box<dyn Error>) },
        async { indexer.await.map_err(|e| Box::new(e) as Box<dyn Error>).and_then(|r| r) }
    )?;
    
    Ok(())
}
```

## Putting It All Together

Our block explorer demonstrates several key capabilities of REVM:

1. **Transaction Replay**: We use REVM to replay transactions and extract detailed information about their execution, including internal calls and state changes.

2. **State Access**: We can access and manipulate the Ethereum state at any block height.

3. **Execution Tracing**: We use custom inspectors to trace transaction execution and gather data.

4. **Decoding**: We decode transaction inputs and event logs using ABIs.

5. **Error Analysis**: We extract detailed error information from failed or reverted transactions.

With these capabilities, we've built a functioning block explorer that can:

- Index blocks and transactions
- Trace execution
- Decode transaction data and events
- Track account balances and contract states
- Identify contract deployments and interactions
- Provide an API for querying blockchain data

## Extending the Block Explorer

You could extend this implementation in several ways:

1. **Smart Contract Verification**: Add functionality to verify contract source code and ABIs.

2. **Token Tracking**: Add special handling for ERC-20 and ERC-721 tokens.

3. **Gas Analysis**: Add detailed gas usage statistics and optimizations.

4. **Transaction Simulation**: Add an endpoint to simulate transactions before they are sent to the network.

5. **Advanced Filtering**: Implement filtering by token, address, or event.

6. **Web UI**: Add a web interface for exploring the indexed data.

## Best Practices

1. **Efficient DB Usage**: Use prepared statements and transactions for better database performance.

2. **Caching**: Implement caching for frequently accessed data.

3. **Parallel Processing**: Process blocks in parallel for faster indexing.

4. **Error Recovery**: Implement robust error handling and recovery mechanisms.

5. **ABI Management**: Maintain a database of verified contract ABIs for better decoding.

6. **State Pruning**: Implement state pruning to keep database size manageable.

7. **Access Control**: Add authentication and authorization to the API.

## Next Steps

Now that you've built a block explorer with REVM, you might want to explore:

1. Forking from a live network to create a local development environment
2. Implementing a JSON-RPC API to create a fully compatible Ethereum node
3. Creating custom precompiles to extend EVM functionality
4. Building advanced debugging tools for smart contract development

Check out the next guide, "3.7 Forking from a Live Network", to learn how to fork from a live Ethereum network using REVM.

---

In this guide, we've shown how to use REVM to build a block explorer. REVM's ability to replay transactions, access state, and trace execution makes it an excellent tool for blockchain data analysis and exploration tools. While our implementation is simplified compared to production explorers like Etherscan, it demonstrates the core concepts and techniques needed to build Ethereum analytics tools with REVM.