---
title: 3.1 Basic Transaction Processing
description: Detailed guide about 3.1 basic transaction processing in REVM (Rust Ethereum Virtual Machine)
---

# 3.1 Basic Transaction Processing

This example demonstrates how to process Ethereum transactions using REVM. We'll cover setting up a basic EVM environment, creating and executing transactions, and analyzing the results.

## Overview

Processing transactions is the core functionality of any Ethereum Virtual Machine. In this example, we'll demonstrate:

1. Creating a basic EVM instance with an in-memory database
2. Setting up and executing a simple ETH transfer transaction
3. Monitoring transaction execution with an inspector
4. Handling transaction errors and understanding execution results

This example serves as a foundation for the more complex examples that follow.

## Prerequisites

To run this example, you'll need:

- Rust and Cargo installed
- Basic knowledge of Ethereum transactions
- The REVM crate added to your project

Add REVM to your `Cargo.toml`:

```toml
[dependencies]
revm = "4.0.0"
primitive-types = "0.12.1"
hex = "0.4.3"
```

## Example 1: Simple ETH Transfer

Let's start with a basic ETH transfer transaction:

```rust
use primitive_types::{H160, H256, U256};
use revm::{
    db::{CacheDB, EmptyDB, InMemoryDB}, 
    primitives::{
        AccountInfo, Address, Bytecode, Bytes, ExecutionResult, Log, 
        SpecId, TransactTo, TxEnv, U256 as rU256,
    },
    EVM, EvmBuilder,
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create addresses for the sender and recipient
    let sender = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    let recipient = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up sender account with some ETH
    let sender_account = AccountInfo {
        balance: rU256::from(10_000_000_000_000_000_000u64), // 10 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    
    // Set up recipient account with zero balance
    let recipient_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(recipient, recipient_account);
    
    // Create an EVM instance
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON) // Use a specific Ethereum hardfork
        .build();
    
    // Set up the transaction
    let tx = TxEnv {
        caller: sender,
        gas_limit: 21000, // Standard gas limit for ETH transfers
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Call(recipient),
        value: rU256::from(1_000_000_000_000_000_000u64), // 1 ETH
        data: Bytes::default(), // No data for simple transfers
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    // Set the transaction in the EVM
    evm.env.tx = tx;
    
    // Execute the transaction
    let result = evm.transact_commit()?;
    
    // Check the result
    match result {
        ExecutionResult::Success { gas_used, gas_refunded, logs, output } => {
            println!("Transaction executed successfully!");
            println!("Gas used: {}", gas_used);
            println!("Gas refunded: {}", gas_refunded);
            println!("Number of logs: {}", logs.len());
            
            // Retrieve updated account states
            let db = evm.db().unwrap();
            
            if let Some(sender_info) = db.basic(sender)? {
                println!("Sender balance after transaction: {} wei", sender_info.balance);
            }
            
            if let Some(recipient_info) = db.basic(recipient)? {
                println!("Recipient balance after transaction: {} wei", recipient_info.balance);
            }
        },
        ExecutionResult::Revert { gas_used, output } => {
            println!("Transaction reverted!");
            println!("Gas used: {}", gas_used);
            println!("Output: 0x{}", hex::encode(&output));
        },
        ExecutionResult::Halt { reason, gas_used } => {
            println!("Transaction halted: {:?}", reason);
            println!("Gas used: {}", gas_used);
        },
    }
    
    Ok(())
}
```

This example performs a simple ETH transfer of 1 ETH from one account to another. It:

1. Creates an in-memory database with two accounts
2. Sets up an EVM instance with the database
3. Creates a transaction that transfers ETH
4. Executes the transaction and commits the state changes
5. Analyzes the results, including updated account balances

When run, this example should output:

```
Transaction executed successfully!
Gas used: 21000
Gas refunded: 0
Number of logs: 0
Sender balance after transaction: 8979000000000000000 wei
Recipient balance after transaction: 1000000000000000000 wei
```

Note that the sender's balance is reduced by both the 1 ETH transfer amount and the gas cost (21,000 gas * 1 gwei).

## Example 2: Monitoring Transaction Execution

To gain insights into transaction execution, we can use an Inspector. REVM provides a powerful inspection mechanism through the `Inspector` trait:

```rust
use revm::{
    db::{CacheDB, EmptyDB},
    primitives::{AccountInfo, Address, ExecutionResult, SpecId, TransactTo, TxEnv, U256},
    Inspector, EVM, EvmBuilder,
};
use primitive_types::{H160, H256};
use std::str::FromStr;

// Define a custom inspector that prints information about execution steps
struct TransactionMonitor {}

impl Inspector for TransactionMonitor {
    // Called before each instruction is executed
    fn step(&mut self, interp: &mut Interpreter, _data: &mut dyn Host) -> InstructionResult {
        let opcode = interp.current_opcode();
        let pc = interp.program_counter();
        let gas = interp.gas().remaining();
        
        println!(
            "Step: PC={:<4} Gas={:<10} Op={:?}",
            pc, gas, opcode_name(opcode)
        );
        
        // Continue execution
        InstructionResult::Continue
    }
    
    // Called when a contract call is made
    fn call(
        &mut self,
        _data: &mut CallInputs,
        _data: &mut dyn Host,
    ) -> Option<CallResult> {
        println!("Call: from={:?} to={:?} value={:?}", 
                 _data.context.caller, _data.contract, _data.transfer.value);
        None // None means continue execution
    }
    
    // Called when gas is consumed
    fn gas(&mut self, gas_used: u64, _data: &mut dyn Host) {
        println!("Gas consumed: {}", gas_used);
    }
    
    // Other inspector methods...
}

// Helper function to get opcode name (not shown for brevity)
fn opcode_name(opcode: u8) -> &'static str {
    // Return the name of the opcode
    match opcode {
        0x00 => "STOP",
        0x01 => "ADD",
        // ... other opcodes
        _ => "UNKNOWN",
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Set up addresses, accounts, and DB like in the previous example
    
    // Create an EVM instance with inspector
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    // Set up the transaction like before
    
    // Create our inspector
    let inspector = TransactionMonitor {};
    
    // Execute with inspection
    let result = evm.inspect_commit(inspector)?;
    
    // Process results as before
    
    Ok(())
}
```

The `TransactionMonitor` inspector outputs details about each step of execution, helping you understand how the EVM processes the transaction. For a simple ETH transfer, you'll see various operations like balance checks, nonce updates, and value transfers.

## Example 3: Handling Transaction Errors

Let's look at some common transaction error scenarios and how to handle them:

```rust
// ... imports and setup from previous examples

fn try_transaction(
    sender: H160,
    recipient: H160,
    value: U256,
    gas_limit: u64,
    db: CacheDB<EmptyDB>
) -> Result<ExecutionResult, Box<dyn std::error::Error>> {
    // Create EVM with provided DB
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    // Set up transaction
    let tx = TxEnv {
        caller: sender,
        gas_limit,
        gas_price: rU256::from(1_000_000_000u64), // 1 gwei
        transact_to: TransactTo::Call(recipient),
        value,
        data: Bytes::default(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx;
    
    // Execute and return result
    let result = evm.transact_commit()?;
    Ok(result)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Scenario 1: Insufficient Balance
    let mut db = CacheDB::new(EmptyDB::default());
    
    let sender = H160::from_str("0x1000000000000000000000000000000000000000").unwrap();
    let recipient = H160::from_str("0x2000000000000000000000000000000000000000").unwrap();
    
    // Sender with only 0.5 ETH
    let sender_account = AccountInfo {
        balance: rU256::from(500_000_000_000_000_000u64), // 0.5 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    
    let recipient_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(recipient, recipient_account);
    
    // Try to send 1 ETH (should fail)
    let result = try_transaction(
        sender,
        recipient,
        rU256::from(1_000_000_000_000_000_000u64), // 1 ETH
        21000,
        db.clone()
    )?;
    
    println!("Scenario 1 - Insufficient Balance:");
    match result {
        ExecutionResult::Success { .. } => println!("Transaction succeeded (unexpected)"),
        ExecutionResult::Revert { .. } => println!("Transaction reverted"),
        ExecutionResult::Halt { reason, gas_used } => {
            println!("Transaction halted: {:?}", reason);
            println!("Gas used: {}", gas_used);
        },
    }
    
    // Scenario 2: Insufficient Gas Limit
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Sender with enough balance
    let sender_account = AccountInfo {
        balance: rU256::from(10_000_000_000_000_000_000u64), // 10 ETH
        nonce: rU256::ZERO,
        code_hash: H256::zero(),
        code: None,
    };
    db.insert_account_info(sender, sender_account);
    db.insert_account_info(recipient, recipient_account);
    
    // Try with insufficient gas (below 21000)
    let result = try_transaction(
        sender,
        recipient,
        rU256::from(1_000_000_000_000_000_000u64), // 1 ETH
        20000, // Less than minimum for transfer
        db.clone()
    )?;
    
    println!("\nScenario 2 - Insufficient Gas:");
    match result {
        ExecutionResult::Success { .. } => println!("Transaction succeeded (unexpected)"),
        ExecutionResult::Revert { .. } => println!("Transaction reverted"),
        ExecutionResult::Halt { reason, gas_used } => {
            println!("Transaction halted: {:?}", reason);
            println!("Gas used: {}", gas_used);
        },
    }
    
    // Scenario 3: Contract Execution with Errors
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Set up a contract that always reverts
    let contract_address = H160::from_str("0x3000000000000000000000000000000000000000").unwrap();
    let contract_account = AccountInfo {
        balance: rU256::ZERO,
        nonce: rU256::ZERO,
        code_hash: H256::from_str("0xabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789").unwrap(),
        code: Some(Bytecode::new_raw(
            // REVERT(0, 0) - always revert
            hex::decode("60006000fd").unwrap().into()
        )),
    };
    db.insert_account_info(contract_address, contract_account);
    db.insert_account_info(sender, sender_account);
    
    // Set up EVM and transaction
    let mut evm = EvmBuilder::default()
        .with_db(db)
        .with_spec_id(SpecId::LONDON)
        .build();
    
    let tx = TxEnv {
        caller: sender,
        gas_limit: 100000,
        gas_price: rU256::from(1_000_000_000u64),
        transact_to: TransactTo::Call(contract_address),
        value: rU256::ZERO,
        data: Bytes::default(),
        chain_id: None,
        nonce: None,
        gas_priority_fee: None,
        access_list: Vec::new(),
    };
    
    evm.env.tx = tx;
    
    let result = evm.transact_commit()?;
    
    println!("\nScenario 3 - Contract Revert:");
    match result {
        ExecutionResult::Success { .. } => println!("Transaction succeeded (unexpected)"),
        ExecutionResult::Revert { gas_used, output } => {
            println!("Transaction reverted as expected");
            println!("Gas used: {}", gas_used);
            println!("Output: 0x{}", hex::encode(&output));
        },
        ExecutionResult::Halt { reason, gas_used } => {
            println!("Transaction halted: {:?}", reason);
            println!("Gas used: {}", gas_used);
        },
    }
    
    Ok(())
}
```

This example demonstrates three common error scenarios:

1. **Insufficient Balance**: The sender doesn't have enough ETH for the transaction
2. **Insufficient Gas Limit**: The gas limit is below the required minimum
3. **Contract Revert**: A contract execution explicitly reverts

Understanding these error patterns is critical for building robust applications with REVM.

## Best Practices

When processing transactions with REVM, consider these best practices:

1. **Proper Error Handling**: Always handle all result types (Success, Revert, Halt)
2. **Gas Management**: Set appropriate gas limits for different transaction types
3. **State Validation**: Verify account balances and state before executing transactions
4. **Use Inspectors**: For monitoring and debugging complex transactions
5. **Database Caching**: Use CacheDB or similar for efficient state management
6. **Hardfork Selection**: Choose the appropriate spec ID for the network you're targeting

## Conclusion

This example has demonstrated the basics of transaction processing with REVM, including:

1. Setting up an EVM with an in-memory database
2. Creating and executing ETH transfer transactions
3. Monitoring execution with inspectors
4. Handling common transaction errors

You can use these fundamentals as building blocks for more complex applications, such as contract deployment, state management, and gas optimization, which we'll explore in the following examples.

## Next Steps

- Learn about [Contract Deployment and Interaction](#TODO)
- Explore [EVM State Manipulation](#TODO)
- Understand [Gas Profiling and Optimization](#TODO)