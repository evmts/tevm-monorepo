---
title: 4.4 Instruction Set
description: Detailed guide about 4.4 instruction set in REVM (Rust Ethereum Virtual Machine)
---

# 4.4 Instruction Set

This document provides a comprehensive reference for the EVM instruction set as implemented in REVM, including opcode details, gas costs, stack effects, and implementation specifics.

## Opcode Basics

Each EVM opcode is represented by a single byte (0x00-0xFF). The EVM executes opcodes sequentially, with control flow modified by jump operations.

### Opcode Structure

In REVM, opcodes are defined in the `Opcode` enum:

```rust
pub enum Opcode {
    STOP,           // 0x00
    ADD,            // 0x01
    MUL,            // 0x02
    SUB,            // 0x03
    DIV,            // 0x04
    SDIV,           // 0x05
    MOD,            // 0x06
    SMOD,           // 0x07
    ADDMOD,         // 0x08
    MULMOD,         // 0x09
    EXP,            // 0x0A
    SIGNEXTEND,     // 0x0B
    // ...
}
```

Each opcode has metadata including its gas cost, stack requirements, and behavior. This metadata is defined in the `OPCODE_JUMPMAP`:

```rust
pub static OPCODE_JUMPMAP: [OpCode; 256] = [
    OpCode::new(Opcode::STOP, 0, 0, 0, 0),          // 0x00
    OpCode::new(Opcode::ADD, 3, 2, 1, 0),           // 0x01
    OpCode::new(Opcode::MUL, 5, 2, 1, 0),           // 0x02
    OpCode::new(Opcode::SUB, 3, 2, 1, 0),           // 0x03
    // ...
];
```

Each entry in `OPCODE_JUMPMAP` contains:
1. The Opcode enum value
2. The base gas cost (may be modified by EIP or execution context)
3. Number of stack inputs
4. Number of stack outputs
5. Memory size change (for opcodes that extend memory)

## Opcode Categories

The EVM instruction set can be grouped into several functional categories:

### Arithmetic Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x01 | ADD | a, b | a + b | Addition |
| 0x02 | MUL | a, b | a * b | Multiplication |
| 0x03 | SUB | a, b | a - b | Subtraction |
| 0x04 | DIV | a, b | a / b | Integer division |
| 0x05 | SDIV | a, b | a / b | Signed integer division |
| 0x06 | MOD | a, b | a % b | Modulo |
| 0x07 | SMOD | a, b | a % b | Signed modulo |
| 0x08 | ADDMOD | a, b, N | (a + b) % N | Addition with modulo |
| 0x09 | MULMOD | a, b, N | (a * b) % N | Multiplication with modulo |
| 0x0A | EXP | a, exponent | a ** exponent | Exponentiation |
| 0x0B | SIGNEXTEND | b, x | extended x | Sign extend from (b + 1) * 8 bits to 256 bits |

### Comparison Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x10 | LT | a, b | a &lt; b | Less than |
| 0x11 | GT | a, b | a > b | Greater than |
| 0x12 | SLT | a, b | a &lt; b | Signed less than |
| 0x13 | SGT | a, b | a > b | Signed greater than |
| 0x14 | EQ | a, b | a == b | Equality |
| 0x15 | ISZERO | a | a == 0 | Is zero |
| 0x16 | AND | a, b | a & b | Bitwise AND |
| 0x17 | OR | a, b | a \| b | Bitwise OR |
| 0x18 | XOR | a, b | a ^ b | Bitwise XOR |
| 0x19 | NOT | a | ~a | Bitwise NOT |
| 0x1A | BYTE | i, x | i-th byte of x | Extract byte |
| 0x1B | SHL | shift, value | value &lt;&lt; shift | Shift left |
| 0x1C | SHR | shift, value | value &gt;&gt; shift | Logical shift right |
| 0x1D | SAR | shift, value | value &gt;&gt; shift | Arithmetic shift right |

### Cryptographic Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x20 | SHA3 | offset, size | keccak256(mem[offset:offset+size]) | Keccak-256 hash |

### Environmental Information

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x30 | ADDRESS | - | address | Get current contract address |
| 0x31 | BALANCE | address | balance | Get balance |
| 0x32 | ORIGIN | - | tx.origin | Get transaction origin address |
| 0x33 | CALLER | - | msg.sender | Get caller address |
| 0x34 | CALLVALUE | - | msg.value | Get deposited value |
| 0x35 | CALLDATALOAD | i | calldata[i:i+32] | Load calldata |
| 0x36 | CALLDATASIZE | - | len(calldata) | Get calldata size |
| 0x37 | CALLDATACOPY | destOffset, offset, size | - | Copy calldata to memory |
| 0x38 | CODESIZE | - | len(code) | Get code size |
| 0x39 | CODECOPY | destOffset, offset, size | - | Copy code to memory |
| 0x3A | GASPRICE | - | tx.gasprice | Get gas price |
| 0x3B | EXTCODESIZE | address | size | Get external code size |
| 0x3C | EXTCODECOPY | address, destOffset, offset, size | - | Copy external code to memory |
| 0x3D | RETURNDATASIZE | - | size | Get return data size |
| 0x3E | RETURNDATACOPY | destOffset, offset, size | - | Copy return data to memory |
| 0x3F | EXTCODEHASH | address | hash | Get external code hash |

### Block Information

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x40 | BLOCKHASH | blockNumber | hash | Get hash of recent block |
| 0x41 | COINBASE | - | address | Get current block miner address |
| 0x42 | TIMESTAMP | - | timestamp | Get current block timestamp |
| 0x43 | NUMBER | - | blockNumber | Get current block number |
| 0x44 | DIFFICULTY/PREVRANDAO | - | difficulty/prevrandao | Get difficulty (pre-merge) or prevrandao (post-merge) |
| 0x45 | GASLIMIT | - | gasLimit | Get block gas limit |
| 0x46 | CHAINID | - | chainid | Get current chain ID |
| 0x47 | SELFBALANCE | - | balance | Get balance of current contract |
| 0x48 | BASEFEE | - | basefee | Get block base fee |
| 0x49 | BLOBBASEFEE | - | blobbasefee | Get blob base fee |
| 0x4A | BLOBHASH | index | hash | Get blob hash |

### Storage and Memory Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x50 | POP | a | - | Remove item from stack |
| 0x51 | MLOAD | offset | value | Load from memory |
| 0x52 | MSTORE | offset, value | - | Store in memory |
| 0x53 | MSTORE8 | offset, value | - | Store single byte in memory |
| 0x54 | SLOAD | key | value | Load from storage |
| 0x55 | SSTORE | key, value | - | Store in storage |
| 0x56 | JUMP | dest | - | Jump to destination |
| 0x57 | JUMPI | dest, condition | - | Conditional jump |
| 0x58 | PC | - | counter | Program counter |
| 0x59 | MSIZE | - | size | Memory size in bytes |
| 0x5A | GAS | - | gas | Get remaining gas |
| 0x5B | JUMPDEST | - | - | Mark a valid jump destination |
| 0x5C | TLOAD | index | value | Load from transient storage |
| 0x5D | TSTORE | index, value | - | Store in transient storage |
| 0x5F | PUSH0 | - | 0 | Push 0 onto stack |

### Push Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x60 | PUSH1 | - | value | Push 1 byte onto stack |
| 0x61 | PUSH2 | - | value | Push 2 bytes onto stack |
| ... | ... | ... | ... | ... | ... |
| 0x7F | PUSH32 | - | value | Push 32 bytes onto stack |

### Duplication Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x80 | DUP1 | a | a, a | Duplicate 1st stack item |
| 0x81 | DUP2 | a, b | a, b, a | Duplicate 2nd stack item |
| ... | ... | ... | ... | ... | ... |
| 0x8F | DUP16 | a, ..., p | a, ..., p, a | Duplicate 16th stack item |

### Exchange Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0x90 | SWAP1 | a, b | b, a | Swap 1st and 2nd stack items |
| 0x91 | SWAP2 | a, b, c | c, b, a | Swap 1st and 3rd stack items |
| ... | ... | ... | ... | ... | ... |
| 0x9F | SWAP16 | a, ..., p, q | q, ..., p, a | Swap 1st and 17th stack items |

### Logging Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0xA0 | LOG0 | offset, size | - | Log without topics |
| 0xA1 | LOG1 | offset, size, topic1 | - | Log with 1 topic |
| 0xA2 | LOG2 | offset, size, topic1, topic2 | - | Log with 2 topics |
| 0xA3 | LOG3 | offset, size, topic1, topic2, topic3 | - | Log with 3 topics |
| 0xA4 | LOG4 | offset, size, topic1, ..., topic4 | - | Log with 4 topics |

### System Operations

| Opcode | Value | Name | Stack Input | Stack Output | Description |
|--------|-------|------|-------------|--------------|-------------|
| 0xF0 | CREATE | value, offset, size | address | Create contract |
| 0xF1 | CALL | gas, addr, value, argsOffset, argsSize, retOffset, retSize | success | Call contract |
| 0xF2 | CALLCODE | gas, addr, value, argsOffset, argsSize, retOffset, retSize | success | Call code from address |
| 0xF3 | RETURN | offset, size | - | Return output data |
| 0xF4 | DELEGATECALL | gas, addr, argsOffset, argsSize, retOffset, retSize | success | Call code with caller's context |
| 0xF5 | CREATE2 | value, offset, size, salt | address | Create contract with salt |
| 0xFA | STATICCALL | gas, addr, argsOffset, argsSize, retOffset, retSize | success | Static call |
| 0xFD | REVERT | offset, size | - | Revert with output data |
| 0xFE | INVALID | - | - | Invalid instruction |
| 0xFF | SELFDESTRUCT | address | - | Self-destruct and send funds |

## Gas Costs

Gas costs in the EVM are determined by several factors:

1. **Base Cost**: Fixed cost for executing the opcode
2. **Dynamic Cost**: Cost based on operands or memory expansion
3. **EIP Modifications**: Changes to costs based on Ethereum Improvement Proposals
4. **Context**: Access patterns (warm vs. cold access in EIP-2929)

### Base Costs

The base cost is the minimum gas required to execute an opcode. Some examples:

| Category | Opcodes | Base Cost |
|----------|---------|-----------|
| Zero cost | STOP, RETURN, REVERT | 0 |
| Very low cost | ADD, SUB, LT, GT, EQ, etc. | 3 |
| Low cost | MUL, DIV, MOD | 5 |
| Mid cost | ADDMOD, MULMOD, JUMP | 8 |
| High cost | SHA3, BALANCE, EXTCODESIZE | 10+ |
| Very high cost | SLOAD, SSTORE, CREATE, CALL | 100+ |

### Dynamic Costs

Many opcodes have dynamic costs based on:

1. **Memory Expansion**: Costs for increasing memory size
2. **Storage Access**: Costs for reading/writing storage
3. **Special Rules**: Complex rules for specific opcodes

#### Memory Expansion Cost

Memory expansion is calculated based on the number of 32-byte words required:

```rust
fn memory_expansion_cost(words: usize) -> u64 {
    let words = words as u64;
    words * 3 + words * words / 512
}
```

Example operations that incur memory expansion costs:
- CALLDATACOPY, CODECOPY, EXTCODECOPY
- MSTORE, MLOAD
- SHA3
- CREATE, CREATE2, CALL variants
- LOG operations

#### Storage Cost (SSTORE)

The cost of SSTORE is complex and depends on:

1. Original value (before transaction)
2. Current value (before the SSTORE operation)
3. New value (to be written)
4. The EVM spec in use (changes in different EIPs)

The latest rules (EIP-3529, Berlin and later) are:

```rust
fn sstore_cost(original: U256, current: U256, new: U256, spec: SpecId) -> u64 {
    if current == new {
        // No change
        return 100;
    }
    
    if original == current {
        if original == U256::ZERO {
            // Zero to non-zero
            return 20000;
        } else if new == U256::ZERO {
            // Non-zero to zero (with refund)
            return 5000 - 4800; // Net cost of 2500 after refund
        } else {
            // Non-zero to non-zero
            return 5000;
        }
    } else {
        // Value was changed in the transaction
        let mut gas = 100;
        
        if original != U256::ZERO {
            if current == U256::ZERO {
                // Restored from zero
                gas -= 4800; // Refund
            }
            if new == U256::ZERO {
                // Resetting to zero
                gas += 5000;
            }
        }
        
        if original == new {
            // Reset to original value
            if original == U256::ZERO {
                // Reset from a non-zero to original zero
                gas -= 19900; // Refund
            } else {
                // Reset from a non-zero to original non-zero
                gas -= 4800; // Refund
            }
        }
        
        return gas;
    }
}
```

#### Call Costs (CALL, STATICCALL, DELEGATECALL)

Call costs depend on:

1. Gas stipend for child call
2. Value transfer (yes/no)
3. New account creation (yes/no)
4. Access status (warm/cold in EIP-2929)

```rust
fn call_cost(
    gas_stipend: u64,
    value_transfer: bool,
    new_account: bool,
    address: Address,
    is_warm: bool,
    spec: SpecId,
) -> u64 {
    let mut gas = 100; // Base cost
    
    // EIP-2929 cost for address access
    if !is_warm && spec >= SpecId::BERLIN {
        gas += 2500; // Cold account access
    } else if spec >= SpecId::BERLIN {
        gas += 100; // Warm account access
    }
    
    // Value transfer
    if value_transfer {
        gas += 9000;
        
        // New account
        if new_account {
            gas += 25000;
        }
    }
    
    gas
}
```

### EIP-Specific Gas Costs

Several EIPs have significantly modified gas costs:

#### EIP-150 (Tangerine Whistle)

- Changed gas forwarding to calls: max 63/64 of available gas
- Increased BALANCE, EXTCODESIZE, EXTCODECOPY costs to 400 gas
- Increased SLOAD cost to 200 gas
- Increased CALL, DELEGATECALL, CALLCODE costs to 700 gas

#### EIP-1884 (Istanbul)

- SLOAD cost increased to 800 gas
- BALANCE cost increased to 700 gas
- EXTCODEHASH cost increased to 700 gas
- EXTCODESIZE cost increased to 700 gas
- SELFBALANCE added at cost of 5 gas

#### EIP-2200 (Istanbul)

- Reduced gas costs for SSTORE when:
  - Storage slot value doesn't change
  - Storage slot is reset to original value
  - Storage slot is cleared

#### EIP-2929 (Berlin)

- Introduced "warm" and "cold" access for addresses and storage slots
- Cold address access: 2600 gas
- Warm address access: 100 gas
- Cold storage access: 2100 gas
- Warm storage access: 100 gas
- First access to an address or storage slot is "cold"
- Subsequent accesses are "warm"

#### EIP-3529 (London)

- Changed gas refund rules for SSTORE
- Removed refund for SELFDESTRUCT

## Implementation Details

### Opcode Execution

REVM implements opcode execution using a large match statement in the interpreter. Here's a simplified example of how it's structured:

```rust
fn execute_opcode(&mut self, opcode: u8) -> Result<ExecuteResult, ExecuteError> {
    match opcode {
        0x00 => {
            // STOP
            return Ok(ExecuteResult::Stop);
        },
        0x01 => {
            // ADD
            let a = self.stack.pop()?;
            let b = self.stack.pop()?;
            self.stack.push(a.overflowing_add(b).0)?;
        },
        0x02 => {
            // MUL
            let a = self.stack.pop()?;
            let b = self.stack.pop()?;
            self.stack.push(a.overflowing_mul(b).0)?;
        },
        // ... hundreds more cases
        _ => {
            return Err(ExecuteError::InvalidOpcode(opcode));
        }
    }
    
    Ok(ExecuteResult::Continue)
}
```

### Stack Implementation

The EVM stack is implemented as a fixed-size array of U256 values with a stack pointer:

```rust
pub struct Stack {
    data: [U256; 1024],
    size: usize,
}

impl Stack {
    pub fn new() -> Self {
        Self {
            data: [U256::ZERO; 1024],
            size: 0,
        }
    }
    
    pub fn push(&mut self, value: U256) -> Result<(), StackError> {
        if self.size >= 1024 {
            return Err(StackError::Overflow);
        }
        
        self.data[self.size] = value;
        self.size += 1;
        Ok(())
    }
    
    pub fn pop(&mut self) -> Result<U256, StackError> {
        if self.size == 0 {
            return Err(StackError::Underflow);
        }
        
        self.size -= 1;
        Ok(self.data[self.size])
    }
    
    // More methods for stack manipulation...
}
```

### Memory Implementation

EVM memory is a byte-addressable, expandable array:

```rust
pub struct Memory {
    data: Vec<u8>,
    effective_len: usize,
}

impl Memory {
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            effective_len: 0,
        }
    }
    
    pub fn resize(&mut self, new_size: usize) {
        if new_size > self.data.len() {
            self.data.resize(new_size, 0);
        }
        if new_size > self.effective_len {
            self.effective_len = new_size;
        }
    }
    
    pub fn store(&mut self, offset: usize, value: U256) {
        let end = offset + 32;
        if end > self.data.len() {
            self.resize(end);
        }
        
        // Store value in big-endian format
        value.to_big_endian(&mut self.data[offset..end]);
    }
    
    pub fn store8(&mut self, offset: usize, value: U256) {
        let end = offset + 1;
        if end > self.data.len() {
            self.resize(end);
        }
        
        self.data[offset] = value.byte(0);
    }
    
    pub fn load(&mut self, offset: usize) -> U256 {
        let end = offset + 32;
        if end > self.data.len() {
            self.resize(end);
        }
        
        U256::from_big_endian(&self.data[offset..end])
    }
    
    // More memory manipulation methods...
}
```

### Gas Accounting

Gas accounting is handled by the `GasMeter` struct:

```rust
pub struct GasMeter {
    gas_limit: u64,
    gas_remaining: u64,
    gas_refund: u64,
}

impl GasMeter {
    pub fn new(gas_limit: u64) -> Self {
        Self {
            gas_limit,
            gas_remaining: gas_limit,
            gas_refund: 0,
        }
    }
    
    pub fn record_cost(&mut self, cost: u64) -> Result<(), OutOfGasError> {
        if cost > self.gas_remaining {
            return Err(OutOfGasError);
        }
        
        self.gas_remaining -= cost;
        Ok(())
    }
    
    pub fn record_refund(&mut self, refund: u64) {
        self.gas_refund += refund;
    }
    
    pub fn gas_used(&self) -> u64 {
        self.gas_limit - self.gas_remaining
    }
    
    // More gas accounting methods...
}
```

### Precompiled Contracts

Precompiled contracts are special contracts at addresses 1-9 with native implementations.

REVM implements them as a map of addresses to implementations:

```rust
pub fn precompiles() -> HashMap<Address, Box<dyn PrecompileContract>> {
    let mut precompiles = HashMap::new();
    
    // EIP-2: ECRECOVER
    precompiles.insert(address!("0x0000000000000000000000000000000000000001"), Box::new(ECRecover));
    
    // EIP-2: SHA256
    precompiles.insert(address!("0x0000000000000000000000000000000000000002"), Box::new(SHA256));
    
    // EIP-2: RIPEMD160
    precompiles.insert(address!("0x0000000000000000000000000000000000000003"), Box::new(RIPEMD160));
    
    // EIP-2: IDENTITY
    precompiles.insert(address!("0x0000000000000000000000000000000000000004"), Box::new(Identity));
    
    // EIP-198: Modular exponentiation
    precompiles.insert(address!("0x0000000000000000000000000000000000000005"), Box::new(ModExp));
    
    // EIP-196: BN curve operations (add)
    precompiles.insert(address!("0x0000000000000000000000000000000000000006"), Box::new(BN256Add));
    
    // EIP-196: BN curve operations (scalar mul)
    precompiles.insert(address!("0x0000000000000000000000000000000000000007"), Box::new(BN256ScalarMul));
    
    // EIP-197: BN curve operations (pairing check)
    precompiles.insert(address!("0x0000000000000000000000000000000000000008"), Box::new(BN256Pairing));
    
    // EIP-152: BLAKE2b
    precompiles.insert(address!("0x0000000000000000000000000000000000000009"), Box::new(Blake2F));
    
    precompiles
}
```

## Advanced Topics

### EIP Compatibility

REVM implements compatibility with Ethereum protocol upgrades through the `SpecId` enum:

```rust
pub enum SpecId {
    FRONTIER,
    FRONTIER_THAWING,
    HOMESTEAD,
    DAO_FORK,
    TANGERINE,
    SPURIOUS_DRAGON,
    BYZANTIUM,
    CONSTANTINOPLE,
    PETERSBURG,
    ISTANBUL,
    MUIR_GLACIER,
    BERLIN,
    LONDON,
    ARROW_GLACIER,
    GRAY_GLACIER,
    MERGE,
    SHANGHAI,
    CANCUN,
    PRAGUE,
    LATEST,
}
```

Each spec ID represents a set of EIPs and rules. The interpreter checks the spec ID to determine how to execute opcodes and calculate gas costs.

### Static Analysis

REVM includes a bytecode analyzer that performs static analysis on contract code:

```rust
pub struct BytecodeAnalysis {
    pub jumpdest_set: BTreeSet<usize>,
    pub push_bytes: BTreeMap<usize, u8>,
}
```

This analysis:
1. Identifies all valid `JUMPDEST` locations
2. Tracks `PUSH` instructions and their sizes
3. Identifies invalid instructions

This allows REVM to:
1. Quickly validate jump targets
2. Skip over data bytes in `PUSH` instructions
3. Detect invalid instructions early

### Optimizations

REVM employs several optimizations to improve execution speed:

1. **Bytecode Analysis Caching**: Analyze bytecode once and cache the results
2. **Jump Map**: Pre-compute valid jump destinations
3. **Opcode Jump Table**: Use a jump table for fast opcode dispatch
4. **Batch Storage Access**: Combine multiple storage accesses when possible
5. **Memory Growth Preallocation**: Allocate memory in larger chunks to avoid frequent reallocations

## Examples

### Executing a Simple Addition

```rust
// Bytecode: PUSH1 0x05, PUSH1 0x07, ADD, STOP (0x6005600701600000)
let bytecode = hex::decode("6005600701600000").unwrap();
let code = Bytecode::new_raw(Bytes::from(bytecode));

// Create execution context
let mut env = Env::default();
env.tx.data = Bytes::default();

// Create in-memory database
let db = CacheDB::new(EmptyDB);

// Create EVM instance
let mut evm = Evm::new();
evm.env = env;
evm.database(db);
```

### Implementing a Custom Opcode Tracer

```rust
struct OpcodeTracer {
    trace: Vec<(u8, Vec<U256>)>,
}

impl<DB: Database> Inspector<DB> for OpcodeTracer {
    fn step(&mut self, data: InspectorData<'_, DB>, _is_static: bool) -> Eval {
        let pc = data.interp.program_counter();
        let opcode = data.interp.contract.bytecode.bytecode()[pc];
        let stack_copy = data.interp.stack().data[0..data.interp.stack().len()].to_vec();
        
        self.trace.push((opcode, stack_copy));
        
        Eval::Continue
    }
}

// Using the tracer
let mut tracer = OpcodeTracer { trace: Vec::new() };
evm.inspect(tracer);
let result = evm.transact().unwrap();

// Access trace results
let tracer = evm.take_inspector().unwrap();
for (opcode, stack) in tracer.trace {
    println!("Opcode: {:#04x} ({}), Stack: {:?}", 
        opcode, 
        OPCODE_JUMPMAP[opcode as usize].name,
        stack);
}
```

### Analyzing Gas Usage

```rust
struct GasTracer {
    opcode_gas: HashMap<u8, u64>,
    last_gas: u64,
}

impl<DB: Database> Inspector<DB> for GasTracer {
    fn step(&mut self, data: InspectorData<'_, DB>, _is_static: bool) -> Eval {
        self.last_gas = data.gas.remaining();
        Eval::Continue
    }
    
    fn step_end(&mut self, data: InspectorData<'_, DB>, _is_static: bool) -> Eval {
        let pc = data.interp.program_counter() - 1; // Executed opcode
        let opcode = data.interp.contract.bytecode.bytecode()[pc];
        
        let gas_used = self.last_gas - data.gas.remaining();
        *self.opcode_gas.entry(opcode).or_insert(0) += gas_used;
        
        Eval::Continue
    }
}

// Using the gas tracer
let mut gas_tracer = GasTracer { 
    opcode_gas: HashMap::new(),
    last_gas: 0,
};
evm.inspect(gas_tracer);
let result = evm.transact().unwrap();

// Access gas usage results
let gas_tracer = evm.take_inspector().unwrap();
for (opcode, gas) in gas_tracer.opcode_gas {
    println!("Opcode: {:#04x} ({}), Gas used: {}", 
        opcode, 
        OPCODE_JUMPMAP[opcode as usize].name,
        gas);
}
```

## Best Practices

### Optimizing Contract Code

1. **Minimize Storage Access**: SLOAD and SSTORE are expensive
2. **Batch Storage Writes**: Combine multiple storage writes
3. **Use Memory for Intermediate Values**: Memory is cheaper than storage
4. **Use STATICCALL for Read-Only Operations**: Avoids unnecessary state access costs
5. **Optimize Math Operations**: MUL, DIV, MOD are more expensive than ADD, SUB
6. **Minimize Memory Expansion**: Reuse memory space when possible
7. **Use Packed Storage**: Pack multiple values into a single storage slot

### Efficient EVM Implementation

1. **Cache Bytecode Analysis**: Analyze bytecode once and reuse results
2. **Implement Fast Opcode Dispatch**: Use jump tables or computed goto
3. **Optimize Hot Paths**: Focus on frequently used opcodes
4. **Batch Database Access**: Combine state reads/writes
5. **Use Stack-Based Allocation**: Avoid heap allocations in the execution loop
6. **Leverage SIMD for Cryptographic Operations**: Use hardware acceleration
7. **Implement Parallel Execution where Possible**: Execute independent operations concurrently

## Common Pitfalls

1. **Incorrect Gas Calculation**: Gas costs change with different EIPs
2. **Invalid Jump Destinations**: Not validating jump targets properly
3. **Stack Overflows/Underflows**: Not checking stack limits
4. **Memory Expansion Costs**: Forgetting to account for memory expansion
5. **EIP Compatibility**: Not implementing all required EIPs for a specific chain
6. **Return Data Handling**: Incorrect handling of return data in calls
7. **Static Call Violations**: Allowing state changes in static contexts
8. **Precompile Edge Cases**: Not handling all input cases in precompile contracts

## Conclusion

REVM's instruction set implementation provides a complete, efficient, and correct Ethereum Virtual Machine. By understanding the details of how instructions are executed, gas is calculated, and state is manipulated, you can:

1. Build optimized smart contracts
2. Create efficient EVM implementations
3. Develop accurate debugging and analysis tools
4. Understand the performance characteristics of Ethereum operations

For developers working directly with the EVM, this knowledge is essential for building robust and efficient Ethereum applications and tools.