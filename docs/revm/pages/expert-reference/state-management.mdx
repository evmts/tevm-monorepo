---
title: 4.6 State Management
description: Detailed guide about 4.6 state management in REVM (Rust Ethereum Virtual Machine)
---

# 4.6 State Management

This document provides a detailed reference for REVM's state management system, including account structure, storage layout, code storage, and state transition mechanisms.

## Overview of Ethereum State

Ethereum's state consists of a mapping from addresses to account states. Each account state contains:

1. **Balance**: The amount of Ether owned by the account
2. **Nonce**: A counter used to ensure each transaction can only be processed once
3. **Storage**: A mapping from 256-bit keys to 256-bit values
4. **Code**: The EVM bytecode associated with the account (empty for EOAs)

REVM implements this state model with flexibility to support various storage backends, from in-memory implementations to database-backed systems that can persist state between sessions.

## Account Structure

The core account structure in REVM is defined by the `AccountInfo` struct:

```rust
pub struct AccountInfo {
    /// Account balance
    pub balance: U256,
    /// Account nonce
    pub nonce: u64,
    /// Code hash
    pub code_hash: B256,
    /// Actual code (if available)
    pub code: Option<Bytecode>,
}
```

The `Bytecode` struct wraps the actual code with metadata:

```rust
pub struct Bytecode {
    /// Raw bytecode
    pub bytecode: Bytes,
    /// Hash of the bytecode (cached)
    pub hash: Option<B256>,
    /// Analysis of the bytecode (cached)
    pub analysis: Option<BytecodeAnalysis>,
}
```

Accounts are typically accessed through the `Account` struct, which combines account information with storage:

```rust
pub struct Account {
    /// Account information
    pub info: Option<AccountInfo>,
    /// Storage changes
    pub storage: Option<BTreeMap<U256, StorageValue>>,
    /// Original storage root
    pub storage_root: Option<B256>,
}
```

The `StorageValue` struct tracks both current and original values to support state changes and reverts:

```rust
pub struct StorageValue {
    /// Present (current) value
    pub present_value: U256,
    /// Original value (before changes)
    pub original_value: U256,
}
```

## Database Interface

REVM's state management is built around the `Database` trait:

```rust
pub trait Database {
    /// Error type associated with this database
    type Error;

    /// Get basic account information
    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error>;

    /// Get storage value at a given position
    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error>;

    /// Get block hash for a given block number
    fn block_hash(&self, number: U256) -> Result<B256, Self::Error>;

    /// Get code by its hash
    fn code_by_hash(&self, code_hash: B256) -> Result<Bytecode, Self::Error>;
}
```

This trait defines the essential operations for accessing Ethereum state. Implementations of this trait provide the actual storage mechanism.

## State Persistence and Modifications

For databases that support state changes, REVM provides the `DatabaseCommit` trait:

```rust
pub trait DatabaseCommit: Database {
    /// Commit changes to the database
    fn commit(&mut self, changes: HashMap<Address, Account>);
}
```

The `changes` map contains all the accounts that were modified during execution, along with their updated information.

## Storage Layout

Ethereum contract storage is a mapping from 256-bit keys to 256-bit values. In Solidity, this maps to storage slots:

- State variables are assigned slots sequentially starting from 0
- Value types (up to 32 bytes) occupy a single slot
- Complex types like arrays and mappings use more complex layouts

### Storage Slot Assignment Rules

1. **Static-sized variables**: Assigned sequential slots in order of declaration
2. **Dynamic arrays**: Start at `keccak256(p)` where `p` is the slot number
3. **Mappings**: For a mapping at slot `p`, the value for key `k` is at `keccak256(k . p)` (concatenation)
4. **Structs**: Treated as consecutive slots for their members
5. **Packed storage**: Multiple small variables (< 32 bytes) may be packed into a single slot

REVM doesn't enforce these rules directly (they're implemented by Solidity), but understanding them is essential for correctly manipulating contract storage.

## In-Memory Database

REVM provides an in-memory database implementation that's useful for testing and simulations:

```rust
pub struct InMemoryDB {
    /// Account states
    pub state: HashMap<Address, Account>,
    /// Block hashes
    pub block_hashes: HashMap<U256, B256>,
    /// Code cache
    pub code: HashMap<B256, Bytecode>,
}
```

The `InMemoryDB` implements both the `Database` and `DatabaseCommit` traits:

```rust
impl Database for InMemoryDB {
    type Error = InMemoryError;

    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        Ok(self.state.get(&address).and_then(|account| account.info.clone()))
    }

    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        if let Some(account) = self.state.get(&address) {
            if let Some(storage) = &account.storage {
                if let Some(slot) = storage.get(&index) {
                    return Ok(slot.present_value);
                }
            }
        }
        Ok(U256::ZERO)
    }

    fn block_hash(&self, number: U256) -> Result<B256, Self::Error> {
        Ok(self.block_hashes.get(&number).cloned().unwrap_or_default())
    }

    fn code_by_hash(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        self.code.get(&code_hash).cloned().ok_or(InMemoryError::CodeNotFound)
    }
}

impl DatabaseCommit for InMemoryDB {
    fn commit(&mut self, changes: HashMap<Address, Account>) {
        for (address, account) in changes {
            if let Some(info) = &account.info {
                // Store code in the code cache
                if let Some(code) = &info.code {
                    self.code.insert(info.code_hash, code.clone());
                }
            }
            
            // Update or delete the account
            if account.info.is_some() {
                self.state.insert(address, account);
            } else {
                self.state.remove(&address);
            }
        }
    }
}
```

## Cache Database

For improved performance, REVM provides a caching layer that can wrap any database implementation:

```rust
pub struct CacheDB<DB: Database> {
    /// Underlying database
    db: DB,
    /// Cached accounts
    accounts: HashMap<Address, Option<AccountInfo>>,
    /// Cached storage values
    storage: HashMap<(Address, U256), U256>,
    /// Cached block hashes
    block_hashes: HashMap<U256, B256>,
    /// Cached code
    code: HashMap<B256, Bytecode>,
}
```

The `CacheDB` implements the `Database` trait by checking its cache first, then falling back to the underlying database:

```rust
impl<DB: Database> Database for CacheDB<DB> {
    type Error = DB::Error;

    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        if let Some(account) = self.accounts.get(&address) {
            return Ok(account.clone());
        }
        
        self.db.basic(address)
    }

    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        if let Some(&value) = self.storage.get(&(address, index)) {
            return Ok(value);
        }
        
        self.db.storage(address, index)
    }

    fn block_hash(&self, number: U256) -> Result<B256, Self::Error> {
        if let Some(&hash) = self.block_hashes.get(&number) {
            return Ok(hash);
        }
        
        self.db.block_hash(number)
    }

    fn code_by_hash(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        if let Some(code) = self.code.get(&code_hash) {
            return Ok(code.clone());
        }
        
        self.db.code_by_hash(code_hash)
    }
}
```

It also implements `DatabaseCommit` by updating both the cache and the underlying database (if it supports commits):

```rust
impl<DB: DatabaseCommit> DatabaseCommit for CacheDB<DB> {
    fn commit(&mut self, changes: HashMap<Address, Account>) {
        // Update the cache
        for (address, account) in &changes {
            if let Some(info) = &account.info {
                self.accounts.insert(*address, Some(info.clone()));
                
                if let Some(code) = &info.code {
                    self.code.insert(info.code_hash, code.clone());
                }
                
                if let Some(storage) = &account.storage {
                    for (&slot, value) in storage {
                        self.storage.insert((*address, slot), value.present_value);
                    }
                }
            } else {
                self.accounts.insert(*address, None);
            }
        }
        
        // Forward changes to the underlying database
        self.db.commit(changes);
    }
}
```

## Journaled State

For transaction execution, REVM uses a journaling system to track state changes and support efficient reverts:

```rust
pub struct JournaledState {
    /// Current state of accounts
    accounts: HashMap<Address, Account>,
    /// Snapshots for reverting
    snapshots: HashMap<u64, JournalSnapshot>,
    /// Logs generated during execution
    logs: Vec<Log>,
    /// Next snapshot ID
    next_snapshot_id: u64,
    /// Touched accounts (for selfdestruct)
    touched: HashSet<Address>,
    /// EIP-2929 access list
    access_list: AccessList,
}
```

The `JournaledState` provides methods for accessing and modifying state:

```rust
impl JournaledState {
    /// Create a new journaled state
    pub fn new() -> Self {
        Self {
            accounts: HashMap::new(),
            snapshots: HashMap::new(),
            logs: Vec::new(),
            next_snapshot_id: 0,
            touched: HashSet::new(),
            access_list: AccessList::default(),
        }
    }
    
    /// Load an account from the database if not already loaded
    pub fn load_account<DB: Database>(
        &mut self,
        address: Address,
        db: &DB,
    ) -> Result<bool, DB::Error> {
        if self.accounts.contains_key(&address) {
            return Ok(false);
        }
        
        if let Some(info) = db.basic(address)? {
            self.accounts.insert(address, Account {
                info: Some(info),
                storage: None,
                storage_root: None,
            });
            Ok(true)
        } else {
            self.accounts.insert(address, Account {
                info: None,
                storage: None,
                storage_root: None,
            });
            Ok(false)
        }
    }
    
    /// Get a reference to an account
    pub fn account(&self, address: Address) -> Option<&Account> {
        self.accounts.get(&address)
    }
    
    /// Get a mutable reference to an account, loading it if necessary
    pub fn account_mut<DB: Database>(
        &mut self,
        address: Address,
        db: &mut DB,
    ) -> Result<&mut Account, DB::Error> {
        self.load_account(address, db)?;
        Ok(self.accounts.get_mut(&address).unwrap())
    }
    
    /// Load storage value
    pub fn load_storage<DB: Database>(
        &mut self,
        address: Address,
        key: U256,
        db: &DB,
    ) -> Result<U256, DB::Error> {
        // Load the account if not loaded
        self.load_account(address, db)?;
        
        let account = self.accounts.get_mut(&address).unwrap();
        
        // Return cached value if available
        if let Some(storage) = &account.storage {
            if let Some(value) = storage.get(&key) {
                return Ok(value.present_value);
            }
        }
        
        // Load from database
        let value = db.storage(address, key)?;
        
        // Initialize storage if needed
        if account.storage.is_none() {
            account.storage = Some(BTreeMap::new());
        }
        
        // Cache the value
        if let Some(storage) = &mut account.storage {
            storage.insert(key, StorageValue {
                present_value: value,
                original_value: value,
            });
        }
        
        Ok(value)
    }
    
    /// Set storage value
    pub fn store<DB: Database>(
        &mut self,
        address: Address,
        key: U256,
        value: U256,
        db: &mut DB,
    ) -> Result<U256, DB::Error> {
        // Ensure the account exists
        self.load_account(address, db)?;
        
        let account = self.accounts.get_mut(&address).unwrap();
        
        // Load current value
        let current = self.load_storage(address, key, db)?;
        
        // Update storage
        if let Some(storage) = &mut account.storage {
            storage.insert(key, StorageValue {
                present_value: value,
                original_value: current,
            });
        }
        
        Ok(current)
    }
    
    /// Create a snapshot
    pub fn checkpoint(&mut self) -> u64 {
        let id = self.next_snapshot_id;
        self.next_snapshot_id += 1;
        
        // Create a snapshot of the current state
        self.snapshots.insert(id, JournalSnapshot {
            accounts: self.accounts.keys().map(|&addr| {
                (addr, self.account_snapshot(addr))
            }).collect(),
            logs_count: self.logs.len(),
            touched: self.touched.clone(),
            access_list: self.access_list.clone(),
        });
        
        id
    }
    
    /// Revert to a snapshot
    pub fn revert(&mut self, id: u64) -> bool {
        let snapshot = match self.snapshots.remove(&id) {
            Some(s) => s,
            None => return false,
        };
        
        // Remove snapshots with higher IDs
        self.snapshots.retain(|&snapshot_id, _| snapshot_id < id);
        
        // Revert accounts
        for (address, account_snapshot) in snapshot.accounts {
            if let Some(account) = self.accounts.get_mut(&address) {
                // Revert account info
                account.info = account_snapshot.info;
                
                // Revert storage
                if let Some(storage_snapshot) = account_snapshot.storage {
                    if let Some(storage) = &mut account.storage {
                        // Apply snapshot to existing storage
                        for (key, value) in storage_snapshot {
                            storage.insert(key, value);
                        }
                    } else {
                        // Set storage from snapshot
                        account.storage = Some(storage_snapshot);
                    }
                }
            }
        }
        
        // Revert logs
        self.logs.truncate(snapshot.logs_count);
        
        // Revert touched accounts
        self.touched = snapshot.touched;
        
        // Revert access list
        self.access_list = snapshot.access_list;
        
        true
    }
    
    /// Commit changes to a database
    pub fn commit<DB: DatabaseCommit>(&mut self, db: &mut DB) -> Result<(), DB::Error> {
        // Extract changes to commit
        let changes: HashMap<Address, Account> = self.accounts.drain()
            .map(|(addr, account)| (addr, account))
            .collect();
        
        // Commit to database
        db.commit(changes);
        
        // Reset state
        self.accounts.clear();
        self.snapshots.clear();
        self.logs.clear();
        self.next_snapshot_id = 0;
        self.touched.clear();
        self.access_list = AccessList::default();
        
        Ok(())
    }
}
```

## State Transitions

State transitions in Ethereum occur through transaction execution. REVM provides a transaction executor in the `Evm` struct:

```rust
impl<DB: Database> Evm<DB> {
    pub fn transact(&mut self) -> Result<ExecutionResult, EVMError<DB::Error>> {
        // Prepare execution context
        self.prepare_for_transaction()?;
        
        // Create journaled state
        let mut state = JournaledState::new();
        
        // Get database
        let db = match &mut self.db {
            Some(db) => db,
            None => return Err(EVMError::Database("No database provided".to_string())),
        };
        
        // Execute based on transaction type
        match self.env.tx.transact_to {
            TransactTo::Call(to) => {
                self.call_transaction(&mut state, to, db)
            },
            TransactTo::Create(CreateScheme::Create) => {
                self.create_transaction(&mut state, db)
            },
            TransactTo::Create(CreateScheme::Create2 { salt }) => {
                self.create2_transaction(&mut state, salt, db)
            },
        }
    }
    
    // (implementation of call_transaction, create_transaction, etc.)
}
```

The main state transition steps are:

1. **Account Loading**: Load sender and recipient accounts
2. **Balance and Nonce Checks**: Verify sender has sufficient balance and correct nonce
3. **Gas Payment**: Deduct gas cost from sender's balance
4. **Contract Creation or Call Execution**: Perform the operation
5. **State Updates**: Update all affected accounts
6. **Gas Refund**: Return unused gas to the sender
7. **Log Recording**: Record all emitted logs

## Storage Examples

### Reading and Writing Storage

```rust
// Reading storage
async fn read_storage_example<DB: Database>(
    evm: &mut Evm<DB>,
    contract_address: Address,
    slot: U256,
) -> Result<U256, EVMError<DB::Error>> {
    // Set up a call transaction to read storage
    let tx_env = TxEnv {
        caller: Address::zero(), // Can be any address for read-only operations
        value: U256::ZERO,
        data: Bytes::new(), // No call data needed for direct storage access
        gas_limit: 21000,
        gas_price: U256::from(1_000_000_000), // 1 gwei
        transact_to: TransactTo::Call(contract_address),
        ..TxEnv::default()
    };
    
    // Save the original transaction
    let original_tx = std::mem::replace(&mut evm.env.tx, tx_env);
    
    // Access storage directly using the database interface
    let db = evm.db().unwrap();
    let value = db.storage(contract_address, slot)?;
    
    // Restore the original transaction
    evm.env.tx = original_tx;
    
    Ok(value)
}

// Writing storage
async fn write_storage_example<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    contract_address: Address,
    slot: U256,
    value: U256,
) -> Result<(), EVMError<DB::Error>> {
    // Create a journaled state
    let mut state = JournaledState::new();
    
    // Get database
    let db = evm.db_mut().unwrap();
    
    // Make sure the account exists
    state.load_account(contract_address, db)?;
    
    // Write to storage
    state.store(contract_address, slot, value, db)?;
    
    // Commit changes
    state.commit(db)?;
    
    Ok(())
}
```

### Account Creation and Modification

```rust
// Create a new account
fn create_account_example<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    address: Address,
    balance: U256,
    code: Option<Bytes>,
) -> Result<(), EVMError<DB::Error>> {
    // Get database
    let db = evm.db_mut().unwrap();
    
    // Create account info
    let info = AccountInfo {
        balance,
        nonce: 0,
        code_hash: if code.is_some() {
            // Calculate code hash
            let hash = keccak256(code.as_ref().unwrap().as_ref());
            B256::from_slice(&hash)
        } else {
            // Empty code hash
            B256::from([0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 
                        0x92, 0x7e, 0x7d, 0xb2, 0xdc, 0xc7, 0x03, 0xc0, 
                        0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82, 0x27, 0x3b, 
                        0x7b, 0xfa, 0xd8, 0x04, 0x5d, 0x85, 0xa4, 0x70])
        },
        code: code.map(|code| Bytecode::new_raw(code)),
    };
    
    // Create account
    let account = Account {
        info: Some(info),
        storage: Some(BTreeMap::new()),
        storage_root: None,
    };
    
    // Commit changes
    let mut changes = HashMap::new();
    changes.insert(address, account);
    db.commit(changes);
    
    Ok(())
}

// Modify an account
fn modify_account_example<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    address: Address,
    new_balance: Option<U256>,
    new_nonce: Option<u64>,
) -> Result<(), EVMError<DB::Error>> {
    // Get database
    let db = evm.db_mut().unwrap();
    
    // Load account
    let account_info = db.basic(address)?
        .ok_or_else(|| EVMError::Database("Account not found".to_string()))?;
    
    // Create updated account info
    let updated_info = AccountInfo {
        balance: new_balance.unwrap_or(account_info.balance),
        nonce: new_nonce.unwrap_or(account_info.nonce),
        code_hash: account_info.code_hash,
        code: account_info.code,
    };
    
    // Create updated account
    let account = Account {
        info: Some(updated_info),
        storage: None, // No storage changes
        storage_root: None,
    };
    
    // Commit changes
    let mut changes = HashMap::new();
    changes.insert(address, account);
    db.commit(changes);
    
    Ok(())
}
```

### Snapshot and Revert

```rust
// Using snapshots for state management
fn snapshot_example<DB: Database>(
    evm: &mut Evm<DB>,
    contract_address: Address,
) -> Result<(), EVMError<DB::Error>> {
    // Create a journaled state
    let mut state = JournaledState::new();
    
    // Get database
    let db = evm.db_mut().unwrap();
    
    // Take a snapshot of the initial state
    let snapshot_id = state.checkpoint();
    
    // Perform some operations
    state.load_account(contract_address, db)?;
    let account = state.account_mut(contract_address, db)?;
    
    if let Some(info) = &mut account.info {
        // Modify balance
        info.balance += U256::from(1_000_000);
    }
    
    // Store some values
    state.store(contract_address, U256::from(1), U256::from(100), db)?;
    state.store(contract_address, U256::from(2), U256::from(200), db)?;
    
    // Take another snapshot
    let snapshot_id2 = state.checkpoint();
    
    // Make more changes
    state.store(contract_address, U256::from(3), U256::from(300), db)?;
    
    // Revert to the second snapshot
    state.revert(snapshot_id2);
    
    // Verify that the third storage slot was not changed
    let value3 = state.load_storage(contract_address, U256::from(3), db)?;
    assert_eq!(value3, U256::ZERO);
    
    // Verify that the first two slots were changed
    let value1 = state.load_storage(contract_address, U256::from(1), db)?;
    let value2 = state.load_storage(contract_address, U256::from(2), db)?;
    assert_eq!(value1, U256::from(100));
    assert_eq!(value2, U256::from(200));
    
    // Revert to the first snapshot
    state.revert(snapshot_id);
    
    // Verify that all slots are back to their original values
    let value1 = state.load_storage(contract_address, U256::from(1), db)?;
    let value2 = state.load_storage(contract_address, U256::from(2), db)?;
    assert_eq!(value1, U256::ZERO);
    assert_eq!(value2, U256::ZERO);
    
    Ok(())
}
```

## Best Practices

### 1. Efficient State Access

- **Batch similar operations**: Group reads and writes to minimize database round-trips
- **Use caching**: Wrap database implementations with `CacheDB` for better performance
- **Prefetch related data**: Load data that's likely to be needed soon
- **Minimize state changes**: Avoid unnecessary state modifications

```rust
// Efficient batch state access
fn efficient_state_access<DB: Database>(
    evm: &mut Evm<DB>,
    addresses: &[Address],
) -> Result<(), EVMError<DB::Error>> {
    // Use a journaled state for efficient caching
    let mut state = JournaledState::new();
    let db = evm.db().unwrap();
    
    // Batch load accounts
    for &address in addresses {
        state.load_account(address, db)?;
    }
    
    // Batch load storage for all accounts
    let keys = [U256::from(1), U256::from(2), U256::from(3)];
    for &address in addresses {
        for &key in &keys {
            state.load_storage(address, key, db)?;
        }
    }
    
    // Now all data is cached and can be accessed without database hits
    for &address in addresses {
        if let Some(account) = state.account(address) {
            if let Some(info) = &account.info {
                // Process account...
            }
        }
    }
    
    Ok(())
}
```

### 2. State Mutation Management

- **Use snapshots for atomic operations**: Take snapshots before state-changing operations
- **Commit only when necessary**: Minimize database writes
- **Handle commit failures gracefully**: Have fallback strategies for failed commits
- **Verify critical state changes**: Double-check important state transitions

```rust
// Atomic state mutation
fn atomic_state_mutation<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    operations: &[(Address, U256, U256)],
) -> Result<(), EVMError<DB::Error>> {
    // Create a journaled state
    let mut state = JournaledState::new();
    let db = evm.db_mut().unwrap();
    
    // Take a snapshot
    let snapshot_id = state.checkpoint();
    
    // Perform operations
    for &(address, key, value) in operations {
        if let Err(err) = state.store(address, key, value, db) {
            // Something went wrong, revert all changes
            state.revert(snapshot_id);
            return Err(EVMError::Database(format!("Storage error: {:?}", err)));
        }
    }
    
    // All operations succeeded, commit changes
    state.commit(db)?;
    
    Ok(())
}
```

### 3. Storage Optimization

- **Pack related data**: Store multiple small values in a single slot
- **Use sequential slots**: Group related data in sequential slots for better caching
- **Clean up unused storage**: Set slots to zero when no longer needed to get gas refunds
- **Minimize storage for temporary data**: Use memory for intermediate values

```rust
// Example of packed storage
fn pack_storage_example<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    contract: Address,
    values: &[u8; 32],
) -> Result<(), EVMError<DB::Error>> {
    // Pack 32 single-byte values into one storage slot
    let mut packed = U256::ZERO;
    for (i, &value) in values.iter().enumerate() {
        packed = packed | (U256::from(value) << (i * 8));
    }
    
    // Store in a single slot
    let mut state = JournaledState::new();
    let db = evm.db_mut().unwrap();
    
    state.store(contract, U256::ZERO, packed, db)?;
    state.commit(db)?;
    
    Ok(())
}
```

### 4. Account Management

- **Check existence before operations**: Verify accounts exist before accessing
- **Initialize storage maps**: When setting the first storage value for an account
- **Handle non-existent accounts gracefully**: Return appropriate defaults
- **Clean up empty accounts**: Remove accounts when balance, code, and storage are empty

```rust
// Proper account management
fn account_management<DB: Database + DatabaseCommit>(
    evm: &mut Evm<DB>,
    address: Address,
) -> Result<(), EVMError<DB::Error>> {
    let mut state = JournaledState::new();
    let db = evm.db_mut().unwrap();
    
    // Check if account exists
    let exists = state.load_account(address, db)?;
    
    if !exists {
        // Create a new account with standard defaults
        let info = AccountInfo {
            balance: U256::ZERO,
            nonce: 0,
            code_hash: B256::from([0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 
                                  0x92, 0x7e, 0x7d, 0xb2, 0xdc, 0xc7, 0x03, 0xc0, 
                                  0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82, 0x27, 0x3b, 
                                  0x7b, 0xfa, 0xd8, 0x04, 0x5d, 0x85, 0xa4, 0x70]),
            code: None,
        };
        
        let account = Account {
            info: Some(info),
            storage: Some(BTreeMap::new()),
            storage_root: None,
        };
        
        let mut changes = HashMap::new();
        changes.insert(address, account);
        db.commit(changes);
    }
    
    // Now safe to access the account
    let account = state.account_mut(address, db)?;
    
    if let Some(info) = &mut account.info {
        // Process account...
    }
    
    Ok(())
}
```

### 5. Database Selection

- **Choose the right database for your use case**:
  - `InMemoryDB` for testing and simple simulations
  - `CacheDB` with persistent backend for production systems
  - Custom implementations for specialized needs
- **Consider persistence requirements**: Do you need state to survive restarts?
- **Consider scaling requirements**: How large will the state grow?
- **Consider performance requirements**: How many transactions per second?

```rust
// Database selection example
fn select_database(use_case: &str) -> Box<dyn Database<Error = Box<dyn std::error::Error>> + DatabaseCommit> {
    match use_case {
        "testing" => {
            // Simple in-memory database for tests
            Box::new(InMemoryDB::new())
        },
        "simulation" => {
            // Cached in-memory database for better performance
            Box::new(CacheDB::new(InMemoryDB::new()))
        },
        "production" => {
            // Database with persistent storage
            let backend = PersistentDB::new("./data/ethereum_state");
            Box::new(CacheDB::new(backend))
        },
        "forking" => {
            // Database that forks from a remote node
            let fork_db = ForkDB::new("https://eth-mainnet.alchemyapi.io/v2/YOUR_API_KEY", Some(12_345_678));
            Box::new(CacheDB::new(fork_db))
        },
        _ => {
            // Default to in-memory
            Box::new(InMemoryDB::new())
        }
    }
}
```

## Custom Database Implementations

To implement a custom database, you need to implement the `Database` trait and optionally the `DatabaseCommit` trait:

### Example: LevelDB-Backed Database

```rust
use leveldb::database::Database as LevelDatabase;
use leveldb::options::{Options, ReadOptions, WriteOptions};
use leveldb::iterator::Iterable;
use leveldb::kv::KV;

pub struct LevelDB {
    db: LevelDatabase,
    write_options: WriteOptions,
    read_options: ReadOptions,
}

impl LevelDB {
    pub fn new(path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let mut options = Options::new();
        options.create_if_missing = true;
        
        let db = LevelDatabase::open(path, options)?;
        
        Ok(Self {
            db,
            write_options: WriteOptions::new(),
            read_options: ReadOptions::new(),
        })
    }
    
    // Helper to construct keys
    fn account_key(address: &Address) -> Vec<u8> {
        let mut key = vec![0]; // Prefix 0 for accounts
        key.extend_from_slice(address.as_bytes());
        key
    }
    
    fn storage_key(address: &Address, slot: &U256) -> Vec<u8> {
        let mut key = vec![1]; // Prefix 1 for storage
        key.extend_from_slice(address.as_bytes());
        
        let mut slot_bytes = [0u8; 32];
        slot.to_big_endian(&mut slot_bytes);
        key.extend_from_slice(&slot_bytes);
        
        key
    }
    
    fn block_hash_key(number: &U256) -> Vec<u8> {
        let mut key = vec![2]; // Prefix 2 for block hashes
        
        let mut number_bytes = [0u8; 32];
        number.to_big_endian(&mut number_bytes);
        key.extend_from_slice(&number_bytes);
        
        key
    }
    
    fn code_key(hash: &B256) -> Vec<u8> {
        let mut key = vec![3]; // Prefix 3 for code
        key.extend_from_slice(hash.as_bytes());
        key
    }
}

#[derive(Debug)]
pub enum LevelDBError {
    NotFound,
    Database(String),
    Serialization(String),
}

impl std::fmt::Display for LevelDBError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LevelDBError::NotFound => write!(f, "Key not found"),
            LevelDBError::Database(msg) => write!(f, "Database error: {}", msg),
            LevelDBError::Serialization(msg) => write!(f, "Serialization error: {}", msg),
        }
    }
}

impl std::error::Error for LevelDBError {}

impl Database for LevelDB {
    type Error = LevelDBError;
    
    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        let key = Self::account_key(&address);
        
        match self.db.get(self.read_options.clone(), &key) {
            Ok(Some(value)) => {
                // Deserialize account info
                let account: AccountInfo = bincode::deserialize(&value)
                    .map_err(|e| LevelDBError::Serialization(e.to_string()))?;
                
                Ok(Some(account))
            },
            Ok(None) => Ok(None),
            Err(e) => Err(LevelDBError::Database(e.to_string())),
        }
    }
    
    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        let key = Self::storage_key(&address, &index);
        
        match self.db.get(self.read_options.clone(), &key) {
            Ok(Some(value)) => {
                // Deserialize storage value
                let storage_value: U256 = bincode::deserialize(&value)
                    .map_err(|e| LevelDBError::Serialization(e.to_string()))?;
                
                Ok(storage_value)
            },
            Ok(None) => Ok(U256::ZERO),
            Err(e) => Err(LevelDBError::Database(e.to_string())),
        }
    }
    
    fn block_hash(&self, number: U256) -> Result<B256, Self::Error> {
        let key = Self::block_hash_key(&number);
        
        match self.db.get(self.read_options.clone(), &key) {
            Ok(Some(value)) => {
                // Deserialize block hash
                let hash: B256 = bincode::deserialize(&value)
                    .map_err(|e| LevelDBError::Serialization(e.to_string()))?;
                
                Ok(hash)
            },
            Ok(None) => Ok(B256::default()),
            Err(e) => Err(LevelDBError::Database(e.to_string())),
        }
    }
    
    fn code_by_hash(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        let key = Self::code_key(&code_hash);
        
        match self.db.get(self.read_options.clone(), &key) {
            Ok(Some(value)) => {
                // Deserialize bytecode
                let bytecode: Bytecode = bincode::deserialize(&value)
                    .map_err(|e| LevelDBError::Serialization(e.to_string()))?;
                
                Ok(bytecode)
            },
            Ok(None) => Err(LevelDBError::NotFound),
            Err(e) => Err(LevelDBError::Database(e.to_string())),
        }
    }
}

impl DatabaseCommit for LevelDB {
    fn commit(&mut self, changes: HashMap<Address, Account>) {
        // Start a batch write
        let mut batch = leveldb::batch::Batch::new();
        
        for (address, account) in changes {
            let account_key = Self::account_key(&address);
            
            match account.info {
                Some(info) => {
                    // Serialize and store account info
                    if let Ok(encoded) = bincode::serialize(&info) {
                        batch.put(&account_key, &encoded);
                    }
                    
                    // Store code if present
                    if let Some(code) = &info.code {
                        let code_key = Self::code_key(&info.code_hash);
                        if let Ok(encoded) = bincode::serialize(code) {
                            batch.put(&code_key, &encoded);
                        }
                    }
                },
                None => {
                    // Delete account
                    batch.delete(&account_key);
                }
            }
            
            // Update storage
            if let Some(storage) = account.storage {
                for (slot, value) in storage {
                    let storage_key = Self::storage_key(&address, &slot);
                    
                    if value.present_value == U256::ZERO {
                        // Delete storage slot
                        batch.delete(&storage_key);
                    } else {
                        // Store value
                        if let Ok(encoded) = bincode::serialize(&value.present_value) {
                            batch.put(&storage_key, &encoded);
                        }
                    }
                }
            }
        }
        
        // Commit batch
        let _ = self.db.write(self.write_options.clone(), &batch);
    }
}
```

### Example: Forking Database

A forking database allows REVM to fork from a live Ethereum network state:

```rust
use ethers_providers::{Http, Middleware, Provider};
use ethers_core::types::{BlockId, BlockNumber, H160, H256, U64};
use std::sync::Arc;
use tokio::runtime::Runtime;

pub struct ForkDB {
    provider: Arc<Provider<Http>>,
    block_number: Option<u64>,
    runtime: Runtime,
    cache: CacheDB<EmptyDB>,
}

impl ForkDB {
    pub fn new(rpc_url: &str, block_number: Option<u64>) -> Result<Self, Box<dyn std::error::Error>> {
        let provider = Arc::new(Provider::<Http>::try_from(rpc_url)?);
        let runtime = Runtime::new()?;
        
        Ok(Self {
            provider,
            block_number,
            runtime,
            cache: CacheDB::new(EmptyDB),
        })
    }
    
    fn block_id(&self) -> BlockId {
        match self.block_number {
            Some(num) => BlockId::Number(BlockNumber::Number(U64::from(num))),
            None => BlockId::Number(BlockNumber::Latest),
        }
    }
}

pub enum ForkDBError {
    Provider(String),
    Runtime(String),
    NotFound,
}

impl std::fmt::Display for ForkDBError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ForkDBError::Provider(msg) => write!(f, "Provider error: {}", msg),
            ForkDBError::Runtime(msg) => write!(f, "Runtime error: {}", msg),
            ForkDBError::NotFound => write!(f, "Not found"),
        }
    }
}

impl std::error::Error for ForkDBError {}

impl Database for ForkDB {
    type Error = ForkDBError;
    
    fn basic(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        // Check cache first
        match self.cache.basic(address) {
            Ok(Some(info)) => return Ok(Some(info)),
            Ok(None) => return Ok(None),
            Err(_) => {} // Fall through to provider
        }
        
        // Not in cache, fetch from provider
        let h160_address = H160::from_slice(address.as_bytes());
        let block_id = self.block_id();
        
        let account_future = async {
            // Get balance
            let balance = match self.provider.get_balance(h160_address, Some(block_id)).await {
                Ok(bal) => {
                    let mut bytes = [0u8; 32];
                    bal.to_little_endian(&mut bytes);
                    U256::from_be_bytes(bytes)
                },
                Err(e) => {
                    return Err(ForkDBError::Provider(e.to_string()));
                }
            };
            
            // Get nonce
            let nonce = match self.provider.get_transaction_count(h160_address, Some(block_id)).await {
                Ok(n) => n.as_u64(),
                Err(e) => {
                    return Err(ForkDBError::Provider(e.to_string()));
                }
            };
            
            // Get code
            let code = match self.provider.get_code(h160_address, Some(block_id)).await {
                Ok(c) => {
                    if c.0.is_empty() {
                        None
                    } else {
                        Some(Bytecode::new_raw(Bytes::from(c.0.to_vec())))
                    }
                },
                Err(e) => {
                    return Err(ForkDBError::Provider(e.to_string()));
                }
            };
            
            if code.is_none() && balance == U256::ZERO && nonce == 0 {
                // Account doesn't exist
                Ok(None)
            } else {
                // Account exists
                let code_hash = if let Some(code) = &code {
                    let hash = keccak256(code.bytecode().as_ref());
                    B256::from_slice(&hash)
                } else {
                    // Empty code hash
                    B256::from([0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 
                               0x92, 0x7e, 0x7d, 0xb2, 0xdc, 0xc7, 0x03, 0xc0, 
                               0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82, 0x27, 0x3b, 
                               0x7b, 0xfa, 0xd8, 0x04, 0x5d, 0x85, 0xa4, 0x70])
                };
                
                Ok(Some(AccountInfo {
                    balance,
                    nonce: nonce.into(),
                    code_hash,
                    code,
                }))
            }
        };
        
        let result = match self.runtime.block_on(account_future) {
            Ok(info) => info,
            Err(e) => return Err(e),
        };
        
        // Cache the result
        if let Some(info) = &result {
            let mut account = Account {
                info: Some(info.clone()),
                storage: None,
                storage_root: None,
            };
            
            let mut changes = HashMap::new();
            changes.insert(address, account);
            self.cache.commit(changes);
        } else {
            // Cache negative result
            let mut changes = HashMap::new();
            changes.insert(address, Account {
                info: None,
                storage: None,
                storage_root: None,
            });
            self.cache.commit(changes);
        }
        
        Ok(result)
    }
    
    fn storage(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
        // Check cache first
        match self.cache.storage(address, index) {
            Ok(value) => {
                if value != U256::MAX {
                    return Ok(value);
                }
            },
            Err(_) => {} // Fall through to provider
        }
        
        // Not in cache, fetch from provider
        let h160_address = H160::from_slice(address.as_bytes());
        let slot = H256::from_slice(&index.to_be_bytes::<32>());
        let block_id = self.block_id();
        
        let storage_future = async {
            match self.provider.get_storage_at(h160_address, slot, Some(block_id)).await {
                Ok(value) => {
                    let mut bytes = [0u8; 32];
                    value.to_little_endian(&mut bytes);
                    Ok(U256::from_be_bytes(bytes))
                },
                Err(e) => {
                    Err(ForkDBError::Provider(e.to_string()))
                }
            }
        };
        
        let value = match self.runtime.block_on(storage_future) {
            Ok(value) => value,
            Err(e) => return Err(e),
        };
        
        // Cache the result
        self.cache.db().insert_account_storage(address, index, value);
        
        Ok(value)
    }
    
    fn block_hash(&self, number: U256) -> Result<B256, Self::Error> {
        // Check cache first
        match self.cache.block_hash(number) {
            Ok(hash) => {
                if hash != B256::default() {
                    return Ok(hash);
                }
            },
            Err(_) => {} // Fall through to provider
        }
        
        // If requested number is future relative to fork, return empty hash
        if let Some(fork_number) = self.block_number {
            if number.as_u64() > fork_number {
                return Ok(B256::default());
            }
        }
        
        // Not in cache, fetch from provider
        let block_future = async {
            match self.provider.get_block(number.as_u64()).await {
                Ok(Some(block)) => {
                    let hash = block.hash.unwrap_or_default();
                    Ok(B256::from_slice(hash.as_bytes()))
                },
                Ok(None) => {
                    Ok(B256::default())
                },
                Err(e) => {
                    Err(ForkDBError::Provider(e.to_string()))
                }
            }
        };
        
        let hash = match self.runtime.block_on(block_future) {
            Ok(hash) => hash,
            Err(e) => return Err(e),
        };
        
        // Cache the result
        let mut changes = HashMap::new();
        changes.insert(number, hash);
        self.cache.insert_block_hash(number, hash);
        
        Ok(hash)
    }
    
    fn code_by_hash(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
        // Check cache first
        match self.cache.code_by_hash(code_hash) {
            Ok(code) => return Ok(code),
            Err(_) => {} // Fall through to error
        }
        
        // We don't have a direct way to fetch code by hash from providers
        // This would typically require first finding an account with this code hash
        Err(ForkDBError::NotFound)
    }
}

impl DatabaseCommit for ForkDB {
    fn commit(&mut self, changes: HashMap<Address, Account>) {
        // Commit changes to the cache
        self.cache.commit(changes);
    }
}
```

## Conclusion

REVM's state management system provides a powerful and flexible way to interact with Ethereum state. By understanding the account structure, storage layout, and state transition mechanisms, you can:

1. Build efficient state access patterns
2. Implement custom database backends
3. Optimize storage usage
4. Create atomic state operations with snapshots
5. Implement specialized state management for your use case

The combination of a clean database interface, journaled state, and flexible storage options makes REVM suitable for a wide range of applications, from testing and development to production systems.