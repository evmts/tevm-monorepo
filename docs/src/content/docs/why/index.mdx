---
title: Why Tevm
description: Explanation of Tevm and it's use case
---

# Why Tevm

Tevm fills the tooling gap missing for the intersection of the EVM, JavaScript, and the browser.

## Tevm in context

EVM tooling has seen a renesance. [viem](https://viem.sh/), [wagmi](https://wagmi.sh/), and [abitype](https://abitype.dev/) raised the bar for how lightweight and typesafe EVM tooling can be. Tools like [MUD](https://mud.dev/), [Ponder](https://ponder.sh/), and [ThirdWeb](https://thirdweb.com/) continue to raise the bar on how productive and robust EVM TypeScript applications can be.

So what is still missing? Tevm identified two major items:

1. Low level EVM tooling. Unlike other ecosystems like [Rust](https://github.com/foundry-rs/foundry) and [Golang](https://geth.ethereum.org/docs) there are no typesafe powerful low level EVM utilities for running a node or executing bytecode in JavaScript.
2. Contract bundling. Though there have been [attempts](https://github.com/Consensys/truffle-solidity-loader) to bundle abis into TypeScript, no fully built out typesafe solution has been built. This is a basic expectation for other tools such as [CSS](https://github.com/css-modules/css-modules) and [graphql](https://www.apollographql.com/docs/react/integrations/webpack/).

Next we will go over common use cases which will demonstrate how these restrictions hurt user experience and how Tevm solves it.
