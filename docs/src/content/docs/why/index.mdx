---
title: Why Tevm
description: Explanation of Tevm and it's use case
---

# Why Tevm

Tevm fills the tooling gap missing for the intersection of the EVM, JavaScript, and the browser.

## Tevm in context

EVM tooling has seen a renesance. [viem](https://viem.sh/), [wagmi](https://wagmi.sh/), and [abitype](https://abitype.dev/) raised the bar for how lightweight and typesafe EVM tooling can be. Tools like [MUD](https://mud.dev/), [Ponder](https://ponder.sh/), and [ThirdWeb](https://thirdweb.com/) continue to raise the bar on how productive and robust EVM TypeScript applications can be.

So what is still missing? Tevm identified two major items:

1. Low level EVM tooling. Unlike other ecosystems like [Rust](https://github.com/foundry-rs/foundry) and [Golang](https://geth.ethereum.org/docs) there are no typesafe powerful low level EVM utilities for running a node or executing bytecode in JavaScript.
2. Contract bundling. Though there have been [attempts](https://github.com/Consensys/truffle-solidity-loader) to bundle abis into TypeScript, no fully built out typesafe solution has been built. This is a basic expectation for other tools such as [CSS](https://github.com/css-modules/css-modules) and [graphql](https://www.apollographql.com/docs/react/integrations/webpack/).

Next we will go over common use cases which will demonstrate how these restrictions hurt user experience and how Tevm solves it.

## Slow to load UI from waterfall calls

This use case is first because

- It demonstrates that Tevm brings extra powers to your existing toolchain such as Viem it does not replace it.
- Demonstrates a bad UX problem the blockchain industry takes for granted. We will see many more

A waterfall call is when one [eth_call](https://viem.sh/docs/actions/public/call.html) blocks another `eth_call` from being able to execute causing slow to load UI. Here is a simple example:

```typescript
// First, we need to get the owner of the token
const owner = await client.readContract({
  address: '0x123...', // NFT contract address
  abi: nftABI,
  functionName: 'ownerOf',
  args: [tokenId]
})
// Then, after waiting, we can get the balance of the owner
const balance = await client.readContract({
  address: '0x456...', // ERC20 token contract address
  abi: erc20ABI,
  functionName: 'balanceOf',
  args: [owner]
})
// now we can finally display the UI
```

In the above example we need to wait 2 round trips before updating the UI.

The existing solution for this issue is multicall but it does not help us here. The second query depends on the first one. Luckily, with Tevm+Viem we should be able to consistently avoid these issues and even fetch all data our app needs in a single request if we wished to.

To solve this problem Tevm collaborated with Viem to make a very simple solution:

**Warning this example is using an unreleased Tevm feature, inline solidity, that will be released soon. See [this thread for how to do this today](https://x.com/FUCORY/status/1801546199092367532).**

```typescript
import {sol} from 'tevm'

// write solidity to
const {bytecode, abi} = sol`
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

contract GetBalanceOfTokenOwner {
    function run(IERC721 nft, uint256 tokenId) public view returns (uint256) {
        address owner = nft.ownerOf(tokenId);
        return nft.balanceOf(owner);
    }
}
`

const balance = client.readContract({
  code: bytecode,
  abi,
  functionName: 'run',
  args: [tokenAddress, tokenId]
})
```

What the above code allowed us to do is write solidity code inline in our javascript that gets our data in one call. Tevm worked with viem to expose this `code` property that will encode our contract such that we are executing our deployless contract. Unlike state overrides or other advanced solutions this solution has 100% compatibility for all RPC providers.

In Tevm we call this bring-your-own-view-function and we will see more use cases for BYOVF in the future.

##