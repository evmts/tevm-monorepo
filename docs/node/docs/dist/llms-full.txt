# Tevm Node

## Example

This is an example page.


## Getting Started

Welcome to [Tevm Node](https://github.com/evmts/tevm-monorepo)! This guide will help you navigate our documentation and get started with running [Ethereum](https://ethereum.org) in JavaScript.

If you're impatient, try creating a [memory client](/api/memory-client) and using the [viem API](https://viem.sh) to interact with a locally running blockchain in JavaScript:

```ts
npm install tevm
```

```ts
import { createMemoryClient, http } from 'tevm/node'
import { optimism } from 'tevm/common'

// Create a client that forks from Optimism mainnet
const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io')({}),
    blockTag: 420n,
  },
  common: optimism,
})

// Read block data using viem's public actions
const block = await client.getBlock({ blockTag: 420n })
console.log(block) // Block data from Optimism mainnet at block 420
```

### Quick Start

Start here to understand the basics:

* [What is Tevm Node?](./introduction/what-is-tevm-node) - Overview and key features
* [Architecture Overview](./introduction/architecture-overview) - High-level explanation of how Tevm works
* [Why run Ethereum in JS?](./introduction/why-run-ethereum-in-js) - Benefits and use cases
* [Installation & Quickstart](./introduction/installation) - Get up and running

### Learning Path

#### 1. Core Concepts

Learn the fundamental building blocks:

* [Creating a Node](./core/create-tevm-node) - Set up and configure your node
* [Node Interface](./core/tevm-node-interface) - Understand the main API surface
* [Forking & Reforking](./core/forking) - Fork from networks or other Tevm instances
* [Managing State](./core/managing-state) - Handle accounts, storage, and blockchain state
* [Mining Configuration](#TODO) - Configure block production

#### 2. Essential APIs

Most commonly used APIs:

* [tevmCall API](./api/tevm-call) - Execute contract calls and transactions
* [JSON-RPC Support](./api/json-rpc) - Standard Ethereum JSON-RPC interface
* [Account Management](./api/account-management) - Work with accounts and balances
* [Contract Utilities](./api/contracts) - Create and interact with contracts
* [Utilities & Addresses](./api/utils) - Core utilities for addresses and common operations
* [Methods & Properties](./api/methods) - Complete API reference
* [VM & Submodules](./api/vm-and-submodules) - Internal architecture based on ethereumjs
* [EVM Events](./api/evm-events) - Debug and trace EVM execution

#### 3. Integration Examples

Real-world usage examples:

* [Local Testing](./examples/local-testing) - Write tests for your contracts
* [Forking Mainnet](./examples/forking-mainnet) - Work with production state locally
* [Using with Viem](./examples/viem) - Integration with [Viem](https://viem.sh)
* [Using with Ethers](./examples/ethers) - Integration with [Ethers.js](https://docs.ethers.org)

#### 4. Advanced Features

Dive deeper into advanced capabilities:

* [Transaction Pool](./advanced/txpool) - Manage pending transactions
* [Custom Precompiles](./advanced/custom-precompiles) - Extend EVM functionality
* [Performance Profiler](./advanced/performance-profiler) - Optimize performance
* [Receipts & Logs](./advanced/receipts-and-logs) - Handle events and logs

### Key Features

#### Forking & State Management

* Fork from any EVM-compatible network
* Memory-efficient reforking strategies
* Complete state control and manipulation
* Account impersonation for testing

#### Performance & Flexibility

* Automatic or manual block mining
* Lazy loading with caching
* Custom precompiles in JavaScript
* Comprehensive debugging tools

#### Developer Experience

* TypeScript-first design
* Viem & Ethers.js compatibility
* Standard JSON-RPC support
* Rich testing utilities

### Additional Resources

* [Ethereum Development Documentation](https://ethereum.org/en/developers/docs/) - Official Ethereum docs
* [EVM Deep Dive](https://ethereum.org/en/developers/docs/evm/) - Understanding the EVM
* [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) - Standard Ethereum API
* [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo) - Core EVM implementation

#### Debugging Example

```ts
import { createTevmNode } from 'tevm/node'

const node = createTevmNode()
const vm = await node.getVm()

// Listen to EVM execution events
vm.evm.events?.on('step', (step, next) => {
  console.log('Executing opcode:', step.opcode.name)
  next?.()
})

vm.evm.events?.on('afterMessage', (result, next) => {
  if (result.execResult.exceptionError) {
    console.error('Error:', result.execResult.exceptionError)
  }
  next?.()
})

// Your contract interactions here...
```


## Account Management

Tevm provides two key actions for managing account state: `tevmGetAccount` and `tevmSetAccount`.

### tevmGetAccount

The `tevmGetAccount` action allows you to retrieve the current state of an account.

#### Parameters

```ts
type GetAccountParams = {
  // Required address of the account
  address: Address
  // Optional block tag to query state from
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to return storage (can be expensive)
  returnStorage?: boolean
}
```

#### Return Type

```ts
type GetAccountResult = {
  // Address of the account
  address: Address
  // Current nonce
  nonce: bigint
  // Balance in wei
  balance: bigint
  // Deployed bytecode (if contract)
  deployedBytecode: Hex
  // Storage root
  storageRoot: Hex
  // Code hash
  codeHash: Hex
  // Whether this is a contract
  isContract: boolean
  // Whether account is empty
  isEmpty: boolean
  // Storage (if returnStorage=true)
  storage?: { [key: Hex]: Hex }
  // Any errors that occurred
  errors?: TevmGetAccountError[]
}
```

#### Example

```ts
import { tevmGetAccount } from 'tevm/actions'
import { createTevmNode } from 'tevm/node'

const node = createTevmNode()

const account = await tevmGetAccount(node, {
  address: '0x...',
  blockTag: 'latest',
  returnStorage: true
})

console.log('Balance:', account.balance)
console.log('Nonce:', account.nonce)
if (account.isContract) {
  console.log('Code:', account.deployedBytecode)
  console.log('Storage:', account.storage)
}
```

### tevmSetAccount

The `tevmSetAccount` action allows you to modify account state directly.

#### Parameters

```ts
type SetAccountParams = {
  // Required address to modify
  address: Address
  // New nonce value
  nonce?: bigint
  // New balance in wei
  balance?: bigint
  // New deployed bytecode
  deployedBytecode?: Hex
  // New storage values
  state?: { [key: Hex]: Hex }
}
```

#### Return Type

```ts
type SetAccountResult = {
  // Any errors that occurred
  errors?: TevmSetAccountError[]
}
```

#### Examples

##### 1. Setting Account Balance

```ts
await tevmSetAccount(node, {
  address: '0x...',
  balance: parseEther('100')
})
```

##### 2. Deploying Contract Code

```ts
await tevmSetAccount(node, {
  address: contractAddress,
  deployedBytecode: '0x...',
  state: {
    // Initial storage values
    '0x0000...': '0x0000...'
  }
})
```

##### 3. Modifying Multiple Properties

```ts
await tevmSetAccount(node, {
  address: '0x...',
  nonce: 5n,
  balance: parseEther('10'),
  state: {
    [slot1]: value1,
    [slot2]: value2
  }
})
```

### Best Practices

1. **Storage Management**:
   ```ts
   // Avoid fetching storage unless needed
   const account = await tevmGetAccount(node, {
     address: '0x...',
     returnStorage: false // default
   })
   ```

2. **State Consistency**:
   ```ts
   // Check account exists before modifying
   const account = await tevmGetAccount(node, { address })
   if (!account.isEmpty) {
     await tevmSetAccount(node, {
       address,
       balance: account.balance + amount
     })
   }
   ```

3. **Error Handling**:
   ```ts
   const result = await tevmSetAccount(node, {
     address: '0x...',
     balance: newBalance,
     throwOnFail: false
   })

   if (result.errors) {
     console.error('Failed to set account:', result.errors)
   }
   ```

### Related Topics

* [State Management](../core/managing-state)
* [tevmCall API](./tevm-call)
* [JSON-RPC Support](./json-rpc)


***

title: Contract Utilities
description: Helper utilities for creating and managing smart contracts, including createContract and standard contract templates.

## Contract Utilities

The [`@tevm/contract`](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract) package provides powerful utilities for working with [Ethereum smart contracts](https://ethereum.org/en/developers/docs/smart-contracts/), offering type-safe contract interactions and simplified deployment workflows.

### createContract

Creates a strongly-typed contract instance with read and write actions:

```ts
import { createContract } from 'tevm/contract'

const contract = createContract({
  // Use as const for type safety
  humanReadableAbi: [
    'function balanceOf(address) view returns (uint256)',
    'function transfer(address to, uint256 amount) returns (bool)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ] as const,
  name: 'MyToken',
})

// Type-safe read actions
const readAction = contract.read.balanceOf('0x...')

// Type-safe write actions
const writeAction = contract.write.transfer('0x...', 1000n)
```

#### Contract with Address

Add an [Ethereum address](https://ethereum.org/en/developers/docs/accounts/#account-creation) to create a fully configured contract instance:

```ts
const token = contract.withAddress('0x1234...')

// Now includes address in all actions
const balanceAction = token.read.balanceOf('0x...')
// balanceAction.to will be set to the token address
```

### Standard Contracts

The package includes pre-built contracts for common standards:

```ts
import { ERC20, ERC721 } from 'tevm/contract'

// ERC20 token with all standard methods
const token = ERC20.withAddress('0x...')

// Read token info
const nameAction = token.read.name()
const symbolAction = token.read.symbol()
const supplyAction = token.read.totalSupply()

// Transfer tokens
const transferAction = token.write.transfer('0x...', 1000n)

// ERC721 NFT contract
const nft = ERC721.withAddress('0x...')
const ownerAction = nft.read.ownerOf(1n)
```

For more information on token standards, see:
\- [ERC-20 Token Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
\- [ERC-721 NFT Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/)

### Deployless Scripts

Create self-deploying contract scripts that work with any client:

```ts
import { ERC20 } from 'tevm/contract'

// Create a script that deploys and initializes a token
const script = ERC20.script({
  bytecode: '0x...',  // Contract bytecode
  args: ['MyToken', 'MTK', 1000000n], // Constructor args
})

// Use with any compatible client
const name = await client.contract(script.read.name())
const symbol = await client.contract(script.read.symbol())
```

### Contract Types

The package exports useful types for contract development:

```ts
import type {
  Contract,
  ContractAbi,
  ContractFunctionName,
  ContractEventName,
} from 'tevm/contract'

// Use with your own contracts
type MyContract = Contract<typeof myAbi>
type MyFunctions = ContractFunctionName<typeof myAbi>
type MyEvents = ContractEventName<typeof myAbi>
```

### Best Practices

#### 1. Type Safety

Always use `as const` with [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html) to get full type inference:

```ts
const abi = [
  'function example(uint256 value) returns (bool)',
] as const

const contract = createContract({
  humanReadableAbi: abi,
  name: 'Example',
})
// contract.write.example will have proper types
```

#### 2. Error Handling

Handle contract errors appropriately:

```ts
try {
  const result = await client.contract(contract.write.transfer('0x...', 1000n))
} catch (e) {
  if (e.message.includes('insufficient balance')) {
    // Handle specific error case
  }
  throw e
}
```

#### 3. Gas Management

Consider [gas costs](https://ethereum.org/en/developers/docs/gas/) in write operations:

```ts
const tx = contract.write.complexOperation('0x...', {
  gas: 500000n,  // Set gas limit
  maxFeePerGas: 30000000000n,  // Set max fee
})
```

#### 4. Event Handling

Listen for contract [events](https://docs.soliditylang.org/en/latest/contracts.html#events):

```ts
// Create event filter
const filter = contract.events.Transfer({
  fromBlock: 'latest',
})

// Process events
client.watchEvent(filter, (event) => {
  console.log('Transfer:', {
    from: event.args.from,
    to: event.args.to,
    value: event.args.value,
  })
})
```

### Related Topics

\- [Utilities & Addresses](./utils)
\- [Custom Precompiles](../advanced/custom-precompiles)
\- [State Management](../core/managing-state)
\- [Solidity Documentation](https://docs.soliditylang.org/)
\- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/)
\- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)


## EVM Events

Tevm Node provides access to low-level EVM events through the VM's event emitter. This allows you to monitor and debug contract execution at a granular level.

### Available Events

```ts
type EVMEvent = {
  // Emitted when a new contract is created
  newContract: (data: {
    address: Address,
    code: Uint8Array
  }) => void

  // Emitted before a message (call) is processed
  beforeMessage: (data: Message) => void

  // Emitted after a message (call) is processed
  afterMessage: (data: EVMResult) => void

  // Emitted on each EVM step
  step: (data: InterpreterStep) => void
}
```

### Basic Usage

```ts
import { createTevmNode } from 'tevm/node'

const node = createTevmNode()
const vm = await node.getVm()

// Listen for EVM steps
vm.evm.events?.on('step', (step, next) => {
  console.log('EVM Step:', {
    pc: step.pc,           // Program counter
    opcode: step.opcode,   // Current opcode
    gasLeft: step.gasLeft, // Remaining gas
    stack: step.stack,     // Stack contents
    depth: step.depth,     // Call depth
  })
  next?.()
})

// Listen for contract creation
vm.evm.events?.on('newContract', (data, next) => {
  console.log('New contract deployed:', {
    address: data.address.toString(),
    codeSize: data.code.length,
  })
  next?.()
})

// Listen for message execution
vm.evm.events?.on('beforeMessage', (message, next) => {
  console.log('Executing message:', {
    to: message.to?.toString(),
    value: message.value.toString(),
    delegatecall: message.delegatecall,
  })
  next?.()
})

vm.evm.events?.on('afterMessage', (result, next) => {
  console.log('Message result:', {
    gasUsed: result.execResult.executionGasUsed.toString(),
    returnValue: result.execResult.returnValue.toString('hex'),
    error: result.execResult.exceptionError?.error,
  })
  next?.()
})
```

### Debugging Example

```ts
// Create a debug tracer
function createDebugTracer(vm) {
  const trace = {
    steps: [],
    contracts: new Set(),
    errors: [],
  }

  // Track each EVM step
  vm.evm.events?.on('step', (step, next) => {
    trace.steps.push({
      pc: step.pc,
      opcode: step.opcode.name,
      gasCost: step.opcode.fee,
      stack: step.stack.map(item => item.toString(16)),
    })
    next?.()
  })

  // Track contract creation
  vm.evm.events?.on('newContract', (data, next) => {
    trace.contracts.add(data.address.toString())
    next?.()
  })

  // Track errors
  vm.evm.events?.on('afterMessage', (result, next) => {
    if (result.execResult.exceptionError) {
      trace.errors.push({
        error: result.execResult.exceptionError.error,
        returnData: result.execResult.returnValue.toString('hex'),
      })
    }
    next?.()
  })

  return trace
}

// Use the tracer
const node = createTevmNode()
const vm = await node.getVm()
const trace = createDebugTracer(vm)

// Run some transactions...

console.log('Execution trace:', {
  stepCount: trace.steps.length,
  contracts: Array.from(trace.contracts),
  errors: trace.errors,
})
```

### Gas Profiling

```ts
// Create a gas profiler
function createGasProfiler(vm) {
  const profile = {
    opcodes: new Map(),
    totalGas: 0n,
  }

  vm.evm.events?.on('step', (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = profile.opcodes.get(opName) || {
      count: 0,
      totalGas: 0n
    }

    stats.count++
    stats.totalGas += gasCost
    profile.totalGas += gasCost
    profile.opcodes.set(opName, stats)

    next?.()
  })

  return profile
}

// Use the profiler
const node = createTevmNode()
const vm = await node.getVm()
const profile = createGasProfiler(vm)

// Run transactions...

// Get gas usage by opcode
for (const [opcode, stats] of profile.opcodes) {
  console.log(`${opcode}:`, {
    count: stats.count,
    totalGas: stats.totalGas.toString(),
    percentageOfTotal: Number(stats.totalGas * 100n / profile.totalGas),
  })
}
```

### Error Handling

```ts
vm.evm.events?.on('afterMessage', (result, next) => {
  if (result.execResult.exceptionError) {
    const error = result.execResult.exceptionError

    switch (error.error) {
      case 'out of gas':
        console.error('Transaction ran out of gas')
        break
      case 'revert':
        console.error('Transaction reverted:',
          result.execResult.returnValue.toString('hex'))
        break
      case 'invalid opcode':
        console.error('Invalid opcode encountered')
        break
      default:
        console.error('Unknown error:', error)
    }
  }
  next?.()
})
```

### Best Practices

1. **Always Call Next**
   ```ts
   vm.evm.events?.on('step', (step, next) => {
     // Process step...
     next?.() // Important: Call next to continue execution
   })
   ```

2. **Clean Up Listeners**
   ```ts
   const handler = (step, next) => {
     // Handle step...
     next?.()
   }

   vm.evm.events?.on('step', handler)

   // Later...
   vm.evm.events?.off('step', handler)
   ```

3. **Handle Errors Gracefully**
   ```ts
   vm.evm.events?.on('step', (step, next) => {
     try {
       // Process step...
     } catch (error) {
       console.error('Error processing step:', error)
     }
     next?.()
   })
   ```

### Related Topics

* [Performance Profiler](../advanced/performance-profiler)
* [Gas Estimation](../api/methods)


## JSON-RPC Support

Tevm Node provides comprehensive [JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/) support through an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible interface. This allows seamless integration with popular Ethereum libraries and tools.

### EIP-1193 Provider

The node can be extended to expose an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible request interface:

```ts
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Use standard JSON-RPC methods
const blockNum = await node.request({
  method: 'eth_blockNumber',
  params: [],
})
```

### Supported Methods

#### Core Ethereum Methods

* **Block & Chain**
  * [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) - Get current block number
  * [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) - Get block by hash
  * [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) - Get block by number
  * [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) - Get current chain ID

* **State & Account**
  * [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) - Get account balance
  * [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) - Get contract code
  * [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) - Get storage value
  * [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) - Get account nonce

* **Transaction**
  * [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) - Execute contract call
  * [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) - Estimate gas usage
  * [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction) - Send transaction
  * [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction) - Send signed transaction
  * [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) - Get transaction details
  * [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) - Get transaction receipt

* **Logs & Events**
  * [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) - Get event logs
  * [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) - Create new filter
  * [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newblockfilter) - Create block filter
  * [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) - Get filter updates
  * [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) - Get all filter logs
  * [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallfilter) - Remove filter

#### Extended Methods

Tevm also supports additional methods commonly found in development environments:

* **Debug Methods**
  * [`debug_traceTransaction`](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug#debug_tracetransaction) - Trace transaction execution
  * [`debug_dumpState`](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug#debug_dumpstate) - Dump current state

* **Anvil Methods** (For [Foundry](https://book.getfoundry.sh/reference/anvil/) compatibility)
  * `anvil_setCode` - Set contract code
  * `anvil_setBalance` - Set account balance
  * `anvil_setNonce` - Set account nonce
  * `anvil_setStorageAt` - Set storage value
  * `anvil_impersonateAccount` - Impersonate account
  * `anvil_stopImpersonatingAccount` - Stop impersonating

### Client Integration

#### Using with Viem

For more information, see the [Viem Documentation](https://viem.sh/docs/clients/custom.html).

```ts
import { createTevmNode } from 'tevm/node'
import { createPublicClient, custom } from 'viem'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

const client = createPublicClient({
  chain: mainnet,
  transport: custom(node.request),
})
```

#### Using with Ethers

For more information, see the [Ethers Documentation](https://docs.ethers.org/v6/api/providers/#Provider).

```ts
import { createTevmNode } from 'tevm/node'
import { BrowserProvider } from 'ethers'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())
const provider = new BrowserProvider(node)
```

### Error Handling

JSON-RPC errors follow the [standard format](https://www.jsonrpc.org/specification#error_object):

```ts
interface JsonRpcError {
  code: number
  message: string
  data?: unknown
}
```

Common error codes (see [Ethereum JSON-RPC Error Codes](https://eips.ethereum.org/EIPS/eip-1474#error-codes)):

* `-32700`: Parse error
* `-32600`: Invalid request
* `-32601`: Method not found
* `-32602`: Invalid params
* `-32603`: Internal error
* `-32000` to `-32099`: Server error

### Best Practices

1. **Error Handling**: Always wrap RPC calls in try-catch blocks to handle potential errors gracefully.

2. **Gas Estimation**: For transactions, use [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) before sending to ensure sufficient gas.

3. **Receipt Confirmation**: Wait for transaction receipts to confirm state changes:

```ts
const txHash = await node.request({
  method: 'eth_sendTransaction',
  params: [tx],
})

const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash],
})
```

4. **Event Filtering**: Use filters efficiently by:
   * Setting appropriate block ranges
   * Using specific [topics](https://docs.soliditylang.org/en/latest/abi-spec.html#events)
   * Cleaning up unused filters

### Related Topics

* [Using with Viem](../examples/viem)
* [Using with Ethers](../examples/ethers)
* [Managing State](../core/managing-state)
* [Receipts & Logs](../advanced/receipts-and-logs)
* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [EIP-1193: Ethereum Provider JavaScript API](https://eips.ethereum.org/EIPS/eip-1193)

### Using Tevm Actions

Tevm provides a set of high-level actions that can be imported from `tevm/actions`:

```ts
import { tevmCall, tevmMine, tevmGetAccount, tevmSetAccount } from 'tevm/actions'
import { createTevmNode } from 'tevm/node'

const node = createTevmNode()

// Call a contract
const result = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  value: 0n,
  createTransaction: true
})

// Mine pending transactions
await tevmMine(node)

// Get account state
const account = await tevmGetAccount(node, {
  address: '0x...',
  blockTag: 'latest'
})

// Set account state
await tevmSetAccount(node, {
  address: '0x...',
  balance: 100n,
  nonce: 0n,
  deployedBytecode: '0x...'
})
```

Note: By default, tevm actions require manual mining via `tevmMine()`. If you want transactions to be automatically applied, you can either:

1. Use the lower level API `vm.runCall`
2. Configure the client with `miningConfig: { type: 'auto' }`

### Optimistic Updates with Receipt Manager

For more information on transaction receipts and logs, see the [Ethereum Receipts Documentation](https://ethereum.org/en/developers/docs/transactions/transaction-receipts/).

```ts
import { createTevmNode } from 'tevm/node'
import { tevmCall, tevmMine } from 'tevm/actions'

const node = createTevmNode()
const receiptsManager = await node.getReceiptsManager()

// Submit transaction
const { txHash } = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  createTransaction: true
})

// Get optimistic receipt
const pendingReceipt = await receiptsManager.getReceiptByTxHash(txHash)

// Update UI optimistically
updateUI(pendingReceipt)

// Wait for real receipt
const realReceipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash]
})

// Eject optimistic tx if real receipt differs
if (receiptsAreDifferent(pendingReceipt, realReceipt)) {
  await receiptsManager.removeReceipt(txHash)
  updateUI(realReceipt)
}

// Advanced: Rebase on new blocks
node.on('block', async (blockNumber) => {
  // Get new block
  const block = await node.request({
    method: 'eth_getBlockByNumber',
    params: [blockNumber, true]
  })

  // Get our pending transactions
  const pendingTxs = await receiptsManager.getPendingTransactions()

  // Rebase our transactions on top of new block
  for (const tx of pendingTxs) {
    const result = await tevmCall(node, {
      ...tx,
      blockTag: 'pending'
    })

    // Update receipt
    await receiptsManager.putReceipt(tx.hash, result)
  }

  // Mine rebased transactions
  await tevmMine(node)
})
```


## MemoryClient

**MemoryClient** combines a fully in-memory Ethereum node powered by [Tevm Node](/introduction/what-is-tevm-node) with [viem](https://viem.sh/). It includes:

1. **Public actions** – All standard viem [public actions](https://viem.sh/docs/actions/public/introduction).
2. **Wallet actions** – Sign transactions, send ETH, deploy contracts, etc.
3. **Test actions** – Ganache/Hardhat-like commands (`mine`, `setBalance`, `impersonateAccount`, etc.).
4. **Tevm Node's own** advanced actions – e.g. `tevmCall`, `tevmContract`, `tevmDeploy`.

:::callout
**Power vs. Modularity**
While **MemoryClient** is the most convenient way to use Tevm, it's less tree-shakeable than the lower-level approach (`createTevmNode` + separate "actions"). For many dev/test use cases, MemoryClient's all-in-one experience is ideal.
:::

***

### 1. Installation & Getting Started

```ts
import { createMemoryClient } from "tevm/memory-client"

// A simple MemoryClient that runs in-memory with no forking
const client = createMemoryClient();

// Use any viem action, e.g. getBlockNumber
const blockNumber = await client.getBlockNumber();
console.log(blockNumber); // => 0n in a fresh chain with no blocks
```

**Fork a chain**:

```ts
import { createMemoryClient, http } from "tevm/memory-client"
import { optimism } from "tevm/chains"

const forkedClient = createMemoryClient({
  fork: {
    transport: http("https://mainnet.optimism.io")({}),
    blockTag: 17400000n,
  },
  common: optimism,
});

console.log(await forkedClient.getBlockNumber());
// => 17400000n (or the block chosen)
```

***

### 2. Interface Overview

```ts
export type MemoryClient<
  TChain extends Chain | undefined = Chain | undefined,
  TAccountOrAddress extends Account | Address | undefined = Account | Address | undefined,
> = // ... merges viem's Client with TEVM-specific methods
```

When you create a `MemoryClient`, you get:

* All **viem** APIs under your usual calls:
  * **PublicActions** (e.g., `getBlockNumber`, `estimateGas`, `simulateContract`, `createEventFilter`, etc.)
  * **WalletActions** (e.g., `sendTransaction`, `deployContract`, `signMessage`, etc.)
  * **TestActions** (e.g., `mine`, `setBalance`, `reset`, `snapshot`, etc.)
* Additional **Tevm Node** actions under a unified interface:
  * `tevmCall`, `tevmContract`, `tevmDeploy`, etc. for advanced control.

***

### 3. Example Usage

#### 3.1 Deploy & Interact with a Contract

```ts
import { createMemoryClient } from "tevm/memory-client"
import { SimpleContract } from "tevm/contract" // A precompiled minimal contract
import { privateKeyToAccount } from "viem/accounts"

// Provide an account for signing
const signerAccount = privateKeyToAccount("0x59c6...b78690d")
const memoryClient = createMemoryClient({
  account: signerAccount,
})

// Deploy the `SimpleContract` with initial value = 2
const txHash = await memoryClient.deployContract(SimpleContract.deploy(2n))

// By default, TEVM is in "manual" mining, so we call:
await memoryClient.mine({ blocks: 1 })

// Grab the receipt
const receipt = await memoryClient.getTransactionReceipt({ hash: txHash })
if (!receipt.contractAddress) throw new Error("Deployment failed")

// Now read from the contract
const contract = SimpleContract.withAddress(receipt.contractAddress)
const currentValue = await memoryClient.readContract(contract.read.get())
console.log("Current value:", currentValue) // => 2n

// Write/Update the contract
const setHash = await memoryClient.writeContract(contract.write.set(420n))
await memoryClient.mine({ blocks: 1 })

const newValue = await memoryClient.readContract(contract.read.get())
console.log("New value:", newValue) // => 420n
```

**Key Points**:

* We used standard viem wallet actions for deploying and writing.
* We used TEVM's local chain for storing these transactions in memory.
* We called `mine({ blocks: 1 })` from the test actions to confirm the block.

#### 3.2 Forking & Reading On-Chain Data

```ts
import { createMemoryClient, http } from "tevm/memory-client"
import { optimism } from "tevm/chains"
import { ERC20 } from "tevm/contract"

const memoryClient = createMemoryClient({
  fork: {
    transport: http("https://mainnet.optimism.io")({}),
    blockTag: 17400000n,
  },
  common: optimism,
})

// The contract "DAI" on Optimism
const Dai = ERC20.withAddress("0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1")

// Read balance of an address
const balance = await memoryClient.readContract(Dai.read.balanceOf("0xf0d4c12a5768d806021f80a262b4d39d26c58b8d"))
console.log(balance)
```

Because we forked from real data, `balance` now reflects the state at block 17,400,000 on Optimism.

***

### 4. Working With Pending Mempool

**Manual Mining**:
By default, transactions sit in the local mempool until you call `mine()` (or the block limit is reached, or the configured mining mode triggers). You can:

1. Send multiple writes in quick succession.
2. Inspect `await memoryClient.getTxpool()`.
3. Then call `await memoryClient.mine({ blocks: 1 })`.

**Auto Mining**:
If you'd rather each tx be instantly mined, set:

```ts
const autoMiningClient = createMemoryClient({
  miningConfig: { type: 'auto' },
})
```

Now every "write" transaction is immediately confirmed.

***

### 5. Using Test & Debug Actions

MemoryClient includes [test actions](https://viem.sh/docs/actions/test/introduction) by default:

```ts
// Increase the chain's time 1 hour
await memoryClient.increaseTime({ seconds: 3600 })

// Create a snapshot
const snap = await memoryClient.snapshot()

// Revert to that snapshot
await memoryClient.revert({ id: snap })
```

These are especially useful in dev/test scenarios for controlling block times, manipulating states, or resetting the chain.

***

### 6. Low-Level TEVM Actions

Beyond viem's standard set, you can also do **Tevm Node** actions:

#### tevmCall

```ts
const result = await memoryClient.tevmCall({
  from: "0xf00...",
  to: "0x1234...",
  value: 69n,
  data: "0x...",
  skipBalance: true,
  skipNonce: true,
})
// This simulates a transaction in the local EVM but doesn't finalize it until we mine or confirm it.
```

#### tevmContract

Run a contract operation in a Tevm-specific manner:

```ts
import { ERC20 } from "tevm/contract"

const result = await memoryClient.tevmContract({
  ...ERC20.read.balanceOf("0xf0d4c12a..."),
  to: "0xda1..."
})
console.log(result.data) // => decoded result
console.log(result.logs) // => logs from the call
```

#### tevmDeploy

Deploy a contract purely using TEVM logic:

```ts
import { SimpleContract } from "tevm/contract"

const deployResult = await memoryClient.tevmDeploy(SimpleContract.deploy(2n));
await memoryClient.mine();

console.log(deployResult.createdAddress);
```

***

### 7. Using MemoryClient as an HTTP RPC

MemoryClient itself is an EIP-1193 provider, so:

* You can pass `memoryClient.request` to any library expecting an EIP-1193 transport (e.g., `createPublicClient({ transport: custom(memoryClient.request) })`).
* Or stand up an RPC server with `tevm/server`:

```ts
import { createServer } from "tevm/server"

const server = createServer({
  request: memoryClient.request,
});
server.listen(8545, () => console.log("Serving TEVM at localhost:8545"));
```

Now external tools (Remix, Hardhat, Foundry) can treat it like "anvil/hardhat" locally.

***

### 8. Persistence (Experimental)

You can persist your MemoryClient state across sessions by providing a `persister`. For example, storing all contract states in `localStorage`:

```ts
import { createMemoryClient, createSyncPersister } from 'tevm/memory-client'

const clientWithPersistence = createMemoryClient({
  persister: createSyncPersister({ storage: localStorage }),
});

// On reload, the client's state (accounts, mempool, etc.) is restored from localStorage.
```

This feature is still considered **experimental**.

***

### 9. Conclusion & Next Steps

**MemoryClient** is a straightforward, "batteries-included" approach for local dev and test. It folds together viem's robust actions with Tevm Node's flexible, in-memory EVM execution. If you need more granular or tree-shakeable control, check out:

* [Tevm Node & tevm/actions](/introduction/what-is-tevm-node)
* [Advanced EVM Customization](/advanced/custom-precompiles)

**Happy testing & building!**


import { Callout } from 'vocs/components'

## Tevm Node Methods

Tevm Node provides a comprehensive API for interacting with the Ethereum Virtual Machine. This reference covers all core methods and capabilities.

### Core Methods

#### Initialization

```ts
import { createTevmNode, http } from 'tevm/node'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')
  }
})

await node.ready() // Wait for initialization
```

#### Virtual Machine Access

```ts
const vm = await node.getVm()

// Execute a transaction
const result = await vm.runTx({
  tx: {
    to: '0x1234...',
    value: 1000000000000000000n, // 1 ETH
    data: '0x...',
  }
})
```

#### Transaction Pool

```ts
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### Receipts & Logs

```ts
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

### State Management

#### Account Impersonation

```ts
// Impersonate an account (fork mode only)
node.setImpersonatedAccount('0x1234...')

// Get current impersonated account
const impersonated = node.getImpersonatedAccount()

// Stop impersonating
node.setImpersonatedAccount(undefined)
```

#### Event Filtering

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

### Node Properties

#### Status

The `status` property indicates the current state of the node:

```ts
console.log(node.status) // One of: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
```

#### Mode

The `mode` property indicates whether the node is running in fork or normal mode:

```ts
console.log(node.mode) // 'fork' or 'normal'
```

#### Logger

Built-in logging capabilities:

```ts
node.logger.debug('Detailed debugging information')
node.logger.info('General information')
node.logger.warn('Warning messages')
node.logger.error('Error information')
```

### Extensibility

#### Adding Custom Functionality

```ts
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### State Copying

```ts
// Create a deep copy with independent state
const nodeCopy = await node.deepCopy()

// Fork from another node
const forkedNode = createTevmNode({
  fork: { transport: node }
})
```

### JSON-RPC Support

Tevm Node implements standard Ethereum JSON-RPC methods through its EIP-1193 interface:

#### Using EIP-1193

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard JSON-RPC calls
const blockNumber = await node.request({
  method: 'eth_blockNumber',
  params: []
})
```

#### Using Actions

```ts
import { ethActions } from 'tevm/decorators'

const node = createTevmNode().extend(ethActions())

// Using action methods
const blockNumber = await node.eth.getBlockNumber()
const balance = await node.eth.getBalance('0x1234...')
```

#### Supported Methods

* **State Access**
  * \`


import { Callout } from 'vocs/components'

## tevmCall API

The `tevmCall` action is one of the most important APIs in Tevm, covering 90% of use cases along with `tevmMine`. It provides a powerful interface for executing EVM calls with extensive configuration options.

### Basic Usage

```ts
import { tevmCall } from 'tevm/actions'
import { createTevmNode } from 'tevm/node'

const node = createTevmNode()

const result = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  value: 0n
})
```

### Parameters

The `CallParams` type includes:

```ts
type CallParams = {
  // Required for most calls (except contract deployment)
  to?: Address
  // Input data for the call
  data?: Hex
  // Value in wei to send
  value?: bigint
  // Gas limit for the call
  gas?: bigint
  // Block tag to execute against
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to create a transaction
  createTransaction?: 'on-success' | 'always' | 'never' | boolean
  // Whether to skip balance checks
  skipBalance?: boolean
  // Whether to create an access list
  createAccessList?: boolean
  // Whether to create a debug trace
  createTrace?: boolean
  // From address (defaults to first account)
  from?: Address
  // Gas price settings
  maxFeePerGas?: bigint
  maxPriorityFeePerGas?: bigint
  // State overrides
  stateOverrideSet?: StateOverrideSet
  // Block overrides
  blockOverrideSet?: BlockOverrideSet
}
```

### Return Type

The `CallResult` includes:

```ts
type CallResult = {
  // Return data from the call
  rawData: Hex
  // Gas used by the EVM
  executionGasUsed: bigint
  // Total gas including intrinsic costs
  totalGasSpent?: bigint
  // Transaction hash if created
  txHash?: Hex
  // Logs emitted
  logs?: Log[]
  // Created contract address
  createdAddress?: Address
  // Access list if requested
  accessList?: Record<Address, Set<Hex>>
  // Debug trace if requested
  trace?: DebugTraceCallResult
  // Any errors that occurred
  errors?: TevmCallError[]
}
```

### Examples

#### 1. Simple Contract Call

```ts
const result = await tevmCall(node, {
  to: contractAddress,
  data: encodeFunctionData({
    abi: myABI,
    functionName: 'getValue',
    args: []
  })
})

const value = decodeFunctionResult({
  abi: myABI,
  functionName: 'getValue',
  data: result.rawData
})
```

#### 2. Contract Deployment

```ts
const result = await tevmCall(node, {
  data: encodeDeploy({
    abi: myABI,
    bytecode: contractBytecode,
    args: [arg1, arg2]
  }),
  createTransaction: true
})

console.log('Contract deployed at:', result.createdAddress)
```

#### 3. State Override

```ts
const result = await tevmCall(node, {
  to: contractAddress,
  data: callData,
  stateOverrideSet: {
    [accountAddress]: {
      balance: '0x1000',
      nonce: '0x2',
      code: '0x...',
      state: {
        '0x...': '0x...'
      }
    }
  }
})
```

#### 4. Debug Trace

```ts
const result = await tevmCall(node, {
  to: contractAddress,
  data: callData,
  createTrace: true
})

// Analyze the execution trace
result.trace?.structLogs.forEach(log => {
  console.log(log.op, log.stack, log.memory)
})
```

### Higher Level APIs

While `tevmCall` is powerful, Tevm provides higher-level convenience methods:

#### tevmContract

```ts
import { tevmContract } from 'tevm/actions'

const result = await tevmContract(node, {
  abi: myABI,
  address: contractAddress,
  functionName: 'getValue',
  args: []
})
```

#### tevmDeploy

```ts
import { tevmDeploy } from 'tevm/actions'

const result = await tevmDeploy(node, {
  abi: myABI,
  bytecode: contractBytecode,
  args: [arg1, arg2]
})
```

### Related Topics

* [Mining Configuration](#TODO)
* [State Management](../core/managing-state)
* [JSON-RPC Support](./json-rpc)


***

title: Utilities & Addresses
description: Core utility functions such as createAddress, createContractAddress, and related classes & errors.

## Utilities & Addresses

Tevm exports a set of lightweight utility functions and classes. Many of these build upon lower-level packages like [`@tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) and [`viem`](https://viem.sh) while standardizing usage for Tevm Node. Below are the most commonly used.

### createAddress

Creates an [Ethereum address](https://ethereum.org/en/developers/docs/accounts/#account-creation) from various input formats:

```ts
import { createAddress } from 'tevm/address'

// Creates a TEVM-style Address object from various input forms
let addr = createAddress(`0x${"00".repeat(20)}`)
// from a hex string
addr = createAddress(420n)
// from a bigint
addr = createAddress(new Uint8Array(20))
// from a 20-byte array
```

#### Signature

```ts
declare function createAddress(
  address: number | bigint | string | Uint8Array | EthjsAddress
): Address
```

#### Behavior & Notes

\- Accepts various input types: [`0x`-prefixed hex strings](https://ethereum.org/en/developers/docs/data-structures-and-encoding/hex/), unprefixed hex, numbers, bigints, `Uint8Array`s, or `EthjsAddress`.
\- Throws `InvalidAddressError` if it can't parse a valid 20-byte address from the input.

### Address Class

A thin wrapper around [`EthjsAddress`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/util) offering a simple, consistent shape for Tevm Node. Created by `createAddress` or by forging your own:

```ts
import { Address } from 'tevm/address'

const a = new Address(Uint8Array.from([ /* 20 bytes */ ]))
console.log(a.bytes)  // a raw 20-byte address
console.log(a.toString()) // 0x....
```

### createContractAddress

Creates a contract address following [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014):

```ts
import { createContractAddress } from 'tevm/address'

// from an existing address + nonce, produce the CREATE address
const from = createAddress("0x1111...1111")
const nonce = 1n
const contractAddr = createContractAddress(from, nonce)
```

#### Usage

1\. Follows standard Ethereum's [`keccak256(rlp([senderAddress, nonce]))[-20..]`](https://ethereum.org/en/developers/docs/smart-contracts/deploying/#how-to-deploy-a-smart-contract).
2\. Ideal for simulating `CREATE` addresses in test or dev flows.

#### Error Handling

\- Throws `InvalidAddressError` if the `from` address is invalid.

### Common Errors

\- **InvalidAddressError**
Thrown when a string/bytes input fails to parse as a valid 20-byte address.

\- **UnreachableCodeError**
Thrown internally if a code path was unexpectedly reached. Generally wrapped into a more descriptive error.

### Other Handy Utilities

Some additional lower-level utility re-exports from [`@tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) or [`viem`](https://viem.sh):

\- `hexToBytes(hex: string): Uint8Array`
Convert a hex string to raw bytes (with optional size checks).
\- `keccak256(data: Uint8Array | HexString, 'bytes' | 'hex')`
A standard [keccak256](https://ethereum.org/en/developers/docs/smart-contracts/security/#keccak256-and-sha-3) hasher.
\- `encodeFunctionData(...)`, `toRlp(...)`, etc.
Various encoding helpers used by Tevm Node internally.

\> **Tip:** If you are building higher-level code in the browser or Node, you may prefer [`viem`](https://viem.sh)'s standardized utilities for bytes conversions, hashing, and ABIs. Tevm re-exports many of these for convenience.


***

title: VM & Submodules
description: Overview of the internal EVM, blockchain, state, receipts, and more

## VM & Submodules

[Tevm Node](https://github.com/evmts/tevm-monorepo) is built on a modular architecture that separates concerns into distinct submodules. This guide covers the internal components and their APIs.

### Overview

The main submodules are:

1\. **EVM (Ethereum Virtual Machine)** - Core [execution engine](https://ethereum.org/en/developers/docs/evm/)
2\. **Blockchain** - [Block and chain state](https://ethereum.org/en/developers/docs/blocks/) management
3\. **StateManager** - [Account and storage state](https://ethereum.org/en/developers/docs/accounts/) management
4\. **TxPool** - [Transaction mempool](https://ethereum.org/en/developers/docs/transactions/)
5\. **ReceiptsManager** - [Transaction receipts and logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)

### EVM Module

The EVM module handles bytecode execution and state transitions. It is based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm).

```ts
const vm = await node.getVm()
const evm = await vm.evm

// Direct EVM execution
const result = await evm.runCall({
  to: '0x...',
  data: '0x...',
  value: 0n,
  caller: '0x...',
})

// Full transaction execution (recommended)
const txResult = await vm.runTx({
  tx: transaction,
  block: block,
})
```

#### Key Features

\- **State Management**: Handles [account state](https://ethereum.org/en/developers/docs/accounts/), storage, and code execution
\- **Gas Metering**: Tracks [gas consumption](https://ethereum.org/en/developers/docs/gas/) during execution
\- **Precompiles**: [Built-in contract implementations](https://www.evm.codes/precompiled)
\- **EIP Support**: Implements various [Ethereum Improvement Proposals](https://eips.ethereum.org/)

#### Common Operations

```ts
// Check execution result
if (result.execResult.exceptionError) {
  console.error('Execution failed:', result.execResult.exceptionError)
} else {
  console.log('Return value:', result.execResult.returnValue)
  console.log('Gas used:', result.execResult.executionGasUsed)
}

// Access logs from execution
for (const log of result.execResult.logs) {
  console.log('Event:', {
    address: log.address,
    topics: log.topics,
    data: log.data
  })
}
```

### Blockchain Module

The blockchain module manages blocks and chain state. It is based on [`@ethereumjs/blockchain`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/blockchain).

```ts
const chain = (await node.getVm()).blockchain

// Get block by number or hash
const block = await chain.getBlock('latest')
const blockByHash = await chain.getBlock(blockHash)

// Add new block
await chain.putBlock(block)

// Delete block
await chain.delBlock(blockHash)

// Get block details
console.log({
  number: block.header.number,
  hash: block.hash(),
  parentHash: block.header.parentHash,
  stateRoot: block.header.stateRoot
})
```

#### Fork Support

```ts
// When forking, blocks are fetched from the parent chain
const forkedBlock = await chain.getBlock(blockNumber)

// Local blocks override forked blocks
await chain.putBlock(localBlock)
```

### StateManager

The StateManager handles account state and storage. It is based on [`@ethereumjs/statemanager`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/statemanager).

```ts
const state = (await node.getVm()).stateManager

// Account operations
const account = await state.getAccount(address)
await state.putAccount(address, account)

// Contract operations
await state.putContractCode(address, bytecode)
const code = await state.getContractCode(address)

// Storage operations
await state.putContractStorage(address, key, value)
const value = await state.getContractStorage(address, key)

// State snapshots
const snapshot = await state.dumpCanonicalGenesis()
await state.commit()
await state.revert()
```

#### Working with Accounts

```ts
// Create or update account
const account = {
  nonce: 1n,
  balance: 100n,
  storageRoot: EMPTY_ROOT,
  codeHash: EMPTY_HASH
}
await state.putAccount(address, account)

// Delete account
await state.deleteAccount(address)
```

### Transaction Pool

The TxPool manages pending transactions. It is based on [`@ethereumjs/tx-pool`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx-pool).

```ts
const pool = await node.getTxPool()

// Add transaction
await pool.add(transaction)

// Get pending transactions
const pending = await pool.getPendingTransactions()

// Remove transaction
await pool.removeByHash(txHash)

// Get transactions ordered by price
const ordered = await pool.txsByPriceAndNonce({
  baseFee: 10n
})
```

#### Transaction Validation

```ts
// Validate transaction before adding
try {
  await pool.validateTx(transaction)
  await pool.add(transaction)
} catch (error) {
  console.error('Invalid transaction:', error)
}
```

### ReceiptsManager

The ReceiptsManager handles [transaction receipts](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) and event logs.

```ts
const receipts = await node.getReceiptsManager()

// Get receipts for block
const blockReceipts = await receipts.getReceipts(blockHash)

// Get receipt by transaction hash
const txReceipt = await receipts.getReceiptByTxHash(txHash)

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: contractAddress,
  topics: [eventSignature]
})
```

#### Working with Logs

```ts
// Process event logs
for (const log of logs) {
  console.log({
    address: log.address,
    topics: log.topics,
    data: log.data,
    blockNumber: log.blockNumber,
    transactionHash: log.transactionHash,
    logIndex: log.logIndex
  })
}
```

### Best Practices

1\. **Use High-Level APIs**: Prefer `vm.runTx()` over direct EVM execution for full transaction support.

2\. **State Management**:
\- Use checkpoints for atomic operations
\- Clean up state after tests
\- Handle reverts properly

3\. **Gas Optimization**:
\- [Estimate gas](https://ethereum.org/en/developers/docs/gas/#why-are-gas-fees-necessary) before execution
\- Monitor gas usage in hot paths
\- Use appropriate gas limits

4\. **Error Handling**:
\- Check execution results
\- Handle exceptions gracefully
\- Validate inputs

### Related Topics

\- [JSON-RPC Support](./json-rpc)
\- [Managing State](../core/managing-state)
\- [Transaction Pool](../advanced/txpool)
\- [Receipts & Logs](../advanced/receipts-and-logs)
\- [EVM Opcodes Reference](https://www.evm.codes/)
\- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
\- [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)

**Up Next**\
\- [JSON-RPC Guide](./json-rpc)
\- [Advanced Usage](../advanced/txpool)


## Custom Precompiles

[Tevm Node](https://github.com/evmts/tevm-monorepo) allows you to extend the [EVM](https://ethereum.org/en/developers/docs/evm/) with custom [precompiled contracts](https://ethereum.org/en/developers/docs/evm/precompiles/) written in JavaScript. These precompiles can provide native functionality at specific addresses, similar to [Ethereum's built-in precompiles](https://www.evm.codes/precompiled).

### Using @tevm/precompiles

The `@tevm/precompiles` package provides utilities for creating type-safe precompiles from contract [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html):

```ts
import { defineCall } from 'tevm/precompiles'
import { SimpleContract } from 'tevm/contract'

// Create a stateful precompile
let value = 0n

const call = defineCall(SimpleContract.abi, {
  // Read method
  get: async () => ({
    returnValue: value,
    executionGasUsed: 100n
  }),

  // Write method with events
  set: async ({ args }) => {
    const [newValue] = args
    value = newValue
    return {
      returnValue: undefined,
      executionGasUsed: 200n,
      logs: [{
        eventName: 'ValueSet',
        address: '0x1234...',
        args: [value, newValue],
      }]
    }
  },
})

// Use with Tevm Node
const precompile = definePrecompile({
  address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2',
  call: async (input) => call(input),
})
```

### Basic Usage

```ts
import { createTevmNode, definePrecompile } from 'tevm/node'

const myPrecompile = definePrecompile({
  address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2',
  call: async ({ data, gasLimit }) => {
    // Process input data
    const processedData = processData(data)

    return {
      returnValue: new Uint8Array([...processedData]),
      executionGasUsed: 200n,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile],
})
```

### Precompile Interface

```ts
interface Precompile {
  address: string // [Address format](https://ethereum.org/en/developers/docs/accounts/#account-creation)
  call: (params: PrecompileInput) => Promise<PrecompileOutput>
}

interface PrecompileInput {
  data: Uint8Array
  gasLimit: bigint
  address: string
  caller: string
  value: bigint
  // Additional context
  block?: Block
  message?: Message
}

interface PrecompileOutput {
  returnValue: Uint8Array
  executionGasUsed: bigint
}
```

### Example Implementations

#### 1. String Manipulation Precompile

```ts
const stringPrecompile = definePrecompile({
  address: '0x0000000000000000000000000000000000000123',
  call: async ({ data }) => {
    // Decode function selector and parameters
    const selector = data.slice(0, 4)
    const params = data.slice(4)

    if (selector.equals(toBytes('toUpper(string)'))) {
      const str = decodeString(params)
      const result = str.toUpperCase()
      return {
        returnValue: encodeString(result),
        executionGasUsed: BigInt(str.length * 10), // Gas based on input size
      }
    }

    throw new Error('Unknown function selector')
  },
})
```

#### 2. Cryptographic Precompile

```ts
import { keccak256 } from 'tevm/utils'

const cryptoPrecompile = definePrecompile({
  address: '0x0000000000000000000000000000000000000456',
  call: async ({ data }) => {
    const selector = data.slice(0, 4)
    const input = data.slice(4)

    switch (selector.toString('hex')) {
      case 'hash':
        const hash = keccak256(input)
        return {
          returnValue: hash,
          executionGasUsed: 100n + BigInt(input.length),
        }
      // Add more crypto functions...
    }
  },
})
```

#### 3. External API Precompile

```ts
const apiPrecompile = definePrecompile({
  address: '0x0000000000000000000000000000000000000789',
  call: async ({ data }) => {
    const { method, url, params } = decodeApiCall(data)

    try {
      const response = await fetch(url, {
        method,
        body: JSON.stringify(params),
      })

      const result = await response.json()
      return {
        returnValue: encodeResult(result),
        executionGasUsed: 1000n, // Fixed gas cost for API calls
      }
    } catch (error) {
      throw new Error(`API call failed: ${error.message}`)
    }
  },
})
```

#### 4. Stateful Precompile with Events

```ts
import { defineCall } from 'tevm/precompiles'

// Define contract ABI
const abi = [
  'function getValue() view returns (uint256)',
  'function setValue(uint256)',
  'event ValueChanged(uint256 oldValue, uint256 newValue)',
] as const

// Create stateful precompile
let storedValue = 0n

const statefulCall = defineCall(abi, {
  getValue: async () => ({
    returnValue: storedValue,
    executionGasUsed: 100n,
  }),

  setValue: async ({ args }) => {
    const oldValue = storedValue
    storedValue = args[0]

    return {
      returnValue: undefined,
      executionGasUsed: 200n,
      logs: [{
        eventName: 'ValueChanged',
        address: '0x1234...',
        args: [oldValue, storedValue],
      }],
    }
  },
})

const precompile = definePrecompile({
  address: '0x0000000000000000000000000000000000000999',
  call: statefulCall,
})
```

### Solidity Interface

Create a [Solidity interface](https://docs.soliditylang.org/en/latest/contracts.html#interfaces) to interact with your precompile:

```solidity
interface IStringPrecompile {
    function toUpper(string calldata input) external view returns (string memory);
}

contract MyContract {
    IStringPrecompile constant strUtils = IStringPrecompile(0x0000000000000000000000000000000000000123);

    function processString(string calldata input) external view returns (string memory) {
        return strUtils.toUpper(input);
    }
}
```

### Gas Considerations

For more information on gas costs, see the [EVM Gas and Fees](https://ethereum.org/en/developers/docs/gas/) documentation.

1. **Static Gas Cost**:
   ```ts
   const precompile = definePrecompile({
     address: '0x123...',
     call: async () => ({
       returnValue: new Uint8Array([1]),
       executionGasUsed: 100n, // Fixed cost
     }),
   })
   ```

2. **Dynamic Gas Cost**:
   ```ts
   const precompile = definePrecompile({
     address: '0x456...',
     call: async ({ data }) => ({
       returnValue: processData(data),
       executionGasUsed: BigInt(data.length * 10), // Cost based on input
     }),
   })
   ```

3. **Operation-based Gas**:
   ```ts
   const precompile = definePrecompile({
     address: '0x789...',
     call: async ({ data }) => {
       let gas = 0n

       // Track gas for each operation
       for (const op of operations) {
         gas += calculateOpGas(op)
       }

       return {
         returnValue: result,
         executionGasUsed: gas,
       }
     },
   })
   ```

### Best Practices

1. **Input Validation**:
   Follow [best practices for input validation](https://consensys.github.io/smart-contract-best-practices/development-recommendations/precautions/validation/)

2. **Error Handling with defineCall**:

```ts
const call = defineCall(abi, {
  method: async ({ args }) => {
    try {
      const result = await processArgs(args)
      return {
        returnValue: result,
        executionGasUsed: 100n,
      }
    } catch (error) {
      // Error will be properly formatted for EVM
      throw new Error(`Custom error: ${error.message}`)
    }
  },
})
```

3. **Resource Management**:
   ```ts
   // Maintain connection pool
   const connections = new Map()

   const precompile = definePrecompile({
     address: '0x789...',
     call: async ({ data }) => {
       let conn = connections.get(data.toString())
       if (!conn) {
         conn = await createConnection()
         connections.set(data.toString(), conn)
       }

       try {
         return await useConnection(conn)
       } finally {
         // Clean up if needed
         await conn.release()
       }
     },
   })
   ```

4. **Security Considerations**:
   * Validate all inputs thoroughly
   * Avoid arbitrary code execution
   * Implement proper access controls
   * Consider gas costs carefully
   * Handle sensitive data appropriately

### Type Safety with defineCall

The `defineCall` utility provides full [type safety](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html) for your precompiles:

```ts
import { defineCall } from 'tevm/precompiles'

// ABI with types
const abi = [
  'function add(uint256 a, uint256 b) returns (uint256)',
  'function sub(uint256 a, uint256 b) returns (uint256)',
] as const

// Type-safe implementation
const call = defineCall(abi, {
  // Types for args and return value are inferred
  add: async ({ args: [a, b] }) => ({
    returnValue: a + b,
    executionGasUsed: 100n,
  }),

  sub: async ({ args: [a, b] }) => ({
    returnValue: a - b,
    executionGasUsed: 100n,
  }),
})
```

### Related Topics

* [Contract Utilities](../api/contracts)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)
* [EVM Opcodes Reference](https://www.evm.codes/)
* [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
* [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)


## Performance & Profiler

Tevm Node includes a built-in performance profiler that helps you analyze EVM execution, identify bottlenecks, and optimize your smart contracts.

### Enabling the Profiler

Enable profiling when creating your node:

```ts
import { createTevmNode } from 'tevm/node'

const node = createTevmNode({
  profiler: {
    enabled: true,
    // Optional: Configure profiling options
    includeOpcodes: true,
    includePrecompiles: true,
  },
})
```

### Collecting Performance Data

```ts
const vm = await node.getVm()

// Execute some transactions
await vm.runTx({ /* ... */ })

// Get performance logs
const logs = vm.evm.getPerformanceLogs()

// Clear logs when done
vm.evm.clearPerformanceLogs()
```

### Log Types

The profiler collects various types of performance data:

```ts
interface PerformanceLog {
  type: 'opcode' | 'precompile' | 'call' | 'create'
  startTime: number
  endTime: number
  executionTime: number
  gasUsed?: bigint
  // Additional data based on type
}

interface OpcodeLog extends PerformanceLog {
  type: 'opcode'
  opcode: string
  pc: number
}

interface PrecompileLog extends PerformanceLog {
  type: 'precompile'
  address: string
  name: string
}
```

### Analyzing Performance

#### 1. Opcode Analysis

```ts
// Group by opcode
const opcodeStats = logs
  .filter(log => log.type === 'opcode')
  .reduce((acc, log) => {
    const key = log.opcode
    acc[key] = acc[key] || { count: 0, totalTime: 0, totalGas: 0n }
    acc[key].count++
    acc[key].totalTime += log.executionTime
    acc[key].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Find expensive operations
const expensiveOps = Object.entries(opcodeStats)
  .sort(([, a], [, b]) => b.totalTime - a.totalTime)
  .slice(0, 10)

console.log('Most expensive operations:', expensiveOps)
```

#### 2. Call Tree Analysis

```ts
// Analyze call depth and patterns
const callTree = logs
  .filter(log => log.type === 'call')
  .map(log => ({
    from: log.from,
    to: log.to,
    value: log.value,
    executionTime: log.executionTime,
    gasUsed: log.gasUsed,
  }))

console.log('Call tree:', callTree)
```

#### 3. Gas Usage Patterns

```ts
// Track gas usage over time
const gasTimeline = logs
  .filter(log => log.gasUsed !== undefined)
  .map(log => ({
    timestamp: log.startTime,
    gasUsed: log.gasUsed,
    type: log.type,
  }))

// Calculate gas efficiency
const gasEfficiency = gasTimeline.reduce((acc, log) => {
  acc.totalGas += log.gasUsed ?? 0n
  acc.totalTime += log.executionTime
  return acc
}, { totalGas: 0n, totalTime: 0 })
```

### Use Cases

#### 1. Contract Optimization

```ts
// Deploy and profile contract
const vm = await node.getVm()
await vm.runTx({ tx: deployTx })

// Clear previous logs
vm.evm.clearPerformanceLogs()

// Profile specific function
await vm.runTx({ tx: functionCallTx })
const logs = vm.evm.getPerformanceLogs()

// Analyze performance
const functionProfile = analyzeLogs(logs)
console.log('Function performance:', {
  totalTime: functionProfile.executionTime,
  gasUsed: functionProfile.gasUsed,
  hotspots: functionProfile.hotspots,
})
```

#### 2. Comparative Analysis

```ts
async function compareImplementations(implementations: string[]) {
  const results = []
  const vm = await node.getVm()

  for (const impl of implementations) {
    vm.evm.clearPerformanceLogs()
    await vm.runTx({ tx: createCallTx(impl) })
    const logs = vm.evm.getPerformanceLogs()
    results.push(analyzePerformance(logs))
  }

  return compareResults(results)
}
```

#### 3. Gas Optimization

```ts
// Track gas usage by contract
const contractGasUsage = logs
  .filter(log => log.type === 'call')
  .reduce((acc, log) => {
    const contract = log.to
    acc[contract] = acc[contract] || { calls: 0, totalGas: 0n }
    acc[contract].calls++
    acc[contract].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Identify gas-intensive contracts
const gasHotspots = Object.entries(contractGasUsage)
  .sort(([, a], [, b]) => Number(b.totalGas - a.totalGas))
```

### Best Practices

1. **Targeted Profiling**:
   ```ts
   // Clear logs before specific operations
   vm.evm.clearPerformanceLogs()
   // Run the operation you want to profile
   await vm.runTx({ /* ... */ })
   // Analyze just that operation
   const logs = vm.evm.getPerformanceLogs()
   ```

2. **Memory Management**:
   * Clear logs periodically
   * Profile specific operations rather than entire sessions
   * Export and analyze large datasets externally

3. **Comparative Analysis**:
   ```ts
   // Compare before/after optimization
   const beforeLogs = await profileOperation(originalCode)
   const afterLogs = await profileOperation(optimizedCode)
   const improvement = compareProfiles(beforeLogs, afterLogs)
   ```

4. **Production Considerations**:
   * Disable profiler in production
   * Use sampling for long-running operations
   * Consider the overhead of profiling itself

### Related Topics

* [VM & Submodules](../api/vm-and-submodules)
* [Gas Estimation](../api/methods)
* [Transaction Pool](./txpool)


## Receipts & Logs

Tevm Node provides robust support for managing transaction receipts and event logs through the ReceiptsManager module and filter system.

### Receipt Management

The ReceiptsManager maintains an index of all transaction receipts and their associated logs.

```ts
const manager = await node.getReceiptsManager()

// Get receipts for a block
const receipts = await manager.getReceipts(blockHash)

// Get receipt for specific transaction
const receipt = await manager.getReceiptByTxHash(txHash)
```

#### Receipt Types

Tevm supports different receipt types based on the Ethereum hardfork:

```ts
interface PreByzantiumReceipt {
  stateRoot: Uint8Array
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface PostByzantiumReceipt {
  status: number
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface EIP4844Receipt extends PostByzantiumReceipt {
  blobGasUsed: bigint
  blobGasPrice: bigint
}
```

### Event Logs

#### Querying Logs

The ReceiptsManager provides flexible log querying:

```ts
// Query logs with filters
const logs = await manager.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: contractAddress,
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
    null, // Any from address
    '0x000000000000000000000000' + address.slice(2), // Specific to address
  ]
})

// Process logs
for (const log of logs) {
  console.log({
    address: log.address,
    topics: log.topics,
    data: log.data,
    blockNumber: log.blockNumber,
    transactionHash: log.transactionHash,
    logIndex: log.logIndex
  })
}
```

#### Log Filters

Tevm implements the Ethereum filter API for real-time log tracking:

```ts
// Create new filter
const filterId = await node.request({
  method: 'eth_newFilter',
  params: [{
    fromBlock: 'latest',
    address: contractAddress,
    topics: [eventSignature]
  }]
})

// Get filter changes
const changes = await node.request({
  method: 'eth_getFilterChanges',
  params: [filterId]
})

// Get all filter logs
const allLogs = await node.request({
  method: 'eth_getFilterLogs',
  params: [filterId]
})

// Remove filter when done
await node.request({
  method: 'eth_uninstallFilter',
  params: [filterId]
})
```

#### Filter Management

The node maintains filters internally:

```ts
// Get all active filters
const filters = node.getFilters()

// Remove specific filter
node.removeFilter(filterId)

// Add new filter
node.setFilter({
  id: filterId,
  fromBlock: 'latest',
  toBlock: 'latest',
  address: contractAddress,
  topics: [eventSignature]
})
```

### Performance Considerations

The ReceiptsManager includes built-in limits to prevent excessive resource usage:

```ts
// Log query limits
const GET_LOGS_LIMIT = 10000 // Maximum number of logs
const GET_LOGS_LIMIT_MEGABYTES = 150 // Maximum response size
const GET_LOGS_BLOCK_RANGE_LIMIT = 2500 // Maximum block range
```

#### Best Practices

1. **Efficient Log Queries**:
   * Use specific address and topic filters
   * Limit block ranges for large queries
   * Clean up unused filters

2. **Receipt Storage**:
   * Receipts are stored by block hash
   * Transaction hash indexes are maintained within limits
   * Old transaction indexes are automatically pruned

3. **Error Handling**:
   ```ts
   try {
     const logs = await manager.getLogs({
       fromBlock,
       toBlock,
       address,
       topics
     })
   } catch (error) {
     if (error.message.includes('block range too large')) {
       // Handle range error
     }
     // Handle other errors
   }
   ```

4. **Memory Management**:
   * Monitor filter count
   * Remove unused filters
   * Use pagination for large log queries

### Working with Contract Events

Example of tracking ERC20 Transfer events:

```ts
const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'

// Get all transfers to/from an address
const logs = await manager.getLogs({
  address: tokenAddress,
  topics: [
    transferTopic,
    null,
    '0x000000000000000000000000' + address.slice(2)
  ],
  fromBlock: startBlock,
  toBlock: 'latest'
})

// Parse transfer events
for (const log of logs) {
  const [from, to, value] = ethers.AbiCoder.defaultAbiCoder().decode(
    ['address', 'address', 'uint256'],
    log.data
  )
  console.log(`Transfer: ${from} -> ${to}: ${value}`)
}
```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Transaction Pool](./txpool)


## Transaction Pool

The Transaction Pool (TxPool) in Tevm Node manages pending transactions that haven't been included in a block yet. It provides functionality for adding, removing, and querying transactions.

### Overview

The TxPool serves several purposes:

* Managing pending transactions
* Handling transaction ordering by gas price
* Supporting the `pending` block tag in JSON-RPC calls
* Validating transactions before inclusion

### Basic Usage

```ts
const pool = await node.getTxPool()

// Add transaction to pool
await pool.add(transaction)

// Get all pending transactions
const pending = await pool.getPendingTransactions()

// Remove transaction
await pool.removeByHash(txHash)
```

### Transaction Validation

Before adding transactions to the pool, they undergo validation:

```ts
try {
  // Validate transaction
  await pool.validateTx(transaction)
  
  // Add to pool if valid
  await pool.add(transaction)
} catch (error) {
  if (error.message.includes('nonce too low')) {
    // Handle nonce error
  } else if (error.message.includes('insufficient funds')) {
    // Handle balance error
  }
  // Handle other validation errors
}
```

#### Validation Checks

The TxPool performs several checks:

1. **Nonce Validation**: Ensures transaction nonce matches account nonce
2. **Balance Check**: Verifies sender has sufficient funds
3. **Gas Price**: Validates against minimum gas price requirements
4. **Gas Limit**: Checks against block gas limit
5. **EIP-1559**: Validates fee parameters for Type-2 transactions

### Transaction Ordering

The TxPool orders transactions by gas price and nonce:

```ts
// Get transactions ordered by price
const ordered = await pool.txsByPriceAndNonce({
  baseFee: 10n
})

// Get transactions for specific sender
const senderTxs = await pool.getBySenderAddress(senderAddress)
```

#### Priority Queue

For EIP-1559 transactions, ordering considers:

* `maxFeePerGas`
* `maxPriorityFeePerGas`
* Current block's `baseFee`

```ts
// Get highest priority transactions
const highPriority = await pool.getHighestPriorityTransactions()
```

### Pending State

The TxPool maintains a "pending state" that includes uncommitted transactions:

```ts
// Get state including pending transactions
const pendingBalance = await pool.getPendingBalance(address)
const pendingNonce = await pool.getPendingNonce(address)
```

#### JSON-RPC Support

The pending state is used when handling JSON-RPC calls with the `pending` block tag:

```ts
// Example eth_call with pending state
const result = await node.request({
  method: 'eth_call',
  params: [{
    to: contractAddress,
    data: calldata
  }, 'pending']
})
```

### Memory Management

The TxPool includes features to prevent memory exhaustion:

```ts
// Configuration
const POOL_SIZE_LIMIT = 5000 // Maximum transactions
const ACCOUNT_TX_LIMIT = 100 // Maximum per account
const PRICE_BUMP = 10        // % price increase to replace tx

// Clear old transactions
await pool.clearOldTransactions()

// Get pool statistics
const stats = await pool.getStats()
console.log({
  pending: stats.pending,
  queued: stats.queued,
  baseFee: stats.baseFee
})
```

### Event Handling

The TxPool emits events for transaction lifecycle:

```ts
pool.on('addedTx', (tx) => {
  console.log('New transaction:', tx.hash)
})

pool.on('removedTx', (txHash) => {
  console.log('Removed transaction:', txHash)
})

pool.on('pendingTx', (tx) => {
  console.log('Transaction pending:', tx.hash)
})
```

### Best Practices

1. **Transaction Replacement**:
   ```ts
   // Replace transaction with higher gas price
   const newTx = {
     ...oldTx,
     maxFeePerGas: oldTx.maxFeePerGas * 110n / 100n, // 10% increase
     nonce: oldTx.nonce // Same nonce
   }
   await pool.add(newTx)
   ```

2. **Memory Management**:
   * Monitor pool size
   * Clear old transactions periodically
   * Set appropriate limits per account

3. **Error Handling**:
   ```ts
   try {
     await pool.add(tx)
   } catch (error) {
     if (error.message.includes('replacement fee too low')) {
       // Increase gas price for replacement
     } else if (error.message.includes('pool is full')) {
       // Handle pool capacity
     }
     // Handle other errors
   }
   ```

4. **Gas Price Management**:
   * Track current base fee
   * Update gas price suggestions
   * Handle EIP-1559 parameters

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Receipts & Logs](./receipts-and-logs)


import { Callout, Steps, Step } from 'vocs/components'

## Creating a Tevm Node

`createTevmNode` is the main entry point for spinning up a local Tevm Node instance. It provides a flexible configuration API to customize your node's behavior for different use cases.

<Steps>
  <Step title="Install Dependencies">
    First, install the required packages:

    ```bash
    npm install tevm
    ```
  </Step>

  <Step title="Create Node Instance">
    Create a basic node instance:

    #### TypeScript

    ```ts
    import { createTevmNode } from 'tevm/node'

    const node = createTevmNode()
    await node.ready()
    ```

    #### JavaScript

    ```js
    const { createTevmNode } = require('tevm/node')

    const node = createTevmNode()
    await node.ready()
    ```
  </Step>

  <Step title="Configure Options">
    Customize the node based on your needs:

    ```ts
    const node = createTevmNode({
      fork: {
        transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      },
      miningConfig: { type: 'auto' },
      loggingLevel: 'debug'
    })
    ```
  </Step>
</Steps>

### Configuration Options

#### Fork Configuration

The `fork` option allows you to create a node that forks from an existing network:

```ts
import { createTevmNode, http } from 'tevm/node'

const node = createTevmNode({
  fork: {
    // Use any EIP-1193 compatible provider
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    // Optional: Fork from a specific block
    blockTag: 17_000_000n,
  },
})
```

<Callout type="info">
  When forking, state is fetched lazily from the remote provider and cached locally. This means your first access to any account or storage slot will be slower, but subsequent accesses will be fast.
</Callout>

#### Mining Configuration

Control how and when blocks are produced:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto', // Mine a block for every transaction
  },
})

// Or use interval-based mining
const node2 = createTevmNode({
  miningConfig: {
    type: 'interval',
    interval: 12_000, // Mine every 12 seconds
  },
})
```

#### Chain Configuration

Customize the chain parameters:

```ts
import { Common } from 'tevm/node'

const node = createTevmNode({
  common: Common.custom({
    chainId: 1337,
    networkId: 1337,
    // ... other chain parameters
  }),
})
```

#### Logging Configuration

Configure the internal logger:

```ts
const node = createTevmNode({
  loggingLevel: 'debug', // 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace'
})

// Later use the logger
node.logger.debug('Detailed debugging information')
```

#### Custom Precompiles

Add your own precompiled contracts:

```ts
import { definePrecompile } from 'tevm/node'

const myPrecompile = definePrecompile({
  address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2',
  call: async ({ data, gasLimit }) => {
    // Your precompile logic here
    return {
      returnValue: new Uint8Array([0x01]),
      executionGasUsed: 200n,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile],
})
```

#### Performance Profiling

Enable the built-in profiler for performance analysis:

```ts
const node = createTevmNode({
  profiler: true,
})

// Later access profiling data
const vm = await node.getVm()
const logs = vm.evm.getPerformanceLogs()
```

### Complete Configuration Reference

| Property                     | Type                                                           | Default      | Description                                                  |
| ---------------------------- | -------------------------------------------------------------- | ------------ | ------------------------------------------------------------ |
| `fork`                       | `{ transport: EIP1193RequestFn; blockTag?: BlockTag; }`        | -            | Enables forking from a live network or another Tevm instance |
| `common`                     | `Common`                                                       | `tevmDevnet` | Chain configuration object                                   |
| `loggingLevel`               | `"fatal" \| "error" \| "warn" \| "info" \| "debug" \| "trace"` | `"info"`     | Logging verbosity level                                      |
| `miningConfig`               | `'auto' \| 'interval' \| 'manual' \| 'gas'`                    | `'manual'`   | Block mining behavior                                        |
| `profiler`                   | `boolean`                                                      | `false`      | Enables performance logging                                  |
| `customPrecompiles`          | `CustomPrecompile[]`                                           | `[]`         | Additional precompiled contracts                             |
| `customPredeploys`           | `Predeploy[]`                                                  | `[]`         | Contracts to deploy at genesis                               |
| `allowUnlimitedContractSize` | `boolean`                                                      | `false`      | Disables EIP-170 contract size checks                        |
| `persister`                  | `SyncStoragePersister`                                         | -            | Hook for state persistence                                   |

### Best Practices

1. **Always await ready()**
   ```ts
   const node = createTevmNode()
   await node.ready() // Ensure node is initialized
   ```

2. **Use Appropriate Mining Config**
   * Use `'auto'` for testing
   * Use `'manual'` for precise control
   * Use `'interval'` for simulation

3. **Handle Errors**
   ```ts
   try {
     const node = createTevmNode()
     await node.ready()
   } catch (error) {
     console.error('Node initialization failed:', error)
   }
   ```

4. **Clean Up Resources**
   ```ts
   const node = createTevmNode()
   // ... use the node
   await node.getVm().then(vm => vm.blockchain.close())
   ```

### Examples

#### Local Development Node

```ts
const devNode = createTevmNode({
  miningConfig: { type: 'auto' },
  loggingLevel: 'debug',
  allowUnlimitedContractSize: true, // Helpful during development
})
```

#### Production Forked Node

```ts
const prodNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest',
  },
  miningConfig: { type: 'interval', interval: 12000 },
  loggingLevel: 'error', // Less verbose in production
})
```

#### Testing Node

```ts
const testNode = createTevmNode({
  miningConfig: { type: 'auto' },
  profiler: true, // Enable profiling for tests
})
```

### Next Steps

* Learn about the [Node Interface](./tevm-node-interface)
* Explore [Forking](./forking)
* Understand [State Management](./managing-state)


import { Callout } from 'vocs/components'

## Forking Networks

Tevm's forking capability allows you to create a local instance that mirrors the state of any live Ethereum network or another Tevm instance. This is incredibly useful for:

* Testing against production state
* Debugging transactions
* Development with real-world data
* Simulating complex DeFi interactions

### Basic Forking

#### TypeScript

```ts
import { createTevmNode, http } from 'tevm/node'

const node = createTevmNode({
  fork: {
    transport: http('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY'),
    blockTag: 'latest',
  },
})

await node.ready()
```

#### JavaScript

```js
const { createTevmNode, http } = require('tevm/node')

const node = createTevmNode({
  fork: {
    transport: http('https://rpc.ankr.com/eth/YOUR-API-KEY'),
    blockTag: 'latest',
  },
})

await node.ready()
```

<Callout type="info">
  The `transport` can be any EIP-1193 compatible provider, including those from viem, ethers, or even another Tevm instance.
</Callout>

### Reforking Strategies

There are two main strategies for reforking a Tevm node: using the node as a transport or using deep copy.

#### 1. Using Node as Transport

This is the recommended approach as it's more memory efficient. You can use an existing Tevm node as the transport for a new fork:

```ts
// Create initial node
const sourceNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 17_000_000n,
  },
})

// Perform some operations...
await performOperations(sourceNode)

// Get current block number
const currentBlock = await sourceNode.request({
  method: 'eth_blockNumber',
  params: [],
})

// Create new fork from the current state
const newNode = createTevmNode({
  fork: {
    transport: sourceNode, // Use the source node as transport
    blockTag: currentBlock, // Fork from current block
  },
})
```

This approach:

* Is memory efficient as it reuses the state from the source node
* Allows forking from a specific point in time
* Maintains the original node's state while allowing new modifications

#### 2. Using Deep Copy

For cases where you need a completely independent copy of the node:

```ts
const sourceNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Create a complete copy of the node
const copiedNode = await sourceNode.deepCopy()
```

This approach:

* Creates a completely independent copy of the node
* Is more memory intensive
* Useful for parallel testing scenarios
* Maintains complete isolation between instances

<Callout type="warning">
  Deep copying creates a new instance with its own state, which can be memory intensive for large state trees. Use this approach sparingly and prefer using the node as a transport when possible.
</Callout>

#### Choosing a Strategy

Use **Node as Transport** when:

* Memory efficiency is important
* You want to fork from a specific block
* You need to maintain the original state while testing alternatives

Use **Deep Copy** when:

* You need complete isolation
* Running parallel tests
* Memory usage is not a concern
* You want to maintain multiple independent states

### Fork Configuration Options

#### Specifying Block Number

Fork from a specific historical block:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://endpoints.omniatech.io/v1/eth/mainnet/YOUR-API-KEY'),
    blockTag: 17_000_000n, // Fork from block 17,000,000
  },
})
```

#### Supported Networks

Tevm can fork from any EVM-compatible network:

```ts
// Optimism
const optimismNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io'),
  },
})

// Arbitrum
const arbitrumNode = createTevmNode({
  fork: {
    transport: http('https://arb1.arbitrum.io/rpc'),
  },
})

// Polygon
const polygonNode = createTevmNode({
  fork: {
    transport: http('https://polygon-rpc.com'),
  },
})
```

### Working with Forked State

#### Reading State

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Get USDC contract state
const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
const vm = await node.getVm()
const usdcContract = await vm.stateManager.getAccount(USDC_ADDRESS)

console.log('USDC contract:', {
  balance: usdcContract.balance,
  nonce: usdcContract.nonce,
  codeHash: usdcContract.codeHash,
})
```

#### Modifying State

```ts
// Modify balance of an account
const vm = await node.getVm()
const address = '0x1234...'
const account = await vm.stateManager.getAccount(address)
account.balance += 1000000000000000000n // Add 1 ETH
await vm.stateManager.putAccount(address, account)
```

### Account Impersonation

Impersonation allows you to send transactions as any address without needing private keys:

```ts
// Impersonate Binance hot wallet
const BINANCE_14 = '0x28C6c06298d514Db089934071355E5743bf21d60'
node.setImpersonatedAccount(BINANCE_14)

// Send transaction as Binance
const vm = await node.getVm()
await vm.runTx({
  tx: {
    from: BINANCE_14,
    to: '0x1234...',
    value: 1000000000000000000n, // 1 ETH
  },
})

// Stop impersonating
node.setImpersonatedAccount(undefined)
```

### Performance Optimization

#### State Caching

Tevm implements lazy loading with caching:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// First access - fetches from remote
const vm = await node.getVm()
const t0 = performance.now()
await vm.stateManager.getAccount('0x1234...')
console.log('First access:', performance.now() - t0)

// Second access - uses cache
const t1 = performance.now()
await vm.stateManager.getAccount('0x1234...')
console.log('Cached access:', performance.now() - t1)
```

#### Prefetching

For known accounts you'll need, consider prefetching:

```ts
async function prefetchAccounts(node: TevmNode, addresses: string[]) {
  const vm = await node.getVm()
  await Promise.all(
    addresses.map(addr => vm.stateManager.getAccount(addr))
  )
}
```

### Advanced Usage

#### Forking from Another Tevm Instance

```ts
const sourceNode = createTevmNode()
// ... perform operations ...

const forkedNode = createTevmNode({
  fork: {
    transport: sourceNode,
  },
})
```

#### Custom State Overrides

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Override specific storage slots
const vm = await node.getVm()
await vm.stateManager.putContractStorage(
  '0x1234...',
  '0x0000000000000000000000000000000000000000000000000000000000000001',
  '0x0000000000000000000000000000000000000000000000000000000000000123'
)
```

### Best Practices

1. **RPC Provider Selection**
   ```ts
   // ✅ Use archive nodes for historical blocks
   const node = createTevmNode({
     fork: {
       transport: http('https://ethereum.quicknode.com/YOUR-API-KEY'),
       blockTag: 15_000_000n,
     },
   })
   ```

2. **Error Handling**
   ```ts
   try {
     const node = createTevmNode({
       fork: {
         transport: http('https://...'),
       },
     })
     await node.ready()
   } catch (error) {
     if (error.message.includes('rate limit')) {
       // Handle RPC rate limiting
     }
     throw error
   }
   ```

3. **Resource Management**
   ```ts
   // Clear cached state when no longer needed
   const vm = await node.getVm()
   await vm.stateManager.clearCaches()
   ```

4. **Testing Considerations**
   ```ts
   // Use a fixed block number for reproducible tests
   const node = createTevmNode({
     fork: {
       transport: http('https://...'),
       blockTag: 17_000_000n, // Fixed block
     },
   })
   ```

### Common Issues

<Callout type="warning">
  When forking from a public RPC endpoint, be mindful of rate limits. Consider using dedicated RPC providers for production use.
</Callout>

#### Rate Limiting

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://...'),
  },
  loggingLevel: 'debug', // Enable detailed logging
})

// Monitor RPC calls
node.logger.on('debug', (msg) => {
  if (msg.includes('rate limit')) {
    console.warn('RPC rate limit hit')
  }
})
```

#### State Inconsistency

```ts
// Verify state consistency
async function verifyState(node: TevmNode, address: string) {
  const vm = await node.getVm()
  const local = await vm.stateManager.getAccount(address)

  const remote = await vm.stateManager.getAccountFromProvider(address)

  if (local.balance !== remote.balance) {
    console.warn('State inconsistency detected')
  }
}
```

### Next Steps

* Learn about [State Management](./managing-state)
* Explore [Transaction Processing](../advanced/txpool)
* See [JSON-RPC Support](../api/json-rpc)


import { Callout } from 'vocs/components'

## Managing State

Tevm Node provides powerful state management capabilities through its `stateManager` interface. This allows you to interact with and modify Ethereum state, including accounts, contract code, and storage.

### Getting Started

Access the state manager through the VM:

```ts
const node = createTevmNode()
const vm = await node.getVm()
const stateManager = vm.stateManager
```

### Account Management

#### Reading Accounts

```ts
const address = '0x1234...'
const account = await stateManager.getAccount(address)

if (account) {
  console.log({
    balance: account.balance,      // BigInt
    nonce: account.nonce,         // BigInt
    codeHash: account.codeHash,   // Hex string
    storageRoot: account.storageRoot // Hex string
  })
}
```

#### Modifying Accounts

```ts
import { EthjsAccount } from 'tevm/utils'

// Create or update an account
await stateManager.putAccount(
  address,
  new EthjsAccount({
    nonce: 0n,
    balance: 10_000_000n, // 0.01 ETH
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })
)
```

<Callout type="info">
  When modifying accounts, make sure to handle the case where the account doesn't exist by creating a new `EthjsAccount` instance.
</Callout>

#### Deleting Accounts

```ts
await stateManager.deleteAccount(address)
```

### Contract Management

#### Deploying Contract Code

```ts
// Deploy contract bytecode
await stateManager.putContractCode(
  address,
  new Uint8Array([/* bytecode */])
)

// Verify deployment
const code = await stateManager.getContractCode(address)
console.log('Deployed code length:', code.length)
```

#### Reading Contract Code

```ts
const deployedCode = await stateManager.getContractCode(address)
if (deployedCode.length > 0) {
  console.log('Contract exists with code')
} else {
  console.log('No contract code at address')
}
```

### Storage Management

#### Reading Storage

```ts
// Get a specific storage slot
const slot = '0x0000000000000000000000000000000000000000000000000000000000000000'
const value = await stateManager.getContractStorage(address, slot)

// Dump all storage
const storage = await stateManager.dumpStorage(address)
console.log('Contract storage:', storage)
```

#### Writing Storage

```ts
// Set a storage value
const key = '0x0000000000000000000000000000000000000000000000000000000000000000'
const value = '0x0000000000000000000000000000000000000000000000000000000000000001'
await stateManager.putContractStorage(address, key, value)
```

#### Clearing Storage

```ts
// Clear all storage for a contract
await stateManager.clearContractStorage(address)
```

### State Checkpoints

Tevm uses a checkpoint system to manage state changes atomically:

```ts
// Create a checkpoint
await stateManager.checkpoint()

try {
  // Make state changes
  await stateManager.putAccount(/* ... */)
  await stateManager.putContractStorage(/* ... */)

  // Commit changes if successful
  await stateManager.commit()
} catch (error) {
  // Revert changes on failure
  await stateManager.revert()
  console.error('State changes reverted:', error)
}
```

### State Persistence

#### Dumping State

Export the entire state as a serializable object:

```ts
// Get complete state
const state = await stateManager.dumpCanonicalGenesis()

// Save state (example with localStorage)
localStorage.setItem('tevmState', JSON.stringify(state))
```

#### Loading State

Restore state from a previous dump:

```ts
// Load saved state
const savedState = JSON.parse(localStorage.getItem('tevmState'))

// Restore state
await stateManager.generateCanonicalGenesis(savedState)
```

### State Persistence with dumpState and loadState

Tevm provides dedicated handlers for persisting and restoring state, which can be used to save the entire state to local storage or the file system.

#### Using dumpState

```ts
import { createTevmNode } from 'tevm/node'
import { dumpStateHandler } from 'tevm/node'

const node = createTevmNode()

// Dump state at latest block
const { state: dumpedState } = await dumpStateHandler(node)()

// Dump state at specific block
const { state: historicalState } = await dumpStateHandler(node)({
  blockTag: 1000n
})

// Save to localStorage
localStorage.setItem('tevmState', JSON.stringify(dumpedState))

// Or save to file system
import { writeFileSync } from 'fs'
writeFileSync('tevm-state.json', JSON.stringify(dumpedState, null, 2))
```

#### Using loadState

```ts
import { createTevmNode } from 'tevm/node'
import { loadStateHandler } from 'tevm/node'

const node = createTevmNode()

// Load from localStorage
const savedState = JSON.parse(localStorage.getItem('tevmState'))
await loadStateHandler(node)({
  state: savedState
})

// Or load from file system
import { readFileSync } from 'fs'
const fileState = JSON.parse(readFileSync('tevm-state.json', 'utf8'))
await loadStateHandler(node)({
  state: fileState
})
```

#### State Format

The dumped state includes account data and storage:

```ts
interface DumpedState {
  [address: string]: {
    nonce: bigint
    balance: bigint
    storage: {
      [key: string]: string // hex strings without 0x prefix
    }
    code?: string // hex string without 0x prefix
  }
}
```

#### Error Handling

```ts
// Handle errors during dump
const { state, errors } = await dumpStateHandler(node)({
  blockTag: 1000n,
  throwOnFail: false // Don't throw on errors
})

if (errors) {
  console.error('State dump errors:', errors)
}

// Handle errors during load
const { errors: loadErrors } = await loadStateHandler(node)({
  state: savedState,
  throwOnFail: false
})

if (loadErrors) {
  console.error('State load errors:', loadErrors)
}
```

#### Testing Example

```ts
import { createTevmNode } from 'tevm/node'
import { EthjsAccount, EthjsAddress, bytesToHex, hexToBytes } from 'tevm'
import { expect, test } from 'vitest'
import { dumpStateHandler, loadStateHandler } from 'tevm/node'

test('State persistence', async () => {
  // Setup initial state
  const accountAddress = '0x0420042004200420042004200420042004200420'
  const account = EthjsAddress.fromString(accountAddress)
  const accountInstance = new EthjsAccount(0n, 100n)

  const node = createTevmNode()
  const vm = await node.getVm()

  // Set account and storage
  await vm.stateManager.putAccount(account, accountInstance)
  await vm.stateManager.putContractStorage(
    account,
    hexToBytes('0x1', { size: 32 }),
    hexToBytes('0x1', { size: 32 })
  )

  // Dump state
  const { state: dumpedState } = await dumpStateHandler(node)()

  // Create new node and load state
  const node2 = createTevmNode()
  await loadStateHandler(node2)({
    state: dumpedState
  })

  // Verify state was restored
  const restoredStorage = await (await node2.getVm())
    .stateManager
    .getContractStorage(account, hexToBytes('0x1', { size: 32 }))

  expect(bytesToHex(restoredStorage)).toEqual('0x1'.padEnd(66, '0'))
})
```

### Fork Mode State

When running in fork mode, state is fetched lazily from the remote provider:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')
  }
})

const vm = await node.getVm()
const stateManager = vm.stateManager

// First access fetches from remote
const t0 = performance.now()
await stateManager.getAccount('0x1234...')
console.log('Initial fetch:', performance.now() - t0)

// Subsequent access uses cache
const t1 = performance.now()
await stateManager.getAccount('0x1234...')
console.log('Cached access:', performance.now() - t1)
```

### Best Practices

1. **Error Handling**
   ```ts
   try {
     const account = await stateManager.getAccount(address)
     if (!account) {
       throw new Error(`Account ${address} not found`)
     }
     // Work with account
   } catch (error) {
     console.error('State operation failed:', error)
   }
   ```

2. **State Isolation**
   ```ts
   // Create isolated copy for testing
   const isolatedState = await stateManager.deepCopy()
   ```

3. **Resource Cleanup**
   ```ts
   // Clear caches when done
   stateManager.clearCaches()
   ```

4. **Atomic Operations**
   ```ts
   await stateManager.checkpoint()
   try {
     // Batch multiple state changes
     await Promise.all([
       stateManager.putAccount(/* ... */),
       stateManager.putContractStorage(/* ... */),
     ])
     await stateManager.commit()
   } catch (error) {
     await stateManager.revert()
   }
   ```

### Related Topics

* [Transaction Processing](../advanced/txpool)
* [Receipts and Logs](../advanced/receipts-and-logs)
* [Forking](./forking)


import { Callout } from 'vocs/components'

## TevmNode Interface

The `TevmNode` interface is the core API surface of Tevm. It provides access to all the fundamental Ethereum node capabilities, from transaction processing to state management.

### Interface Overview

```ts
export type TevmNode<TMode extends 'fork' | 'normal' = 'fork' | 'normal', TExtended = {}> = {
  readonly logger: Logger
  readonly getReceiptsManager: () => Promise<ReceiptsManager>
  readonly miningConfig: MiningConfig
  readonly forkTransport?: { request: EIP1193RequestFn }
  readonly mode: TMode
  readonly ready: () => Promise<true>
  readonly getVm: () => Promise<Vm>
  readonly getTxPool: () => Promise<TxPool>
  readonly getImpersonatedAccount: () => Address | undefined
  readonly setImpersonatedAccount: (address: Address | undefined) => void
  readonly extend: <TExtension>(decorator: (client: TevmNode<TMode, TExtended>) => TExtension) => TevmNode<TMode, TExtended & TExtension>
  readonly setFilter: (filter: Filter) => void
  readonly getFilters: () => Map<Hex, Filter>
  readonly removeFilter: (id: Hex) => void
  status: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
  readonly deepCopy: () => Promise<TevmNode<TMode, TExtended>>
} & EIP1193EventEmitter & TExtended
```

### Core Components

#### 1. Initialization & Status

```ts
const node = createTevmNode()

// Wait for initialization
await node.ready()

// Check status
console.log(node.status) // 'READY'
```

<Callout type="info">
  The `ready()` method ensures all internal components are initialized. While not strictly required (methods will wait implicitly), calling it explicitly can help manage initialization flow.
</Callout>

#### 2. Virtual Machine Access

The VM is the heart of Tevm, providing EVM execution capabilities:

```ts
const node = createTevmNode()
const vm = await node.getVm()

// Execute a transaction
const result = await vm.runTx({
  tx: {
    to: '0x1234...',
    value: 1000000000000000000n, // 1 ETH
    data: '0x...',
  }
})
```

#### 3. Transaction Pool Management

The TxPool handles pending transactions:

```ts
const node = createTevmNode()
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### 4. Receipt & Log Management

Track transaction outcomes and event logs:

```ts
const node = createTevmNode()
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

#### 5. Account Impersonation

In fork mode, you can impersonate existing accounts:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

// Now you can send transactions as this account
const vm = await node.getVm()
await vm.runTx({
  tx: {
    from: '0x28C6c06298d514Db089934071355E5743bf21d60',
    to: '0x1234...',
    value: 1000000000000000000n,
  },
})
```

#### 6. Event Filtering

Manage subscriptions to blockchain events:

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

#### 7. Extensibility

The `extend` method allows adding custom functionality:

```ts
// Add custom methods
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### 8. Deep Copying

Create independent copies of a node:

```ts
const node = createTevmNode()
// ... perform some operations ...

// Create a copy with the same state
const nodeCopy = await node.deepCopy()
```

<Callout type="warning">
  Deep copying creates a completely new instance with its own state. This is useful for testing different scenarios, but can be memory-intensive.
</Callout>

### Best Practices

1. **Initialization**
   ```ts
   const node = createTevmNode()
   await node.ready() // Always wait for ready
   ```

2. **Error Handling**
   ```ts
   try {
     const vm = await node.getVm()
     await vm.runTx(/* ... */)
   } catch (error) {
     if (error.message.includes('insufficient funds')) {
       // Handle specific error cases
     }
     throw error
   }
   ```

3. **Resource Management**
   ```ts
   // Clean up filters when done
   node.getFilters().forEach((_, id) => node.removeFilter(id))
   ```

4. **State Isolation**
   ```ts
   // Use deepCopy for isolated test cases
   const baseNode = createTevmNode()

   test('scenario 1', async () => {
     const node = await baseNode.deepCopy()
     // Test with isolated state
   })
   ```

### Type Safety

The interface is fully typed with TypeScript:

```ts
import type { TevmNode } from 'tevm/node'

function useNode<TMode extends 'fork' | 'normal'>(
  node: TevmNode<TMode>
) {
  if (node.mode === 'fork') {
    // Fork-specific operations
    node.setImpersonatedAccount('0x...')
  }
}
```

### Next Steps

* Learn about [Forking](./forking)
* Explore [State Management](./managing-state)
* See [JSON-RPC Support](../api/json-rpc)


## Architecture Overview

### What is Tevm Node?

[Tevm Node](https://github.com/evmts/tevm-monorepo) is a JavaScript implementation of an Ethereum node that can run in any JavaScript environment - browsers, Node.js, or other runtimes. It provides a complete [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/) with state management, transaction processing, and JSON-RPC support.

### Core Architecture

![Tevm Node Architecture](https://raw.githubusercontent.com/evmts/tevm-monorepo/main/docs/images/architecture.png)

Tevm Node is built on several key components that work together:

#### 1. Virtual Machine (EVM)

* Core execution engine that runs [EVM bytecode](https://ethereum.org/en/developers/docs/evm/opcodes/)
* Handles state transitions and gas metering
* Based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm)

#### 2. State Manager

* Manages account balances, contract code, and storage
* Supports forking from live networks
* Implements caching and lazy loading

#### 3. Transaction Pool (Mempool)

* Manages pending transactions
* Orders transactions by gas price
* Validates transaction requirements

#### 4. Blockchain

* Maintains block history and chain state
* Handles block production (mining)
* Manages chain reorganizations

#### 5. Receipts Manager

* Tracks transaction outcomes
* Manages event logs and filters
* Supports optimistic updates

### Available APIs

Tevm Node provides several layers of APIs for different use cases:

#### 1. High-Level Actions

Most functionality in Tevm is done via tree shakable actions including JSON-RPC compatabile actions.

The most commonly used action is `tevmCall`

```ts
import { tevmCall, tevmMine, tevmGetAccount } from 'tevm/actions'

// Execute contract calls
const result = await tevmCall(node, {
  to: contractAddress,
  data: calldata
})

// Mine pending transactions
await tevmMine(node)

// Read account state
const account = await tevmGetAccount(node, {
  address: accountAddress
})
```

#### 2. JSON-RPC Interface

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard Ethereum JSON-RPC calls
const balance = await node.request({
  method: 'eth_getBalance',
  params: [address, 'latest']
})
```

#### 3. Direct VM Access

```ts
const vm = await node.getVm()

// Low-level EVM execution
const result = await vm.runTx({
  tx: transaction,
  block: block
})

// State management
await vm.stateManager.putAccount(address, account)
```

#### 4. Contract Utilities

```ts
import { createContract } from 'tevm/contract'

// Type-safe contract interactions
const contract = createContract({
  humanReadableAbi: abi,
  address: contractAddress
})

const action = contract.write.transfer(to, amount)
```

Note, you can optionally compile these contracts automatically in a typesafe way using the tevm bundler (docs coming soon)

```typescript
// import solidity direction to create a contract
import {MyContract} from './MyContract.sol'

console.log(MyContract.abi)
```

### Key Features

#### 1. Forking

Fork from any live network or another Tevm instance:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest'
  }
})
```

#### 2. Mining Modes

Configure how transactions are processed:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto' // Mine every transaction
    // Or 'interval', 'manual', 'gas'
  }
})
```

#### 3. Custom Precompiles

Extend the EVM with JavaScript functions:

```ts
const precompile = definePrecompile({
  address: '0x123...',
  call: async (input) => {
    // Custom logic
    return {
      returnValue: result,
      executionGasUsed: 100n
    }
  }
})
```

#### 4. State Management

Direct control over blockchain state:

```ts
// Modify account state
await node.setAccount({
  address: '0x123...',
  balance: 100n,
  code: '0x...',
  storage: { /* ... */ }
})

// Create checkpoints
await vm.stateManager.checkpoint()
await vm.stateManager.commit() // or .revert()
```

### Common Use Cases

1. **Local Development**
   * Run a complete Ethereum environment locally
   * Test contracts without external networks
   * Simulate complex scenarios

2. **Testing**
   * Unit test smart contracts
   * Integration test DApp interactions
   * Fork mainnet for realistic tests

3. **Transaction Simulation**
   * Preview transaction outcomes
   * Estimate gas costs accurately
   * Debug failed transactions

4. **State Manipulation**
   * Modify account balances
   * Override contract state
   * Test edge cases

### Integration Examples

#### With Viem

```ts
import { createPublicClient, custom } from 'viem'

const client = createPublicClient({
  transport: custom(node.request)
})
```

#### With Ethers.js

```ts
import { BrowserProvider } from 'ethers'

const provider = new BrowserProvider(node)
```

### Next Steps

* [Installation & Quickstart](../introduction/installation)
* [Core Concepts](../core/create-tevm-node)
* [API Reference](../api/methods)
* [Examples](../examples/local-testing)


## Installation & Quickstart

### 1. Install

```sh
npm install @tevm/node

# or
yarn add @tevm/node

# or
pnpm add @tevm/node

# or
bun add @tevm/node
```

### 2. Quick Start

```ts
import { createTevmNode } from 'tevm/node'

// Create an instance
const node = createTevmNode()

// Access the internal VM once it is ready
const vm = await node.getVm()

// Perform an method on the vm or one of it's subcomponents like blockchain
console.log(await vm.blockchain.getBlockByTag('latest'))
```

### 3. Next Steps

* Explore the [Core Concepts](../core/create-tevm-node)
* Check out [Examples](../examples/local-testing)


## What is Tevm Node?

Tevm Node is an in-browser & Node.js-compatible Ethereum Node. It provides a complete Ethereum Virtual Machine (EVM) execution environment, powered by JavaScript, that you can run:

* **In Node.js** for local or CI testing.
* **In the Browser** for advanced user experiences (offline, real-time simulation, etc.).
* **In Deno, Bun**, or any modern JS environment.

### Key Features

* **Forking:** Simulate mainnet or testnet state from a live RPC, similar to Hardhat or Anvil.
* **TxPool (Mempool):** Keep track of unmined transactions locally.
* **Mining Config:** Choose between auto mining, interval-based mining, manual, or gas-limit-based mining.
* **Zero dependencies on native modules** – works seamlessly in the browser.
* **Extendable:** Hook into the VM, custom precompiles, receipts, and more.

### Hello World Example

This example forks optimism then reads block data using `vm.blockchain`

```ts
import { createTevmNode, http } from 'tevm/node'

// Create a node that forks from Optimism
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io')
  }
})

const vm = await node.getVm()

console.log(await vm.blockchain.getBlockByTag('latest'))
```

### Motivations / Why Tevm Node

* **Browser/Local Execution** for improved latency & advanced debugging.
* **Optimistic updates**: Inspect tx side effects before on-chain mining.
* **Lightweight**: Slashes overhead vs. running a full geth or anvil node.
* **Network independence**: Freed from real chain constraints in your applications.

### Next Steps

* [Why run Ethereum in JavaScript?](./why-run-ethereum-in-js)
* [Installation & Quickstart](./installation)


## Why run Ethereum in JavaScript?

### 1. Advanced Gas Estimation & Local Execution

Running the EVM locally removes round-trip latency to a remote node. You can do:

* Bulk simulation or multi-tx simulation
* Real-time "dry run" of transactions
* Faster dev/test cycles

### 2. User Experience Enhancements

* **Offline** or *local-first* capabilities
* **Optimistic UI** updates with local simulation
* No reliance on ephemeral test networks

### 3. Testing & Debugging

* Fine-grained EVM introspection
* Deterministic environment
* Light footprint – no external server needed

### 4. Ecosystem & Portability

* Portable across Node.js, browsers, and serverless
* Works with standard EVM interfaces
* Integrates well with modern JS/TS tooling


## Building a Debugger UI

This example demonstrates how to create a minimal EVM debugger interface using [Svelte](https://svelte.dev) and Tevm Node. The debugger will show:

* Live opcode execution
* Stack contents
* Memory state
* Error messages
* Gas usage

### Project Setup

First, create a new Svelte project and install dependencies:

```bash
npm create vite@latest tevm-debugger -- --template svelte-ts
cd tevm-debugger
npm install tevm @tevm/contract
```

### Components

#### 1. EVMDebugger.svelte

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte'
  import { createTevmNode } from 'tevm/node'
  import type { InterpreterStep } from '@tevm/evm'

  // Store execution state
  let steps: InterpreterStep[] = []
  let currentStep: InterpreterStep | null = null
  let errors: string[] = []
  let gasUsed = 0n
  let isRunning = false

  // Create Tevm Node
  const node = createTevmNode()
  let vm: Awaited<ReturnType<typeof node.getVm>>

  onMount(async () => {
    vm = await node.getVm()
    setupEventListeners()
  })

  function setupEventListeners() {
    // Track execution steps
    vm.evm.events?.on('step', (step, next) => {
      currentStep = step
      steps = [...steps, step]
      next?.()
    })

    // Track errors
    vm.evm.events?.on('afterMessage', (result, next) => {
      if (result.execResult.exceptionError) {
        errors = [...errors, result.execResult.exceptionError.error]
      }
      gasUsed = result.execResult.executionGasUsed
      next?.()
    })
  }

  // Clean up
  onDestroy(() => {
    vm?.evm.events?.removeAllListeners()
  })

  // Execute sample transaction
  async function runSampleTx() {
    isRunning = true
    steps = []
    errors = []

    try {
      await vm.runTx({
        tx: {
          to: '0x1234...',
          data: '0x...',  // Your transaction data
        }
      })
    } catch (error) {
      errors = [...errors, error.message]
    }

    isRunning = false
  }
</script>

<div class="debugger">
  <div class="controls">
    <button on:click={runSampleTx} disabled={isRunning}>
      {isRunning ? 'Running...' : 'Run Transaction'}
    </button>
    <div class="gas">Gas Used: {gasUsed.toString()}</div>
  </div>

  <div class="execution">
    <h3>Current Step</h3>
    {#if currentStep}
      <div class="step">
        <div>PC: {currentStep.pc}</div>
        <div>Opcode: {currentStep.opcode.name}</div>
        <div>Gas Left: {currentStep.gasLeft.toString()}</div>
        <div>Depth: {currentStep.depth}</div>
      </div>
    {/if}
  </div>

  <div class="stack">
    <h3>Stack</h3>
    {#if currentStep?.stack}
      <div class="stack-items">
        {#each currentStep.stack as item}
          <div class="stack-item">{item.toString(16)}</div>
        {/each}
      </div>
    {/if}
  </div>

  <div class="errors">
    <h3>Errors</h3>
    {#each errors as error}
      <div class="error">{error}</div>
    {/each}
  </div>

  <div class="history">
    <h3>Execution History ({steps.length} steps)</h3>
    <div class="steps">
      {#each steps as step}
        <div class="history-step">
          {step.opcode.name} (Gas: {step.gasLeft.toString()})
        </div>
      {/each}
    </div>
  </div>
</div>

<style>
  .debugger {
    padding: 1rem;
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(2, 1fr);
  }

  .controls {
    grid-column: 1 / -1;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  button {
    padding: 0.5rem 1rem;
    background: #4a5568;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .execution, .stack, .errors, .history {
    background: #2d3748;
    padding: 1rem;
    border-radius: 0.5rem;
    color: #e2e8f0;
  }

  .stack-items {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .stack-item {
    font-family: monospace;
    padding: 0.25rem;
    background: #4a5568;
    border-radius: 0.25rem;
  }

  .error {
    color: #fc8181;
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: #742a2a;
    border-radius: 0.25rem;
  }

  .steps {
    height: 200px;
    overflow-y: auto;
  }

  .history-step {
    padding: 0.25rem;
    border-bottom: 1px solid #4a5568;
    font-family: monospace;
  }
</style>
```

#### 2. App.svelte

```svelte
<script lang="ts">
  import EVMDebugger from './lib/EVMDebugger.svelte'
</script>

<main>
  <h1>Tevm Debugger</h1>
  <EVMDebugger />
</main>

<style>
  main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  h1 {
    color: #2d3748;
    margin-bottom: 2rem;
  }
</style>
```

### Advanced Features

#### Memory Viewer Component

```svelte
<script lang="ts">
  export let memory: Uint8Array
  export let startOffset = 0
  export let bytesPerRow = 16

  $: rows = chunk(memory, bytesPerRow)

  function chunk(array: Uint8Array, size: number) {
    const chunks = []
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size))
    }
    return chunks
  }

  function formatByte(byte: number) {
    return byte.toString(16).padStart(2, '0')
  }

  function formatAscii(byte: number) {
    return byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'
  }
</script>

<div class="memory-viewer">
  {#each rows as row, i}
    <div class="memory-row">
      <span class="offset">
        {(startOffset + i * bytesPerRow).toString(16).padStart(8, '0')}:
      </span>
      <span class="hex">
        {#each row as byte}
          {formatByte(byte)}
        {/each}
      </span>
      <span class="ascii">
        {#each row as byte}
          {formatAscii(byte)}
        {/each}
      </span>
    </div>
  {/each}
</div>

<style>
  .memory-viewer {
    font-family: monospace;
    white-space: pre;
  }

  .memory-row {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
  }

  .offset {
    color: #718096;
  }

  .hex {
    letter-spacing: 0.1em;
  }

  .ascii {
    color: #718096;
  }
</style>
```

#### Storage Viewer Component

```svelte
<script lang="ts">
  import type { Address } from '@tevm/utils'
  import { createTevmNode } from 'tevm/node'

  export let address: Address

  let storage = new Map<string, string>()
  let loading = false

  const node = createTevmNode()

  async function loadStorage() {
    loading = true
    try {
      const vm = await node.getVm()
      const dump = await vm.stateManager.dumpStorage(address)
      storage = new Map(Object.entries(dump))
    } catch (error) {
      console.error('Failed to load storage:', error)
    }
    loading = false
  }
</script>

<div class="storage">
  <button on:click={loadStorage} disabled={loading}>
    {loading ? 'Loading...' : 'Load Storage'}
  </button>

  {#if storage.size > 0}
    <div class="storage-items">
      {#each [...storage] as [slot, value]}
        <div class="storage-item">
          <span class="slot">{slot}:</span>
          <span class="value">{value}</span>
        </div>
      {/each}
    </div>
  {/if}
</div>

<style>
  .storage {
    padding: 1rem;
  }

  .storage-items {
    margin-top: 1rem;
  }

  .storage-item {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
    font-family: monospace;
  }

  .slot {
    color: #718096;
  }
</style>
```

### Usage

1. Create the project structure:

```
tevm-debugger/
├── src/
│   ├── lib/
│   │   ├── EVMDebugger.svelte
│   │   ├── MemoryViewer.svelte
│   │   └── StorageViewer.svelte
│   ├── App.svelte
│   └── main.ts
└── package.json
```

2. Run the development server:

```bash
npm run dev
```

3. Use the debugger:

```ts
// Example contract deployment
const bytecode = '0x...' // Your contract bytecode
await vm.runTx({
  tx: {
    data: bytecode
  }
})

// Example contract interaction
await vm.runTx({
  tx: {
    to: '0x...',    // Contract address
    data: '0x...',  // Encoded function call
  }
})
```

### Customization

#### Adding Transaction History

```svelte
<script lang="ts">
  import { writable } from 'svelte/store'

  const transactions = writable<{
    hash: string
    to: string
    data: string
    status: 'success' | 'error'
  }[]>([])

  vm.evm.events?.on('afterMessage', (result, next) => {
    transactions.update(txs => [...txs, {
      hash: result.execResult.hash?.toString() ?? '',
      to: result.execResult.to?.toString() ?? '',
      data: result.execResult.data?.toString('hex') ?? '',
      status: result.execResult.exceptionError ? 'error' : 'success'
    }])
    next?.()
  })
</script>

<div class="transactions">
  <h3>Transaction History</h3>
  {#each $transactions as tx}
    <div class="transaction" class:error={tx.status === 'error'}>
      <div>Hash: {tx.hash}</div>
      <div>To: {tx.to}</div>
      <div>Data: {tx.data}</div>
    </div>
  {/each}
</div>
```

#### Adding Gas Profiling

```svelte
<script lang="ts">
  const gasProfile = new Map<string, { count: number, totalGas: bigint }>()

  vm.evm.events?.on('step', (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = gasProfile.get(opName) ?? { count: 0, totalGas: 0n }
    stats.count++
    stats.totalGas += gasCost
    gasProfile.set(opName, stats)

    next?.()
  })
</script>

<div class="gas-profile">
  <h3>Gas Profile</h3>
  <table>
    <thead>
      <tr>
        <th>Opcode</th>
        <th>Count</th>
        <th>Total Gas</th>
      </tr>
    </thead>
    <tbody>
      {#each [...gasProfile] as [opcode, stats]}
        <tr>
          <td>{opcode}</td>
          <td>{stats.count}</td>
          <td>{stats.totalGas.toString()}</td>
        </tr>
      {/each}
    </tbody>
  </table>
</div>
```

### Related Topics

* [EVM Events](../api/evm-events)
* [Performance Profiler](../advanced/performance-profiler)


## Using with Ethers.js

This guide demonstrates how to use Tevm Node with Ethers.js, enabling seamless integration with the popular Ethereum development library.

### Basic Setup

```ts
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'
import { BrowserProvider } from 'ethers'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Ethers provider
const provider = new BrowserProvider(node)

// Basic provider usage
const block = await provider.getBlockNumber()
const balance = await provider.getBalance('0x1234...')
```

### Contract Interaction

#### 1. Reading Contract State

```ts
import { Contract } from 'ethers'

// Contract setup
const abi = [
  'function balanceOf(address) view returns (uint256)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
]

const tokenAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' // USDC
const contract = new Contract(tokenAddress, abi, provider)

// Read multiple values
const [balance, symbol, decimals] = await Promise.all([
  contract.balanceOf('0x1234...'),
  contract.symbol(),
  contract.decimals(),
])

console.log(`${symbol} Balance: ${formatUnits(balance, decimals)}`)
```

#### 2. Writing to Contracts

```ts
// Get signer
const signer = await provider.getSigner()

// Connect contract to signer
const contractWithSigner = contract.connect(signer)

// Send transaction
const tx = await contractWithSigner.transfer('0x5678...', parseUnits('100', 6))

// Wait for confirmation
const receipt = await tx.wait()
console.log('Transaction confirmed:', receipt.hash)
```

### Event Handling

#### 1. Listening for Events

```ts
// Listen for Transfer events
contract.on('Transfer', (from, to, amount, event) => {
  console.log('Transfer:', {
    from,
    to,
    amount: formatUnits(amount, 6),
    blockNumber: event.blockNumber,
    transactionHash: event.transactionHash,
  })
})

// Remove listener when done
contract.off('Transfer')
```

#### 2. Querying Past Events

```ts
// Create filter
const filter = contract.filters.Transfer()

// Get past events
const events = await contract.queryFilter(filter, -1000, 'latest')

for (const event of events) {
  const { from, to, value } = event.args
  console.log('Historical transfer:', {
    from,
    to,
    value: formatUnits(value, 6),
  })
}
```

### Advanced Usage

#### 1. Contract Deployment

```ts
import { ContractFactory } from 'ethers'

// Get signer
const signer = await provider.getSigner()

// Create factory
const factory = new ContractFactory(abi, bytecode, signer)

// Deploy contract
const contract = await factory.deploy(constructorArg1, constructorArg2)
await contract.waitForDeployment()

console.log('Contract deployed to:', await contract.getAddress())
```

#### 2. Low-level Transaction Handling

```ts
// Create transaction
const tx = {
  to: '0x1234...',
  value: parseEther('1'),
  data: '0x',
}

// Sign transaction
const signer = await provider.getSigner()
const signedTx = await signer.signTransaction(tx)

// Send raw transaction
const hash = await provider.send('eth_sendRawTransaction', [signedTx])

// Wait for confirmation
const receipt = await provider.waitForTransaction(hash)
```

#### 3. Interface Encoding/Decoding

```ts
import { Interface } from 'ethers'

// Create interface
const iface = new Interface([
  'function transfer(address to, uint256 amount) returns (bool)',
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])

// Encode function data
const data = iface.encodeFunctionData('transfer', [
  '0x1234...',
  parseUnits('100', 6),
])

// Decode event logs
const log = receipt.logs[0]
const decodedLog = iface.parseLog({
  topics: log.topics,
  data: log.data,
})
```

### Testing with Ethers

```ts
import { expect } from 'chai'
import { loadFixture } from '@nomicfoundation/hardhat-network-helpers'

describe('Token Contract', () => {
  async function deployTokenFixture() {
    // Setup Tevm Node
    const node = createTevmNode()
    const provider = new BrowserProvider(node)
    const signer = await provider.getSigner()

    // Deploy contract
    const factory = new ContractFactory(abi, bytecode, signer)
    const token = await factory.deploy()
    await token.waitForDeployment()

    return { token, signer, provider }
  }

  it('Should handle basic operations', async () => {
    const { token, signer } = await loadFixture(deployTokenFixture)

    // Test initial state
    expect(await token.balanceOf(signer.address)).to.equal(initialSupply)

    // Test transfer
    await token.transfer('0x1234...', 100)
    expect(await token.balanceOf('0x1234...')).to.equal(100)
  })
})
```

### Best Practices

1. **Contract Initialization**:
   ```ts
   // Reuse contract instances
   const contracts = new Map<string, Contract>()

   function getContract(address: string): Contract {
     let contract = contracts.get(address)
     if (!contract) {
       contract = new Contract(address, abi, provider)
       contracts.set(address, contract)
     }
     return contract
   }
   ```

2. **Error Handling**:
   ```ts
   try {
     const tx = await contract.riskyFunction()
     await tx.wait()
   } catch (error) {
     if (error.code === 'CALL_EXCEPTION') {
       console.error('Contract call failed:', error.reason)
     } else if (error.code === 'NETWORK_ERROR') {
       console.error('Network error:', error.message)
     }
     throw error
   }
   ```

3. **Gas Management**:
   ```ts
   // Estimate gas with buffer
   const gasEstimate = await contract.transfer.estimateGas(
     recipient,
     amount
   )

   const tx = await contract.transfer(
     recipient,
     amount,
     {
       gasLimit: gasEstimate * 120n / 100n, // 20% buffer
     }
   )
   ```

4. **Event Management**:
   ```ts
   // Clean up listeners
   function setupEventListeners(contract: Contract) {
     const handler = (...args) => {
       // Handle event
     }

     contract.on('Transfer', handler)

     return () => {
       contract.off('Transfer', handler)
     }
   }

   const cleanup = setupEventListeners(contract)
   // Later...
   cleanup()
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [Local Testing](./local-testing)
* [Forking Mainnet](./forking-mainnet)


## Forking Mainnet Example

### Basic Fork Setup

```ts
import { createTevmNode } from 'tevm/node'
import { http } from 'viem'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 17_000_000n,
  },
  loggingLevel: 'debug',
})

await node.ready()

// Now any calls to an unknown account or contract
// will fetch the data from mainnet, but store the result locally for caching.
```

### Account Impersonation

```ts
// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60') // Binance 14

// Now you can run transactions "as" that address, no signature needed
const tx = createImpersonatedTx({
  to: '0x1234...',
  value: 1000000000000000000n, // 1 ETH
})

const vm = await node.getVm()
await vm.runTx({ tx })
```

### Working with Forked Contracts

```ts
// Example: Interacting with USDC on mainnet
const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

// Get the contract state from mainnet
const usdcContract = new Contract(USDC_ADDRESS, USDC_ABI)
const balance = await usdcContract.read.balanceOf(['0x1234...'])

// Modify state locally
await usdcContract.write.transfer(['0x5678...', 1000000]) // 1 USDC

// Changes only affect your local fork
const newBalance = await usdcContract.read.balanceOf(['0x1234...'])
```

### Fork at Specific Block

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 15_000_000n, // Fork from a specific block
  },
})

// Test historical state
const historicalBalance = await getBalance(address)
```

### Multiple Network Support

```ts
// Fork from different networks
const optimismNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io'),
  },
})

const arbitrumNode = createTevmNode({
  fork: {
    transport: http('https://arb1.arbitrum.io/rpc'),
  },
})
```

**Related**

* [Forking Guide](../core/forking)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)


## Local Testing

This guide demonstrates how to use Tevm Node for local testing of [smart contracts](https://ethereum.org/en/developers/docs/smart-contracts/) and [transactions](https://ethereum.org/en/developers/docs/transactions/). For more background on testing Ethereum applications, see the [Smart Contract Testing Guide](https://ethereum.org/en/developers/docs/smart-contracts/testing/).

### Basic Test Setup

```ts
import { createTevmNode } from 'tevm/node'
import { createImpersonatedTx } from 'tevm/tx'
import { expect, test } from 'vitest' // or jest, mocha, etc.

test('Basic ETH transfer', async () => {
  // Create a new node instance
  const node = createTevmNode({
    miningConfig: { type: 'auto' }, // Mine blocks automatically
  })
  await node.ready()

  const vm = await node.getVm()

  // Create and run a transaction
  const tx = createImpersonatedTx({
    from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    value: 1000000000000000000n, // 1 ETH
  })

  const result = await vm.runTx({ tx })

  // Assert transaction succeeded
  expect(result.execResult.exceptionError).toBeUndefined()

  // Check recipient balance
  const account = await vm.stateManager.getAccount(tx.to)
  expect(account.balance).toBe(1000000000000000000n)
})
```

For more information on transaction execution, see the [EVM Execution Model](https://ethereum.org/en/developers/docs/evm/execution/).

### Contract Testing

#### 1. Deployment & Interaction

For background on contract deployment and interaction, see the [Contract Deployment Guide](https://ethereum.org/en/developers/docs/smart-contracts/deploying/).

```ts
import { Contract } from 'tevm/contract'
import { bytecode, abi } from './MyContract.json'

test('Deploy and interact with contract', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Deploy contract
  const deployTx = createImpersonatedTx({
    data: bytecode,
  })

  const result = await vm.runTx({ tx: deployTx })
  expect(result.execResult.exceptionError).toBeUndefined()

  const contractAddress = result.createdAddress
  expect(contractAddress).toBeDefined()

  // Create contract instance
  const contract = new Contract(contractAddress, abi)

  // Call contract method
  const callResult = await contract.read.getValue()
  expect(callResult).toBe(expectedValue)

  // Send transaction to contract
  const tx = await contract.write.setValue([newValue])
  const txResult = await vm.runTx({ tx })
  expect(txResult.execResult.exceptionError).toBeUndefined()

  // Verify state change
  const updatedValue = await contract.read.getValue()
  expect(updatedValue).toBe(newValue)
})
```

#### 2. Event Testing

For more information on events and logs, see the [Events and Logs Guide](https://ethereum.org/en/developers/docs/smart-contracts/anatomy/#events-and-logs).

```ts
test('Contract events', async () => {
  const node = createTevmNode()
  await node.ready()

  // Deploy contract
  const contract = await deployContract(node)

  // Create event filter
  node.setFilter({
    id: '0x1',
    address: contract.address,
    topics: [
      contract.interface.getEventTopic('ValueChanged'),
    ],
  })

  // Trigger event
  const tx = await contract.write.setValue([123])
  await vm.runTx({ tx })

  // Get event logs
  const receipts = await node.getReceiptsManager()
  const logs = await receipts.getLogs({
    fromBlock: 0n,
    toBlock: 'latest',
    address: contract.address,
  })

  expect(logs.length).toBe(1)
  expect(logs[0].topics[0]).toBe(contract.interface.getEventTopic('ValueChanged'))
})
```

### Complex Testing Scenarios

#### 1. State Management

For more information on state management, see the [Ethereum State Guide](https://ethereum.org/en/developers/docs/evm/state-machine/).

```ts
test('Complex state changes', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Create checkpoint
  await vm.stateManager.checkpoint()

  try {
    // Perform multiple state changes
    await performStateChanges(vm)

    // Verify intermediate state
    const intermediateState = await getState(vm)
    expect(intermediateState).toMatchSnapshot()

    // More changes
    await performMoreChanges(vm)

    // Commit changes
    await vm.stateManager.commit()
  } catch (error) {
    // Revert on failure
    await vm.stateManager.revert()
    throw error
  }
})
```

#### 2. Fork Testing

For more information on network forking, see the [Forking Guide](../core/forking).

```ts
test('Mainnet fork testing', async () => {
  const node = createTevmNode({
    fork: {
      transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      blockTag: 17_000_000n,
    },
  })
  await node.ready()

  // Impersonate a whale account
  node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

  // Test DeFi interactions
  const uniswap = new Contract(UNISWAP_ADDRESS, UNISWAP_ABI)
  const tx = await uniswap.write.swapExactTokensForTokens([/* ... */])

  const result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

#### 3. Time-based Testing

For more information on block timestamps and time-based operations, see the [Block Time Guide](https://ethereum.org/en/developers/docs/blocks/blocks-and-time/).

```ts
test('Time-dependent behavior', async () => {
  const node = createTevmNode({
    miningConfig: { type: 'interval', interval: 1000 },
  })
  await node.ready()
  const vm = await node.getVm()

  // Deploy time-locked contract
  const contract = await deployTimeLock(vm)

  // Try to withdraw (should fail)
  let tx = await contract.write.withdraw()
  let result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeDefined()

  // Advance time by mining blocks
  for (let i = 0; i < 100; i++) {
    await vm.blockchain.putBlock(createBlock({ timestamp: Date.now() + i * 1000 }))
  }

  // Try withdraw again (should succeed)
  tx = await contract.write.withdraw()
  result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

### Testing Utilities

#### 1. Account Management

For more information on Ethereum accounts, see the [Accounts Guide](https://ethereum.org/en/developers/docs/accounts/).

```ts
// Helper to setup test accounts
async function setupAccounts(vm) {
  const accounts = [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  ]

  for (const address of accounts) {
    await vm.stateManager.putAccount(address, {
      nonce: 0n,
      balance: 10000000000000000000n, // 10 ETH
    })
  }

  return accounts
}
```

#### 2. Transaction Helpers

For more information on transaction types and formats, see the [Transaction Types Guide](https://ethereum.org/en/developers/docs/transactions/transaction-types/).

```ts
// Helper to send ETH
async function sendEth(vm, from, to, value) {
  const tx = createImpersonatedTx({
    from,
    to,
    value,
  })

  return vm.runTx({ tx })
}

// Helper to deploy contract
async function deployContract(vm, bytecode, args = []) {
  const tx = createImpersonatedTx({
    data: bytecode + encodeConstructor(args),
  })

  const result = await vm.runTx({ tx })
  return result.createdAddress
}
```

### Related Topics

* [Viem Testing Guide](https://viem.sh/docs/testing/overview.html)
* [EthereumJS VM](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/vm)
* [JSON-RPC Methods](../api/json-rpc)
* [Contract API](../api/contracts)
* [State Management](../core/managing-state)

### Replaying Contracts with Shadow Events

```ts
import { createTevmNode } from 'tevm/node'
import { http } from 'viem'

// Create a node that forks from mainnet
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Get the transaction receipt to find its index
const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: ['0x...'] // Original tx hash
})

// Get the block and its transactions
const block = await node.request({
  method: 'eth_getBlockByNumber',
  params: [(receipt.blockNumber - 1n).toString(16), true]
})

// Replay all transactions before our target tx
for (let i = 0; i < receipt.transactionIndex; i++) {
  const tx = block.transactions[i]
  await node.getVm().runTx({ tx })
}

// Deploy modified contract with new event
const modifiedBytecode = '0x...' // Contract bytecode with new event
await node.setAccount({
  address: receipt.contractAddress,
  deployedBytecode: modifiedBytecode
})

// Now run the target transaction
const result = await node.getVm().runTx({
  tx: block.transactions[receipt.transactionIndex]
})

// The result will include the new shadow event
console.log(result.execResult.logs)
```

### Estimating Gas for Token Approval

```ts
import { createTevmNode } from 'tevm/node'
import { encodeFunctionData } from 'viem'

const node = createTevmNode()
const vm = await node.getVm()

// First approve the token
const approveTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'approve',
    args: [spenderAddress, amount]
  })
}

// Estimate gas by running the tx
const result = await vm.runTx({ tx: approveTx })
console.log('Gas used:', result.execResult.executionGasUsed)

// Now we can estimate transferFrom
const transferFromTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'transferFrom',
    args: [ownerAddress, recipientAddress, amount]
  })
}

const transferResult = await vm.runTx({ tx: transferFromTx })
console.log('TransferFrom gas:', transferResult.execResult.executionGasUsed)
```


## Using with Viem

This guide demonstrates how to use Tevm Node with Viem, enabling seamless integration with Viem's powerful Ethereum development tools.

### Basic Setup

```ts
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'
import { createPublicClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Viem client
const client = createPublicClient({
  chain: mainnet,
  transport: custom(node.request),
})

// Now viemClient can do e.g. getBalance, readContract, etc,
// all fully in memory or forking from node if you configured it
```

### Reading Blockchain State

#### 1. Basic State Queries

```ts
// Get latest block
const block = await client.getBlock()

// Get balance
const balance = await client.getBalance({
  address: '0x1234...',
})

// Get transaction count
const nonce = await client.getTransactionCount({
  address: '0x1234...',
})
```

#### 2. Contract Reading

```ts
import { parseAbi } from 'viem'

const abi = parseAbi([
  'function balanceOf(address) view returns (uint256)',
  'function symbol() view returns (string)',
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])

// Read token data
const tokenContract = {
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
  abi,
}

const [balance, symbol] = await Promise.all([
  client.readContract({
    ...tokenContract,
    functionName: 'balanceOf',
    args: ['0x1234...'],
  }),
  client.readContract({
    ...tokenContract,
    functionName: 'symbol',
  }),
])

console.log(`${symbol} Balance:`, balance)
```

### Writing to the Blockchain

#### 1. Transaction Simulation

```ts
// Simulate contract interaction
const { request } = await client.simulateContract({
  address: contractAddress,
  abi,
  functionName: 'transfer',
  args: ['0x1234...', 1000000n],
})

// Execute the transaction
const hash = await client.writeContract(request)

// Wait for confirmation
const receipt = await client.waitForTransactionReceipt({ hash })
```

#### 2. Raw Transactions

```ts
// Send ETH
const hash = await client.sendTransaction({
  to: '0x1234...',
  value: parseEther('1'),
})

// Send raw transaction
const hash2 = await client.sendRawTransaction({
  serializedTransaction: '0x...',
})
```

### Event Handling

#### 1. Reading Past Events

```ts
// Get all Transfer events
const logs = await client.getLogs({
  address: tokenAddress,
  event: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
  fromBlock: 0n,
  toBlock: 'latest',
})

for (const log of logs) {
  console.log('Transfer:', {
    from: log.args.from,
    to: log.args.to,
    value: log.args.value,
  })
}
```

#### 2. Event Filtering

```ts
// Create filter for new transfers
const filter = await client.createEventFilter({
  address: tokenAddress,
  event: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
})

// Get filter changes
const newEvents = await client.getFilterChanges({ filter })
```

### Advanced Usage

#### 1. Multiple Contract Interactions

```ts
// Batch contract reads
const results = await Promise.all([
  client.readContract({
    address: token1Address,
    abi: TOKEN_ABI,
    functionName: 'balanceOf',
    args: [address],
  }),
  client.readContract({
    address: token2Address,
    abi: TOKEN_ABI,
    functionName: 'balanceOf',
    args: [address],
  }),
])

// Multicall
const multicallResult = await client.multicall({
  contracts: [
    {
      address: token1Address,
      abi: TOKEN_ABI,
      functionName: 'balanceOf',
      args: [address],
    },
    {
      address: token2Address,
      abi: TOKEN_ABI,
      functionName: 'balanceOf',
      args: [address],
    },
  ],
})
```

#### 2. Contract Deployment

```ts
// Deploy contract
const hash = await client.deployContract({
  abi,
  bytecode,
  args: [constructorArg1, constructorArg2],
})

// Get contract address
const receipt = await client.waitForTransactionReceipt({ hash })
const contractAddress = receipt.contractAddress
```

#### 3. Gas Estimation

```ts
// Estimate gas for contract deployment
const gas = await client.estimateContractGas({
  abi,
  bytecode,
  args: [constructorArg1, constructorArg2],
})

// Estimate gas for contract call
const gas2 = await client.estimateContractGas({
  address: contractAddress,
  abi,
  functionName: 'transfer',
  args: ['0x1234...', 1000000n],
})
```

### Testing with Viem

```ts
import { expect, test } from 'vitest'

test('Contract interaction', async () => {
  // Setup Tevm Node
  const node = createTevmNode()
  const client = createPublicClient({
    chain: mainnet,
    transport: custom(node.request),
  })

  // Deploy contract
  const hash = await client.deployContract({
    abi,
    bytecode,
  })
  const receipt = await client.waitForTransactionReceipt({ hash })
  const contractAddress = receipt.contractAddress

  // Test contract
  const result = await client.readContract({
    address: contractAddress,
    abi,
    functionName: 'getValue',
  })

  expect(result).toBe(expectedValue)
})
```

### Best Practices

1. **Error Handling**:
   ```ts
   try {
     const result = await client.readContract({
       address,
       abi,
       functionName: 'riskyFunction',
     })
   } catch (error) {
     if (error.message.includes('revert')) {
       // Handle contract revert
     }
     throw error
   }
   ```

2. **Gas Management**:
   ```ts
   // Always estimate gas before sending transactions
   const gas = await client.estimateContractGas({
     address,
     abi,
     functionName: 'transfer',
     args: [to, amount],
   })

   const hash = await client.writeContract({
     address,
     abi,
     functionName: 'transfer',
     args: [to, amount],
     gas: gas * 120n / 100n, // Add 20% buffer
   })
   ```

3. **Transaction Confirmation**:
   ```ts
   // Wait for sufficient confirmations
   const receipt = await client.waitForTransactionReceipt({
     hash,
     confirmations: 2,
     timeout: 60_000,
   })
   ```

4. **Resource Cleanup**:
   ```ts
   // Clean up filters when done
   const filter = await client.createEventFilter({
     address,
     event: parseAbi(['event Transfer(...)']),
   })

   try {
     // Use filter
   } finally {
     await client.uninstallFilter({ filter })
   }
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [Local Testing](./local-testing)
* [Forking Mainnet](./forking-mainnet)

