# Tevm Node

> A lightweight, unopinionated, powerful EVM node that runs in the browser

## Custom Precompiles

[Tevm Node](https://github.com/evmts/tevm-monorepo) allows you to extend the [EVM](https://ethereum.org/en/developers/docs/evm/) with custom [precompiled contracts](https://ethereum.org/en/developers/docs/evm/precompiles/) written in JavaScript. These precompiles can provide native functionality at specific addresses, similar to [Ethereum's built-in precompiles](https://www.evm.codes/precompiled).

### Using tevm/precompiles

The `tevm/precompiles` package provides utilities for creating type-safe precompiles from contract [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html):

```ts
import { createTevmNode, definePrecompile } from 'tevm'
import { createAddress } from 'tevm/address'
import { createContract } from 'tevm/contract'
import { parseAbi } from 'tevm/utils'
import { createImpersonatedTx } from 'tevm/tx'
import { EvmError, EvmErrorMessage } from 'tevm/evm'

// Create a basic precompile
const customPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function double(bytes) returns (bytes)']),
    address: '0x0000000000000000000000000000000000000123'
  }),
  call: async ({ data }) => {
    // Simple precompile that doubles each byte
    const input = Array.from(data)
    return {
      returnValue: new Uint8Array(input.map(byte => Number(byte) * 2)),
      executionGasUsed: 200n,
    }
  },
})

// Create node with precompile
const node = createTevmNode({
  customPrecompiles: [customPrecompile.precompile()],
})

// Create a transaction to interact with the precompile
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: customPrecompile.contract.address,
  data: '0x00',
  gasLimit: 21000n,
})

// Execute the transaction
const vm = await node.getVm()
const result = await vm.runTx({ tx })
```

### Basic Usage

Here's a simple example of creating and using a precompile:

```ts
import { createTevmNode, definePrecompile } from 'tevm'
import { createAddress } from 'tevm/address'
import { createContract } from 'tevm/contract'
import { parseAbi } from 'tevm/utils'
import { createImpersonatedTx } from 'tevm/tx'
import { EvmError, EvmErrorMessage } from 'tevm/evm'

const myPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes) returns (bytes)']),
    address: '0x0000000000000000000000000000000000000123'
  }),
  call: async ({ data, gasLimit }) => {
    const executionGasUsed = 200n
    if (gasLimit <= executionGasUsed) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    // Process input data
    const processedData = data
    return {
      returnValue: new Uint8Array([...processedData]),
      executionGasUsed,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile.precompile()],
})
```

### Precompile Interface

```ts
interface PrecompileInput {
  data: Uint8Array
  gasLimit: bigint
}

interface PrecompileOutput {
  returnValue: Uint8Array
  executionGasUsed: bigint
}

interface PrecompileContract {
  contract: Contract
  call: (input: PrecompileInput) => Promise<PrecompileOutput>
}
```

### Example Implementations

#### 1. State Access Precompile

```ts
const statePrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function store(bytes32,bytes32)']),
    address: '0x0000000000000000000000000000000000000124'
  }),
  call: async ({ data, gasLimit }) => {
    const key = data.slice(0, 32)
    const value = data.slice(32)
    const vm = await node.getVm()
    await vm.stateManager.putContractStorage(
      createAddress(statePrecompile.contract.address),
      hexToBytes(key),
      hexToBytes(value)
    )
    const executionGasUsed = 200n
    if (gasLimit <= executionGasUsed) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed,
    }
  },
})
```

#### 2. Gas Calculation Precompile

```ts
const gasPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processWithGas(bytes)']),
    address: '0x0000000000000000000000000000000000000125'
  }),
  call: async ({ data, gasLimit }) => {
    // Charge 100 gas per byte
    const gasUsed = BigInt(data.length * 100)
    if (gasUsed > gasLimit) {
      throw new Error('Out of gas')
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed: gasUsed,
    }
  },
})
```

#### 3. Error Handling Precompile

```ts
const errorPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process()']),
    address: '0x0000000000000000000000000000000000000126'
  }),
  call: async ({ data }) => {
    if (data.length === 0) {
      throw new Error('Empty input not allowed')
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed: 200n,
    }
  },
})
```

#### 4. Multiple Precompiles

```ts
const precompileA = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processA() returns (bytes)']),
    address: '0x0000000000000000000000000000000000000127'
  }),
  call: async () => ({
    returnValue: new Uint8Array([1]),
    executionGasUsed: 200n,
  }),
})

const precompileB = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processB() returns (bytes)']),
    address: '0x0000000000000000000000000000000000000128'
  }),
  call: async () => ({
    returnValue: new Uint8Array([2]),
    executionGasUsed: 200n,
  }),
})

const node = createTevmNode({
  customPrecompiles: [precompileA.precompile(), precompileB.precompile()],
})
```

### Best Practices

1. **Gas Calculation**:
   * Always calculate gas based on input size or operations performed
   * Check against provided gas limit
   * Return accurate gas usage and proper error types

```ts
const precompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes)']),
    address: createAddress('0x0000000000000000000000000000000000000123')
  }),
  call: async ({ data, gasLimit }) => {
    const gasPerByte = 100n
    const gasUsed = BigInt(data.length) * gasPerByte
    if (gasUsed > gasLimit) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    return {
      returnValue: processData(data),
      executionGasUsed: gasUsed,
    }
  },
})
```

2. **Error Handling**:
   * Use proper EvmError types for EVM-specific errors
   * Check input validity
   * Handle gas limits properly

```ts
const precompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes)']),
    address: createAddress('0x0000000000000000000000000000000000000123')
  }),
  call: async ({ data, gasLimit }) => {
    try {
      if (data.length === 0) {
        throw new Error('Empty input not allowed')
      }
      const executionGasUsed = 200n
      if (gasLimit <= executionGasUsed) {
        return {
          returnValue: new Uint8Array(),
          exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
          executionGasUsed: gasLimit,
        }
      }
      // Process data
      return {
        returnValue: processData(data),
        executionGasUsed,
      }
    } catch (error) {
      throw new Error(`Precompile error: ${error.message}`)
    }
  },
})
```

3. **State Management**:
   * Use VM state manager for persistent storage
   * Handle state access errors
   * Clean up resources when needed

### Related Topics

* [contract reference](/reference/contract)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)
* [EVM Opcodes Reference](https://www.evm.codes/)
* [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
* [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)


## Performance & Profiler

Tevm Node includes a built-in performance profiler that helps you analyze EVM execution, identify bottlenecks, and optimize your smart contracts.

### Enabling the Profiler

Enable profiling when creating your node:

```ts
import { createTevmNode } from 'tevm'

const node = createTevmNode({
  profiler: {
    enabled: true,
    // Optional: Configure profiling options
    includeOpcodes: true,
    includePrecompiles: true,
  },
})
```

### Collecting Performance Data

```ts
const vm = await node.getVm()

// Execute some transactions
await vm.runTx({ /* ... */ })

// Get performance logs
const logs = vm.evm.getPerformanceLogs()

// Clear logs when done
vm.evm.clearPerformanceLogs()
```

### Log Types

The profiler collects various types of performance data:

```ts
interface PerformanceLog {
  type: 'opcode' | 'precompile' | 'call' | 'create'
  startTime: number
  endTime: number
  executionTime: number
  gasUsed?: bigint
  // Additional data based on type
}

interface OpcodeLog extends PerformanceLog {
  type: 'opcode'
  opcode: string
  pc: number
}

interface PrecompileLog extends PerformanceLog {
  type: 'precompile'
  address: string
  name: string
}
```

### Analyzing Performance

#### 1. Opcode Analysis

```ts
// Group by opcode
const opcodeStats = logs
  .filter(log => log.type === 'opcode')
  .reduce((acc, log) => {
    const key = log.opcode
    acc[key] = acc[key] || { count: 0, totalTime: 0, totalGas: 0n }
    acc[key].count++
    acc[key].totalTime += log.executionTime
    acc[key].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Find expensive operations
const expensiveOps = Object.entries(opcodeStats)
  .sort(([, a], [, b]) => b.totalTime - a.totalTime)
  .slice(0, 10)

console.log('Most expensive operations:', expensiveOps)
```

#### 2. Call Tree Analysis

```ts
// Analyze call depth and patterns
const callTree = logs
  .filter(log => log.type === 'call')
  .map(log => ({
    from: log.from,
    to: log.to,
    value: log.value,
    executionTime: log.executionTime,
    gasUsed: log.gasUsed,
  }))

console.log('Call tree:', callTree)
```

#### 3. Gas Usage Patterns

```ts
// Track gas usage over time
const gasTimeline = logs
  .filter(log => log.gasUsed !== undefined)
  .map(log => ({
    timestamp: log.startTime,
    gasUsed: log.gasUsed,
    type: log.type,
  }))

// Calculate gas efficiency
const gasEfficiency = gasTimeline.reduce((acc, log) => {
  acc.totalGas += log.gasUsed ?? 0n
  acc.totalTime += log.executionTime
  return acc
}, { totalGas: 0n, totalTime: 0 })
```

### Use Cases

#### 1. Contract Optimization

```ts
// Deploy and profile contract
const vm = await node.getVm()
await vm.runTx({ tx: deployTx })

// Clear previous logs
vm.evm.clearPerformanceLogs()

// Profile specific function
await vm.runTx({ tx: functionCallTx })
const logs = vm.evm.getPerformanceLogs()

// Analyze performance
const functionProfile = analyzeLogs(logs)
console.log('Function performance:', {
  totalTime: functionProfile.executionTime,
  gasUsed: functionProfile.gasUsed,
  hotspots: functionProfile.hotspots,
})
```

#### 2. Comparative Analysis

```ts
async function compareImplementations(implementations: string[]) {
  const results = []
  const vm = await node.getVm()

  for (const impl of implementations) {
    vm.evm.clearPerformanceLogs()
    await vm.runTx({ tx: createCallTx(impl) })
    const logs = vm.evm.getPerformanceLogs()
    results.push(analyzePerformance(logs))
  }

  return compareResults(results)
}
```

#### 3. Gas Optimization

```ts
// Track gas usage by contract
const contractGasUsage = logs
  .filter(log => log.type === 'call')
  .reduce((acc, log) => {
    const contract = log.to
    acc[contract] = acc[contract] || { calls: 0, totalGas: 0n }
    acc[contract].calls++
    acc[contract].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Identify gas-intensive contracts
const gasHotspots = Object.entries(contractGasUsage)
  .sort(([, a], [, b]) => Number(b.totalGas - a.totalGas))
```

### Best Practices

1. **Targeted Profiling**:
   ```ts
   // Clear logs before specific operations
   vm.evm.clearPerformanceLogs()
   // Run the operation you want to profile
   await vm.runTx({ /* ... */ })
   // Analyze just that operation
   const logs = vm.evm.getPerformanceLogs()
   ```

2. **Memory Management**:
   * Clear logs periodically
   * Profile specific operations rather than entire sessions
   * Export and analyze large datasets externally

3. **Comparative Analysis**:
   ```ts
   // Compare before/after optimization
   const beforeLogs = await profileOperation(originalCode)
   const afterLogs = await profileOperation(optimizedCode)
   const improvement = compareProfiles(beforeLogs, afterLogs)
   ```

4. **Production Considerations**:
   * Disable profiler in production
   * Use sampling for long-running operations
   * Consider the overhead of profiling itself

### Related Topics

* [VM & Submodules](../api/vm-and-submodules)
* [Gas Estimation](../api/methods)
* [Transaction Pool](./txpool)


## Receipts & Logs

Tevm Node provides robust support for managing transaction receipts and event logs through the ReceiptsManager module and filter system.

### Receipt Management

The ReceiptsManager maintains an index of all transaction receipts and their associated logs.

```ts
import { createTevmNode } from 'tevm'
import { createImpersonatedTx } from 'tevm/tx'
import { runTx } from 'tevm/vm'
import { createAddress, hexToBytes } from 'tevm/utils'

const node = createTevmNode()
const receiptsManager = await node.getReceiptsManager()

// Execute a transaction and get receipt
const vm = await node.getVm()
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: createAddress('0x2345678901234567890123456789012345678901'),
  value: 1000000000000000000n,
  gasLimit: 21000n,
})

const result = await runTx(vm)({ tx })
const receiptResult = await receiptsManager.getReceiptByTxHash(tx.hash())

if (receiptResult) {
  const [receipt, blockHash, txIndex, logIndex] = receiptResult
  // Access receipt data
  console.log({
    status: 'status' in receipt ? receipt.status : undefined,
    gasUsed: receipt.cumulativeBlockGasUsed,
    logs: receipt.logs
  })
}
```

#### Receipt Types

Tevm supports different receipt types based on the Ethereum hardfork:

```ts
interface PreByzantiumReceipt {
  stateRoot: Uint8Array
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface PostByzantiumReceipt {
  status: number // 1 for success, 0 for failure
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface EIP4844Receipt extends PostByzantiumReceipt {
  blobGasUsed: bigint
  blobGasPrice: bigint
}
```

### Event Logs

#### Contract Deployment and Event Emission

Here's how to deploy a contract and capture its events:

```ts
// Deploy contract
const deployTx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  data: CONTRACT_BYTECODE,
  gasLimit: 1000000n,
})

const vm = await node.getVm()
const deployResult = await runTx(vm)({ tx: deployTx })
const contractAddress = deployResult.createdAddress
if (!contractAddress) throw new Error('Contract deployment failed')

// Interact with contract to emit events
const interactTx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: contractAddress,
  data: EMIT_EVENT_SELECTOR, // Function selector that emits events
  gasLimit: 100000n,
})

await runTx(vm)({ tx: interactTx })
```

#### Querying Logs

The ReceiptsManager provides flexible log querying with multiple filter options:

```ts
// Get blocks for filtering
const fromBlock = await vm.blockchain.getBlockByTag('earliest')
const toBlock = await vm.blockchain.getBlockByTag('latest')

// Filter by contract address
const addressLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  [contractAddress.toBytes()],
  undefined
)

// Filter by event topic
const eventTopic = hexToBytes('0x000000000000000000000000000000000000000000000000000000000000abcd')
const topicLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  undefined,
  [eventTopic]
)

// Filter by both address and topic
const combinedLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  [contractAddress.toBytes()],
  [eventTopic]
)
```

#### Error Handling

The ReceiptsManager includes robust error handling:

```ts
// Handle non-existent receipts
const nonExistentHash = hexToBytes('0x1234567890123456789012345678901234567890123456789012345678901234')
const receipt = await receiptsManager.getReceiptByTxHash(nonExistentHash)
if (receipt === null) {
  console.log('Receipt not found')
}

// Handle invalid log filters
const invalidAddress = hexToBytes('0x0000')
const logs = await receiptsManager.getLogs(fromBlock, toBlock, [invalidAddress], undefined)
if (logs.length === 0) {
  console.log('No logs found for invalid address')
}
```

### Performance Considerations

The ReceiptsManager includes built-in limits to prevent excessive resource usage:

```ts
// Log query limits
const GET_LOGS_LIMIT = 10000 // Maximum number of logs
const GET_LOGS_LIMIT_MEGABYTES = 150 // Maximum response size
const GET_LOGS_BLOCK_RANGE_LIMIT = 2500 // Maximum block range
```

#### Best Practices

1. **Efficient Log Queries**:
   * Use specific address and topic filters
   * Limit block ranges for large queries
   * Handle null results appropriately

2. **Receipt Storage**:
   * Always check for null/undefined results
   * Handle receipt pruning gracefully
   * Verify contract deployment success

3. **Type Safety**:
   ```ts
   // Ensure contract deployment success
   const contractAddress = deployResult.createdAddress
   if (!contractAddress) throw new Error('Contract deployment failed')

   // Handle receipt types
   if (receiptResult) {
     const [receipt] = receiptResult
     if ('status' in receipt) {
       console.log(`Transaction ${receipt.status === 1 ? 'succeeded' : 'failed'}`)
     }
   }
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Transaction Pool](./txpool)


## Transaction Pool

The Transaction Pool (TxPool) is a crucial component that manages pending transactions before they're included in blocks. It handles transaction ordering, replacement, validation, and lifecycle management.

### Quick Start

```ts
import { createTevmNode } from 'tevm'
import { createAddress } from 'tevm/address'
import { createImpersonatedTx } from 'tevm/tx'

// Initialize node and get txpool
const node = createTevmNode()
const txPool = await node.getTxPool()

// Create and add a transaction
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234...'),
  to: createAddress('0x2345...'),
  value: 1000000000000000000n, // 1 ETH
  gasLimit: 21000n,
  maxFeePerGas: 20000000000n,
  maxPriorityFeePerGas: 20000000000n,
  nonce: 0n,
})

await txPool.addUnverified(tx)
```

### Key Features

* 🔍 **Transaction Validation** - Comprehensive validation including nonce, balance, and gas checks
* 🔄 **Transaction Replacement** - Replace pending transactions with higher gas price versions
* 📊 **Nonce Ordering** - Maintains correct transaction sequence per account
* 🧹 **Automatic Pruning** - Removes old transactions to prevent memory bloat
* ⚡ **Performance Optimized** - Efficient handling of large transaction volumes

### Core Concepts

#### Pool Limits

The TxPool enforces several limits to ensure stable operation:

```ts
const LIMITS = {
  MAX_POOL_SIZE: 5000,           // Maximum total transactions
  MAX_TXS_PER_ACCOUNT: 100,      // Maximum per account
  MIN_GAS_PRICE: 100000000n,     // 0.1 GWei minimum
  TX_MAX_DATA_SIZE: 128 * 1024,  // 128KB max transaction size
}
```

#### Transaction Lifecycle

1. **Addition** - Transactions enter the pool via `add()` or `addUnverified()`
2. **Validation** - Optional checks for nonce, balance, and gas parameters
3. **Storage** - Valid transactions are stored and ordered by nonce
4. **Pruning** - Old transactions are removed after `POOLED_STORAGE_TIME_LIMIT` (20 minutes)

### Detailed Usage

#### Adding Transactions

Two methods for adding transactions, each with different validation levels:

```ts
// Method 1: With full validation
try {
  await txPool.add(tx)
} catch (error) {
  if (error.message.includes('insufficient balance')) {
    console.error('Account has insufficient funds')
  }
}

// Method 2: Without validation (faster)
await txPool.addUnverified(tx)
```

#### Transaction Replacement

Replace a pending transaction by submitting a new one with the same nonce and higher gas price:

```ts
const originalTx = createImpersonatedTx({
  // ... base transaction params ...
  maxFeePerGas: 20000000000n,
  nonce: 0n,
})

const replacementTx = createImpersonatedTx({
  // ... same params as original ...
  maxFeePerGas: 30000000000n, // At least 10% higher
  nonce: 0n, // Same nonce as original
})

await txPool.addUnverified(originalTx)
await txPool.addUnverified(replacementTx) // Replaces originalTx
```

> **Note**: Replacement transactions must increase gas price by at least `MIN_GAS_PRICE_BUMP_PERCENT` (10%)

#### Querying Transactions

```ts
// Get transactions by sender
const senderTxs = await txPool.getBySenderAddress(senderAddress)

// Get transactions by hash
const txHashes = [hash1, hash2]
const specificTxs = txPool.getByHash(txHashes)

// Get ordered transactions for mining
const orderedTxs = await txPool.txsByPriceAndNonce({
  baseFee: currentBaseFee,
  allowedBlobs: 6, // For EIP-4844
})
```

#### Block Processing

When new blocks are added, update the pool:

```ts
import { mineHandler } from 'tevm/actions'

// Mine new blocks
await mineHandler(node)()

// Remove included transactions
txPool.removeNewBlockTxs(newBlocks)
```

### Advanced Features

#### Pool Management

```ts
// Start transaction processing
txPool.start()

// Stop processing (but keep transactions)
txPool.stop()

// Clear all transactions
txPool.close()

// Manual cleanup of old transactions
txPool.cleanup()
```

#### Transaction Types

The pool supports all Ethereum transaction types:

* Legacy Transactions
* EIP-2930 (Access Lists)
* EIP-1559 (Fee Market)
* EIP-4844 (Blob Transactions)
* Tevm Impersonated Transactions

### Best Practices

#### 1. Transaction Creation

Always use `createImpersonatedTx` with proper types:

```ts
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress(address),
  to: createAddress(recipient),
  value: parseEther('1'), // Use helper functions for values
  gasLimit: 21000n,
  maxFeePerGas: gweiToWei('20'),
  maxPriorityFeePerGas: gweiToWei('2'),
  nonce: 0n,
})
```

#### 2. Error Handling

Implement comprehensive error handling:

```ts
try {
  await txPool.add(tx)
} catch (error) {
  switch (true) {
    case error.message.includes('insufficient balance'):
      // Handle balance error
      break
    case error.message.includes('nonce too low'):
      // Handle nonce error
      break
    case error.message.includes('gas price too low'):
      // Handle gas price error
      break
    default:
      // Handle unknown errors
  }
}
```

#### 3. Performance Optimization

* Use `addUnverified` for bulk operations
* Implement proper cleanup cycles
* Monitor pool size and transaction age

#### 4. Memory Management

```ts
// Regular cleanup cycle
setInterval(() => {
  txPool.cleanup()
}, 5 * 60 * 1000) // Every 5 minutes

// Monitor pool size
const poolSize = txPool.txsInPool
if (poolSize > MAX_POOL_SIZE * 0.8) {
  console.warn('Pool approaching capacity')
}
```

### API Reference

#### TxPool Class

```ts
class TxPool {
  constructor(options: { vm: Vm })
  async add(tx: Transaction): Promise<void>
  async addUnverified(tx: Transaction): Promise<void>
  async getBySenderAddress(address: Address): Promise<TxPoolObject[]>
  getByHash(hashes: Uint8Array[]): Transaction[]
  removeByHash(hash: string): void
  removeNewBlockTxs(blocks: Block[]): void
  start(): boolean
  stop(): boolean
  cleanup(): void
  close(): void
}
```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Receipts & Logs](./receipts-and-logs)


import { Callout, Steps, Step } from 'vocs/components'

## Creating a Tevm Node

`createTevmNode` is the main entry point for spinning up a local Tevm Node instance. It provides a flexible configuration API to customize your node's behavior for different use cases.

<Steps>
  <Step title="Install Dependencies">
    First, install the required packages:

    ```bash
    npm install tevm
    ```
  </Step>

  <Step title="Create Node Instance">
    Create a basic node instance:

    #### TypeScript

    ```ts
    import { createTevmNode } from 'tevm'

    const node = createTevmNode()
    await node.ready()
    ```

    #### JavaScript

    ```js
    const { createTevmNode } = require('tevm')

    const node = createTevmNode()
    await node.ready()
    ```
  </Step>

  <Step title="Configure Options">
    Customize the node based on your needs:

    ```ts
    const node = createTevmNode({
      fork: {
        transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      },
      miningConfig: { type: 'auto' },
      loggingLevel: 'debug'
    })
    ```
  </Step>
</Steps>

### Configuration Options

#### Fork Configuration

The `fork` option allows you to create a node that forks from an existing network:

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    // Use any EIP-1193 compatible provider
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    // Optional: Fork from a specific block
    blockTag: 17_000_000n,
  },
})
```

<Callout type="info">
  When forking, state is fetched lazily from the remote provider and cached locally. This means your first access to any account or storage slot will be slower, but subsequent accesses will be fast.
</Callout>

#### Mining Configuration

Control how and when blocks are produced:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto', // Mine a block for every transaction
  },
})

// Or use interval-based mining
const node2 = createTevmNode({
  miningConfig: {
    type: 'interval',
    interval: 12_000, // Mine every 12 seconds
  },
})
```

#### Chain Configuration

Customize the chain parameters:

```ts
import { Common } from 'tevm/common'

const node = createTevmNode({
  common: Common.custom({
    chainId: 1337,
    networkId: 1337,
    // ... other chain parameters
  }),
})
```

Or if your network is a known network import it by name

```ts
import { mainnet, base, arbitrum, optimism } from 'tevm/common'
```

If you want your network added you should first add it to `viem/chains` and open an issue to regenerate the commons in Tevm

#### Logging Configuration

Configure the internal logger:

```ts
const node = createTevmNode({
  loggingLevel: 'debug', // 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace'
})

// Later use the logger
node.logger.debug('Detailed debugging information')
```

#### Custom Precompiles

Add your own precompiled contracts:

```ts
import { definePrecompile, createContract, parseAbi } from 'tevm'

const myPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi([
      'function add(uint256 a, uint256 b) returns (uint256)',
      'function subtract(uint256 a, uint256 b) returns (uint256)'
    ]),
    address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'
  }),
  call: async ({ data, gasLimit }) => {
    // Your precompile logic here
    return {
      returnValue: new Uint8Array([0x01]),
      executionGasUsed: 200n,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile.precompile()],
})
```

#### Performance Profiling

Enable the built-in profiler for performance analysis:

```ts
const node = createTevmNode({
  profiler: true,
})

// Later access profiling data
const vm = await node.getVm()
const logs = vm.evm.getPerformanceLogs()
```

### Complete Configuration Reference

| Property                     | Type                                                           | Default            | Description                                                  |
| ---------------------------- | -------------------------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| `fork`                       | `{ transport: EIP1193RequestFn; blockTag?: BlockTag; }`        | -                  | Enables forking from a live network or another Tevm instance |
| `common`                     | `Common`                                                       | `tevmDevnet`       | Chain configuration object                                   |
| `loggingLevel`               | `"fatal" \| "error" \| "warn" \| "info" \| "debug" \| "trace"` | `"info"`           | Logging verbosity level                                      |
| `miningConfig`               | `{ type: 'auto' } \| { type: 'interval', interval: number }`   | `{ type: 'auto' }` | Block mining behavior                                        |
| `profiler`                   | `boolean`                                                      | `false`            | Enables performance logging                                  |
| `customPrecompiles`          | `Precompile[]`                                                 | `[]`               | Additional precompiled contracts                             |
| `allowUnlimitedContractSize` | `boolean`                                                      | `false`            | Disables EIP-170 contract size checks                        |

### Best Practices

1. **Always await node.ready()**
   ```ts
   const node = createTevmNode()
   await node.ready() // Ensure node is fully initialized
   ```

2. **Use Appropriate Mining Config**
   ```ts
   // For testing - mine after each transaction
   const testNode = createTevmNode({
     miningConfig: { type: 'auto' }
   })

   // For simulation - mine at intervals
   const simNode = createTevmNode({
     miningConfig: { type: 'interval', interval: 12_000 }
   })
   ```

3. **Handle Errors**
   ```ts
   try {
     const node = createTevmNode()
     await node.ready()
   } catch (error) {
     console.error('Node initialization failed:', error)
   }
   ```

### Example Configurations

#### Local Development Node

```ts
const devNode = createTevmNode({
  miningConfig: { type: 'auto' },
  loggingLevel: 'debug',
  allowUnlimitedContractSize: true, // Helpful during development
})
await devNode.ready()
```

#### Production Forked Node

```ts
const prodNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest',
  },
  miningConfig: { type: 'interval', interval: 12000 },
  loggingLevel: 'error', // Less verbose in production
})
await prodNode.ready()
```

#### Testing Node

```ts
const testNode = createTevmNode({
  miningConfig: { type: 'auto' },
  profiler: true, // Enable profiling for performance testing
})
await testNode.ready()
```

### Next Steps

* Learn about the [Node Interface](./tevm-node-interface)
* Explore [Forking](./forking)
* Understand [State Management](./managing-state)
* Learn about [Custom Precompiles](../advanced/custom-precompiles)


import { Callout } from 'vocs/components'

## Forking Networks

Tevm's forking capability allows you to create a local instance that mirrors the state of any live Ethereum network or another Tevm instance. This is incredibly useful for:

* Testing against production state
* Debugging transactions
* Development with real-world data
* Simulating complex DeFi interactions

### Basic Forking

#### TypeScript

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    transport: http('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY'),
    blockTag: 'latest',
  },
})

await node.ready()
```

<Callout type="info">
  The `transport` can be any EIP-1193 compatible provider, including those from viem, ethers, or even another Tevm instance. Note that the transport function must be called with an empty object `({})`.
</Callout>

### Reforking Strategies

There are two main strategies for reforking a Tevm node: using the node as a transport or using deep copy.

#### 1. Using Node as Transport

This is the recommended approach as it's more memory efficient. You can use an existing Tevm node as the transport for a new fork:

```ts
import { createTevmNode, http, hexToBigInt } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'

// Create initial node with request handler
const sourceNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 17_000_000n,
  },
}).extend(requestEip1193())

// Get current block number
const currentBlock = await sourceNode.request({
  method: 'eth_blockNumber',
})

// Create new fork from the current state
const newNode = createTevmNode({
  fork: {
    transport: sourceNode,
    blockTag: hexToBigInt(currentBlock),
  },
})

await newNode.ready()
```

This approach:

* Is memory efficient as it reuses the state from the source node
* Allows forking from a specific point in time
* Maintains the original node's state while allowing new modifications

#### 2. Using Deep Copy

For cases where you need a completely independent copy of the node:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Read state from the forked node
const USDC_ADDRESS = createAddress('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48')
const vm = await node.getVm()
const usdcContract = await vm.stateManager.getAccount(USDC_ADDRESS)

console.log('USDC contract:', {
  balance: usdcContract?.balance,
  nonce: usdcContract?.nonce,
  codeHash: usdcContract?.codeHash,
})
```

<Callout type="warning">
  Deep copying creates a new instance with its own state, which can be memory intensive for large state trees. Use this approach sparingly and prefer using the node as a transport when possible.
</Callout>

### Working with Forked State

#### Reading State

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Get USDC contract state
const USDC_ADDRESS = createAddress('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48')
const vm = await node.getVm()
const usdcContract = await vm.stateManager.getAccount(USDC_ADDRESS)

if (usdcContract) {
  console.log('USDC contract:', {
    balance: usdcContract.balance,
    nonce: usdcContract.nonce,
    codeHash: usdcContract.codeHash,
  })
}
```

#### Modifying State

```ts
import { createAddress } from 'tevm/address'

// Modify balance of an account
const vm = await node.getVm()
const address = createAddress('0x1234567890123456789012345678901234567890')
const account = await vm.stateManager.getAccount(address)
if (account) {
  account.balance += 1000000000000000000n // Add 1 ETH
  await vm.stateManager.putAccount(address, account)

  // Verify the change
  const updatedAccount = await vm.stateManager.getAccount(address)
  console.log('New balance:', updatedAccount?.balance)
}
```

### Performance Optimization

#### State Caching

Tevm implements lazy loading with caching:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'
import { performance } from 'node:perf_hooks'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

const vm = await node.getVm()
const testAddress = createAddress('0x1234567890123456789012345678901234567890')

// First access - fetches from remote
const t0 = performance.now()
await vm.stateManager.getAccount(testAddress)
console.log('First access:', performance.now() - t0)

// Second access - uses cache
const t1 = performance.now()
await vm.stateManager.getAccount(testAddress)
console.log('Cached access:', performance.now() - t1)
```

#### Best Practices

1. **RPC Provider Setup**
   ```ts
   // ✅ Always call transport with empty object
   const node = createTevmNode({
     fork: {
       transport: http('https://ethereum.quicknode.com/YOUR-API-KEY'),
       blockTag: 15_000_000n,
     },
   })
   ```

2. **Type Safety**
   ```ts
   // ✅ Use proper type checks
   const account = await vm.stateManager.getAccount(address)
   if (account) {
     account.balance += 1000000000000000000n
     await vm.stateManager.putAccount(address, account)
   }
   ```

3. **Address Handling**
   ```ts
   // ✅ Use createAddress for type safety
   import { createAddress } from 'tevm/address'
   const address = createAddress('0x1234567890123456789012345678901234567890')
   ```

4. **Testing Setup**
   ```ts
   // ✅ Wait for node to be ready
   const node = createTevmNode({
     fork: {
       transport: http('https://...'),
     },
   })
   await node.ready()
   ```

### Related Topics

* [State Management](./managing-state)
* [Transaction Processing](../advanced/txpool)
* [JSON-RPC Support](../api/json-rpc)


import { Callout } from 'vocs/components'

## Managing State

Tevm provides powerful state management capabilities through multiple APIs. Let's explore how to manage Ethereum state using different approaches.

### Raw API Approach

The most direct way to manage state is through the [`StateManager`](https://github.com/evmts/tevm-monorepo/blob/main/packages/state/docs/interfaces/StateManager.md) interface:

```typescript
import { createTevmNode } from 'tevm'
import { EthjsAccount } from 'tevm/utils'

const node = createTevmNode()
const vm = await node.getVm()
const stateManager = vm.stateManager

// Read account state
const address = '0x1234567890123456789012345678901234567890'
const account = await stateManager.getAccount(address)
console.log({
  balance: account.balance,
  nonce: account.nonce,
  codeHash: account.codeHash,
  storageRoot: account.storageRoot
})

// Create or update an account
await stateManager.putAccount(
  address,
  new EthjsAccount({
    nonce: 0n,
    balance: 10_000_000n,
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })
)

// Delete an account
await stateManager.deleteAccount(address)
```

#### Contract Management

```typescript
// Deploy contract code
await stateManager.putContractCode(
  address,
  new Uint8Array([/* bytecode */])
)

// Read contract code
const code = await stateManager.getContractCode(address)

// Read storage slot
const slot = '0x0000000000000000000000000000000000000000000000000000000000000000'
const value = await stateManager.getContractStorage(address, slot)

// Write storage
const key = '0x0000000000000000000000000000000000000000000000000000000000000000'
const newValue = '0x0000000000000000000000000000000000000000000000000000000000000001'
await stateManager.putContractStorage(address, key, newValue)

// Clear all storage
await stateManager.clearContractStorage(address)
```

### Using with Viem

For a more familiar experience, you can use the Viem client interface while still accessing raw state management when needed:

```typescript
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

// Use Viem-style API for basic operations
await client.setBalance({
  address: '0x1234567890123456789012345678901234567890',
  value: 1000000000000000000n
})

// Access raw state manager for advanced operations
const vm = await client.transport.tevm.getVm()
const stateManager = vm.stateManager

// Use raw API for complex operations
await stateManager.checkpoint()
try {
  await stateManager.putContractStorage(address, key, value)
  await stateManager.commit()
} catch (error) {
  await stateManager.revert()
}
```

### Using with Ethers

When using Ethers.js, you can combine the standard Ethers API with Tevm's state management:

```typescript
import { createTevmNode } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'
import { BrowserProvider } from 'ethers'

const node = createTevmNode().extend(requestEip1193())
const provider = new BrowserProvider(node)

// Use Ethers API for standard operations
const balance = await provider.getBalance('0x1234...')

// Access raw state manager for advanced operations
const vm = await node.getVm()
const stateManager = vm.stateManager
```

### Advanced Features

#### State Checkpoints

Create atomic state changes that can be committed or reverted:

```typescript
const stateManager = (await node.getVm()).stateManager

await stateManager.checkpoint()
try {
  // Batch multiple state changes
  await Promise.all([
    stateManager.putAccount(address, account),
    stateManager.putContractStorage(address, key, value),
  ])
  await stateManager.commit()
} catch (error) {
  await stateManager.revert()
  console.error('State changes reverted:', error)
}
```

#### State Persistence

Save and load state:

```typescript
// Dump complete state
const state = await stateManager.dumpCanonicalGenesis()

// Save state (example with localStorage)
localStorage.setItem('tevmState', JSON.stringify(state))

// Load saved state
const savedState = JSON.parse(localStorage.getItem('tevmState'))
await stateManager.generateCanonicalGenesis(savedState)
```

#### Fork Mode

Tevm supports lazy loading with caching when forking from another network:

```typescript
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io')
  }
})

const stateManager = (await node.getVm()).stateManager

// First access fetches from remote
const account = await stateManager.getAccount('0x1234...')

// Subsequent access uses cache
const cachedAccount = await stateManager.getAccount('0x1234...')
```

### Best Practices

#### 1. Error Handling

```typescript
try {
  const account = await stateManager.getAccount('0x1234...')
  if (!account) {
    throw new Error('Account not found')
  }
  // Work with account
} catch (error) {
  if (error instanceof MissingAccountError) {
    // Handle missing account
  }
  console.error('State operation failed:', error)
}
```

#### 2. State Isolation

```typescript
// Create isolated copy for testing
const isolatedState = await stateManager.deepCopy()

// Make changes without affecting original
await isolatedState.putAccount(address, account)
```

#### 3. Atomic Operations

```typescript
await stateManager.checkpoint()
try {
  // Group related changes
  await Promise.all([
    stateManager.putAccount(address, account),
    stateManager.putContractStorage(address, key, value),
  ])
  await stateManager.commit()
} catch (error) {
  await stateManager.revert()
}
```

### See Also

* [State Manager API](https://github.com/evmts/tevm-monorepo/blob/main/packages/state/docs/interfaces/StateManager.md)
* [Account Management](../api/account-management)
* [Contract Storage](/reference/contract)
* [Forking Guide](../core/forking)


## Mining Modes

Tevm Node provides several mining modes to control how and when blocks are produced. This flexibility allows you to simulate different network conditions and test various scenarios.

### Available Mining Modes

#### Auto Mining (`auto`)

Automatically mines a new block after each transaction.

```typescript
const node = createTevmNode({
  miningConfig: {
    type: 'auto'
  }
})
```

Best for:

* Quick testing and development
* Immediate transaction confirmation
* Simulating instant finality

#### Interval Mining (`interval`)

Mines blocks at fixed time intervals, simulating real network block times.

```typescript
const node = createTevmNode({
  miningConfig: {
    type: 'interval',
    interval: 12000 // 12 seconds, similar to Ethereum
  }
})
```

Best for:

* Testing time-dependent logic
* Simulating realistic network conditions
* Handling pending transaction queues

#### Manual Mining (`manual`)

Only mines blocks when explicitly requested, giving you complete control over block production.

```typescript
const node = createTevmNode({
  miningConfig: {
    type: 'manual'
  }
})

// Later, mine blocks manually
await node.mine()
```

Best for:

* Complex test scenarios
* Precise control over block timing
* Testing mempool behavior

#### Gas-Based Mining (`gas`)

Mines a new block when the accumulated gas usage reaches a specified threshold.

```typescript
const node = createTevmNode({
  miningConfig: {
    type: 'gas',
    gasLimit: 15000000 // Similar to Ethereum block gas limit
  }
})
```

Best for:

* Testing gas-dependent behavior
* Simulating block fullness scenarios
* Performance testing with varying load

### Changing Mining Modes

You can change the mining mode after node creation:

```typescript
// Switch to interval mining
await node.setMiningConfig({
  type: 'interval',
  interval: 5000 // 5 seconds
})

// Switch to manual mining
await node.setMiningConfig({
  type: 'manual'
})
```

### Best Practices

1. **Choose the Right Mode**
   * Use `auto` for simple testing and development
   * Use `interval` or `gas` for more realistic scenarios
   * Use `manual` for precise control in tests

2. **Consider Performance**
   * `auto` mining can be resource-intensive with many transactions
   * `interval` mining might delay transaction processing
   * `gas` mining helps simulate network congestion

3. **Testing Considerations**
   * Test time-sensitive logic with `interval` mining
   * Use `manual` mining for deterministic test cases
   * Simulate network conditions with appropriate intervals

### Example: Testing Different Mining Modes

```typescript
import { createTevmNode } from 'tevm'

// Auto mining for quick tests
const autoNode = createTevmNode({
  miningConfig: { type: 'auto' }
})

// Interval mining for realistic scenarios
const intervalNode = createTevmNode({
  miningConfig: {
    type: 'interval',
    interval: 12000
  }
})

// Manual mining for controlled tests
const manualNode = createTevmNode({
  miningConfig: { type: 'manual' }
})

// Test transaction processing
await autoNode.sendTransaction({...}) // Mines immediately
await intervalNode.sendTransaction({...}) // Mines after interval
await manualNode.sendTransaction({...}) // Stays pending until manual mine
await manualNode.mine() // Now the transaction is mined
```

### Related Topics

* [Transaction Pool](../advanced/txpool) - Understanding pending transaction handling
* [Performance Optimization](../advanced/performance-profiler) - Tuning mining for better performance
* [Block Management](../api/methods#block-methods) - Low-level block control


import { Callout } from 'vocs/components'

## TevmNode Interface

The `TevmNode` interface is the core API surface of Tevm. It provides access to all the fundamental Ethereum node capabilities, from transaction processing to state management.

### Interface Overview

```ts
export type TevmNode<TMode extends 'fork' | 'normal' = 'fork' | 'normal', TExtended = {}> = {
  readonly logger: Logger
  readonly getReceiptsManager: () => Promise<ReceiptsManager>
  readonly miningConfig: MiningConfig
  readonly forkTransport?: { request: EIP1193RequestFn }
  readonly mode: TMode
  readonly ready: () => Promise<true>
  readonly getVm: () => Promise<Vm>
  readonly getTxPool: () => Promise<TxPool>
  readonly getImpersonatedAccount: () => Address | undefined
  readonly setImpersonatedAccount: (address: Address | undefined) => void
  readonly extend: <TExtension>(decorator: (client: TevmNode<TMode, TExtended>) => TExtension) => TevmNode<TMode, TExtended & TExtension>
  readonly setFilter: (filter: Filter) => void
  readonly getFilters: () => Map<Hex, Filter>
  readonly removeFilter: (id: Hex) => void
  status: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
  readonly deepCopy: () => Promise<TevmNode<TMode, TExtended>>
} & EIP1193EventEmitter & TExtended
```

### Core Components

#### 1. Initialization & Status

```ts
const node = createTevmNode()

// Wait for initialization
await node.ready()

// Check status
console.log(node.status) // 'READY'
```

<Callout type="info">
  The `ready()` method ensures all internal components are initialized. While not strictly required (methods will wait implicitly), calling it explicitly can help manage initialization flow.
</Callout>

#### 2. Virtual Machine Access

The VM is the heart of Tevm, providing EVM execution capabilities:

```ts
const node = createTevmNode()
const vm = await node.getVm()

// Execute a transaction
const result = await vm.runTx({
  tx: {
    to: '0x1234...',
    value: 1000000000000000000n, // 1 ETH
    data: '0x...',
  }
})
```

#### 3. Transaction Pool Management

The TxPool handles pending transactions:

```ts
const node = createTevmNode()
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### 4. Receipt & Log Management

Track transaction outcomes and event logs:

```ts
const node = createTevmNode()
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

#### 5. Account Impersonation

In fork mode, you can impersonate existing accounts:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

// Now you can send transactions as this account
const vm = await node.getVm()
await vm.runTx({
  tx: {
    from: '0x28C6c06298d514Db089934071355E5743bf21d60',
    to: '0x1234...',
    value: 1000000000000000000n,
  },
})
```

#### 6. Event Filtering

Manage subscriptions to blockchain events:

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

#### 7. Extensibility

The `extend` method allows adding custom functionality:

```ts
// Add custom methods
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### 8. Deep Copying

Create independent copies of a node:

```ts
const node = createTevmNode()
// ... perform some operations ...

// Create a copy with the same state
const nodeCopy = await node.deepCopy()
```

<Callout type="warning">
  Deep copying creates a completely new instance with its own state. This is useful for testing different scenarios, but can be memory-intensive.
</Callout>

### Best Practices

1. **Initialization**
   ```ts
   const node = createTevmNode()
   await node.ready() // Always wait for ready
   ```

2. **Error Handling**
   ```ts
   try {
     const vm = await node.getVm()
     await vm.runTx(/* ... */)
   } catch (error) {
     if (error.message.includes('insufficient funds')) {
       // Handle specific error cases
     }
     throw error
   }
   ```

3. **Resource Management**
   ```ts
   // Clean up filters when done
   node.getFilters().forEach((_, id) => node.removeFilter(id))
   ```

4. **State Isolation**
   ```ts
   // Use deepCopy for isolated test cases
   const baseNode = createTevmNode()

   test('scenario 1', async () => {
     const node = await baseNode.deepCopy()
     // Test with isolated state
   })
   ```

### Type Safety

The interface is fully typed with TypeScript:

```ts
import type { TevmNode } from 'tevm/node'

function useNode<TMode extends 'fork' | 'normal'>(
  node: TevmNode<TMode>
) {
  if (node.mode === 'fork') {
    // Fork-specific operations
    node.setImpersonatedAccount('0x...')
  }
}
```

### Next Steps

* Learn about [Forking](./forking)
* Explore [State Management](./managing-state)
* See [JSON-RPC Support](../api/json-rpc)


## Account Management

Tevm provides two key actions for managing account state: `getAccountHandler` and `setAccountHandler`.

### getAccountHandler

The `getAccountHandler` action allows you to retrieve the current state of an account.

#### Parameters

```ts
type GetAccountParams = {
  // Required address of the account
  address: Address
  // Optional block tag to query state from
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to return storage (can be expensive)
  returnStorage?: boolean
}
```

#### Return Type

```ts
type GetAccountResult = {
  // Address of the account
  address: Address
  // Current nonce
  nonce: bigint
  // Balance in wei
  balance: bigint
  // Deployed bytecode (if contract)
  deployedBytecode: Hex
  // Storage root
  storageRoot: Hex
  // Code hash
  codeHash: Hex
  // Whether this is a contract
  isContract: boolean
  // Whether account is empty
  isEmpty: boolean
  // Storage (if returnStorage=true)
  storage?: { [key: Hex]: Hex }
  // Any errors that occurred
  errors?: TevmGetAccountError[]
}
```

#### Example

```ts
import { createTevmNode } from 'tevm'
import { getAccountHandler } from 'tevm/actions'

const node = createTevmNode()

const account = await getAccountHandler(node)({
  address: '0x...',
  blockTag: 'latest',
  returnStorage: true
})

console.log('Balance:', account.balance)
console.log('Nonce:', account.nonce)
if (account.isContract) {
  console.log('Code:', account.deployedBytecode)
  console.log('Storage:', account.storage)
}
```

### setAccountHandler

The `setAccountHandler` action allows you to modify account state directly.

#### Parameters

```ts
type SetAccountParams = {
  // Required address to modify
  address: Address
  // New nonce value
  nonce?: bigint
  // New balance in wei
  balance?: bigint
  // New deployed bytecode
  deployedBytecode?: Hex
  // New storage values
  state?: { [key: Hex]: Hex }
}
```

#### Return Type

```ts
type SetAccountResult = {
  // Any errors that occurred
  errors?: TevmSetAccountError[]
}
```

#### Examples

##### 1. Setting Account Balance

```ts
import { setAccountHandler } from 'tevm/actions'

await setAccountHandler(node)({
  address: '0x...',
  balance: parseEther('100')
})
```

##### 2. Deploying Contract Code

```ts
await setAccountHandler(node)({
  address: contractAddress,
  deployedBytecode: '0x...',
  state: {
    // Initial storage values
    '0x0000...': '0x0000...'
  }
})
```

##### 3. Modifying Multiple Properties

```ts
await setAccountHandler(node)({
  address: '0x...',
  nonce: 5n,
  balance: parseEther('10'),
  state: {
    [slot1]: value1,
    [slot2]: value2
  }
})
```

### Best Practices

1. **Storage Management**:
   ```ts
   // Avoid fetching storage unless needed
   const account = await getAccountHandler(node)({
     address: '0x...',
     returnStorage: false // default
   })
   ```

2. **State Consistency**:
   ```ts
   // Check account exists before modifying
   const account = await getAccountHandler(node)({ address })
   if (!account.isEmpty) {
     await setAccountHandler(node)({
       address,
       balance: account.balance + amount
     })
   }
   ```

3. **Error Handling**:
   ```ts
   const result = await setAccountHandler(node)({
     address: '0x...',
     balance: newBalance,
     throwOnFail: false
   })

   if (result.errors) {
     console.error('Failed to set account:', result.errors)
   }
   ```

### Related Topics

* [State Management](../core/managing-state)
* [Call API](./tevm-call)
* [JSON-RPC Support](./json-rpc)


### See Also

* [JSON-RPC API](/api/json-rpc)
* [Client Types](#TODO)
* [Actions Reference](/reference/actions)
* [EIP-1193 Specification](https://eips.ethereum.org/EIPS/eip-1193)
* [Ethereum JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/)


## EVM Events

Tevm Node provides access to low-level EVM events, allowing you to monitor and debug contract execution at a granular level.

### Available Events

```ts
type EVMEvent = {
  // Emitted when a new contract is created
  newContract: (data: {
    address: Address, // Contract address
    code: Uint8Array  // Contract bytecode
  }, next?: () => void) => void

  // Emitted before a message (call) is processed
  beforeMessage: (data: Message, next?: () => void) => void

  // Emitted after a message (call) is processed
  afterMessage: (data: EVMResult, next?: () => void) => void

  // Emitted on each EVM step (instruction execution)
  step: (data: InterpreterStep, next?: () => void) => void
}
```

#### The InterpreterStep Object

The `step` event handler receives a detailed `InterpreterStep` object with the following properties:

```ts
interface InterpreterStep {
  // Program counter - current position in the bytecode
  pc: number
  
  // Current opcode information
  opcode: {
    name: string        // Opcode name (e.g., 'SSTORE', 'CALL')
    fee: number         // Base gas fee of the opcode
    dynamicFee?: bigint // Additional dynamic gas fee (if applicable)
    isAsync: boolean    // Whether opcode is asynchronous
  }
  
  // Gas information
  gasLeft: bigint    // Remaining gas
  gasRefund: bigint  // Gas refund accumulator
  
  // EVM state
  stateManager: StateManager  // Reference to the StateManager instance
  stack: Uint8Array[]         // Current EVM stack contents
  returnStack: bigint[]       // Return stack for RETURNSUB operations
  
  // Account information
  account: Account    // Account which owns the code running
  address: Address    // Address of the current account
  
  // Execution context
  depth: number       // Current call depth (starts at 0 for top-level call)
  memory: Uint8Array  // Current EVM memory contents
  memoryWordCount: bigint  // Current size of memory in words (32 bytes)
  codeAddress: Address     // Address of the code being executed
                          // (differs from address in DELEGATECALL/CALLCODE)
}
```

Where:

* [`Address`](/reference/address) is Tevm's address type (from `tevm/address`)
* [`StateManager`](/reference/state) is the state manager interface (from `tevm/state`)
* [`Account`](/reference/node) is Tevm's account representation

#### The NewContractEvent Object

The `onNewContract` event handler receives a `NewContractEvent` object with the following properties:

```ts
interface NewContractEvent {
  // Contract information
  address: Address      // Address of the newly created contract
  code: Uint8Array      // Deployed contract bytecode
}
```

#### The Message Object

The `beforeMessage` event handler receives a `Message` object with the following properties:

```ts
interface Message {
  // Call information
  to?: Address            // Target address (undefined for contract creation)
  value: bigint           // Value sent with the call (in wei)
  caller: Address         // Address of the account that initiated this call
  
  // Gas information
  gasLimit: bigint        // Gas limit for this call
  
  // Data and code
  data: Uint8Array        // Input data to the call
  code?: Uint8Array       // Contract code for the call
  codeAddress?: Address   // Address of contract code
  
  // Call type
  depth: number           // Call depth
  isStatic: boolean       // Whether the call is static (view)
  isCompiled: boolean     // Whether this is precompiled contract code
  delegatecall: boolean   // Whether this is a DELEGATECALL
  callcode: boolean       // Whether this is a CALLCODE
  
  // Other
  salt?: Uint8Array       // Salt for CREATE2 calls
  authcallOrigin?: Address // Origin address for AUTH calls
}
```

#### The EVMResult Object

The `afterMessage` event handler receives an `EVMResult` object with the following properties:

```ts
interface EVMResult {
  execResult: {
    // Return information
    returnValue: Uint8Array   // Return data from the call
    executionGasUsed: bigint  // Gas used in execution
    gasRefund?: bigint        // Gas refunded
    
    // Error information
    exceptionError?: {        // Error encountered during execution
      error: string           // Error type (e.g., 'revert', 'out of gas')
      errorType?: string      // Additional error type information
    }
    
    // State
    logs?: Log[]              // Logs emitted during execution
    selfdestruct?: Record<string, true>  // Self-destructed addresses
    gas?: bigint              // Remaining gas
  }
  
  // Other information
  gasUsed: bigint             // Total gas used (including intrinsic costs)
  createdAddress?: Address    // Address of created contract (if any)
  gasRefund?: bigint          // Total gas refunded
}
```

### Using with tevmCall Family

The recommended way to access EVM events is through the tevmCall family of methods. Tevm offers two API styles for this:

#### Client-based API (batteries included)

```ts
import { createMemoryClient } from 'tevm'
import { encodeFunctionData } from 'viem'

const client = createMemoryClient()

// Listen for EVM steps and other events during execution
const result = await client.tevmCall({
  to: contractAddress,
  data: encodeFunctionData({
    abi,
    functionName: 'myFunction',
    args: [arg1, arg2]
  }),
  // Listen for EVM steps
  onStep: (step, next) => {
    console.log('EVM Step:', {
      pc: step.pc,           // Program counter
      opcode: step.opcode,   // Current opcode
      gasLeft: step.gasLeft, // Remaining gas
      stack: step.stack,     // Stack contents
      depth: step.depth,     // Call depth
    })
    next?.()
  },
  // Listen for contract creation
  onNewContract: (data, next) => {
    console.log('New contract deployed:', {
      address: data.address.toString(),
      codeSize: data.code.length,
    })
    next?.()
  },
  // Listen for message execution
  onBeforeMessage: (message, next) => {
    console.log('Executing message:', {
      to: message.to?.toString(),
      value: message.value.toString(),
      delegatecall: message.delegatecall,
    })
    next?.()
  },
  onAfterMessage: (result, next) => {
    console.log('Message result:', {
      gasUsed: result.execResult.executionGasUsed.toString(),
      returnValue: result.execResult.returnValue.toString('hex'),
      error: result.execResult.exceptionError?.error,
    })
    next?.()
  }
})
```

#### Tree-shakable API

```ts
import { tevmCall } from 'tevm/actions'
import { createClient, custom } from 'viem'
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'
import { encodeFunctionData } from 'viem'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Viem client
const client = createClient({
  transport: custom(node),
})

// Listen for EVM steps and other events during execution
const result = await tevmCall(client, {
  to: contractAddress,
  data: encodeFunctionData({
    abi,
    functionName: 'myFunction',
    args: [arg1, arg2]
  }),
  // Event handlers work the same way with both API styles
  onStep: (step, next) => {
    console.log('EVM Step:', {
      pc: step.pc,
      opcode: step.opcode,
      gasLeft: step.gasLeft,
      stack: step.stack,
      depth: step.depth,
    })
    next?.()
  },
  onNewContract: (data, next) => {
    console.log('New contract deployed:', {
      address: data.address.toString(),
      codeSize: data.code.length,
    })
    next?.()
  },
  onBeforeMessage: (message, next) => {
    console.log('Executing message:', {
      to: message.to?.toString(),
      value: message.value.toString(),
      delegatecall: message.delegatecall,
    })
    next?.()
  },
  onAfterMessage: (result, next) => {
    console.log('Message result:', {
      gasUsed: result.execResult.executionGasUsed.toString(),
      returnValue: result.execResult.returnValue.toString('hex'),
      error: result.execResult.exceptionError?.error,
    })
    next?.()
  }
})
```

### Advanced Examples

#### Debugging

You can create a debug tracer to collect comprehensive execution data:

```ts
import { createMemoryClient } from 'tevm'
import { tevmCall } from 'tevm/actions'

const client = createMemoryClient()

// Create a debug tracer
const trace = {
  steps: [],
  contracts: new Set(),
  errors: [],
}

// Execute with tracing
const result = await tevmCall(client, {
  to: contractAddress,
  data: '0x...',
  // Track each EVM step
  onStep: (step, next) => {
    trace.steps.push({
      pc: step.pc,
      opcode: step.opcode.name,
      gasCost: step.opcode.fee,
      stack: step.stack.map(item => item.toString(16)),
    })
    next?.()
  },
  // Track contract creation
  onNewContract: (data, next) => {
    trace.contracts.add(data.address.toString())
    next?.()
  },
  // Track errors
  onAfterMessage: (result, next) => {
    if (result.execResult.exceptionError) {
      trace.errors.push({
        error: result.execResult.exceptionError.error,
        returnData: result.execResult.returnValue.toString('hex'),
      })
    }
    next?.()
  }
})

console.log('Execution trace:', {
  stepCount: trace.steps.length,
  contracts: Array.from(trace.contracts),
  errors: trace.errors,
})
```

#### Gas Profiling

Create a gas profiler to analyze opcode costs:

```ts
import { createMemoryClient } from 'tevm'
import { tevmCall } from 'tevm/actions'

const client = createMemoryClient()

// Create a gas profiler
const profile = {
  opcodes: new Map(),
  totalGas: 0n,
}

// Execute with profiling
const result = await tevmCall(client, {
  to: contractAddress,
  data: '0x...',
  onStep: (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = profile.opcodes.get(opName) || {
      count: 0,
      totalGas: 0n
    }

    stats.count++
    stats.totalGas += gasCost
    profile.totalGas += gasCost
    profile.opcodes.set(opName, stats)

    next?.()
  }
})

// Get gas usage by opcode
for (const [opcode, stats] of profile.opcodes) {
  console.log(`${opcode}:`, {
    count: stats.count,
    totalGas: stats.totalGas.toString(),
    percentageOfTotal: Number(stats.totalGas * 100n / profile.totalGas),
  })
}
```

#### Error Handling

Handle errors in execution:

```ts
import { createMemoryClient } from 'tevm'
import { tevmCall } from 'tevm/actions'

const client = createMemoryClient()

const result = await tevmCall(client, {
  to: contractAddress,
  data: '0x...',
  onAfterMessage: (result, next) => {
    if (result.execResult.exceptionError) {
      const error = result.execResult.exceptionError

      switch (error.error) {
        case 'out of gas':
          console.error('Transaction ran out of gas')
          break
        case 'revert':
          console.error('Transaction reverted:',
            result.execResult.returnValue.toString('hex'))
          break
        case 'invalid opcode':
          console.error('Invalid opcode encountered')
          break
        default:
          console.error('Unknown error:', error)
      }
    }
    next?.()
  }
})
```

### Best Practices

1. **Always Call Next**
   ```ts
   // Important: Call next to continue execution
   onStep: (step, next) => {
     // Process step...
     next?.() 
   }
   ```

2. **Handle Errors Gracefully**
   ```ts
   onStep: (step, next) => {
     try {
       // Process step...
     } catch (error) {
       console.error('Error processing step:', error)
     }
     next?.()
   }
   ```

3. **Be Efficient**
   ```ts
   // Focus on information you need
   onStep: (step, next) => {
     // Only log SSTORE operations
     if (step.opcode.name === 'SSTORE') {
       console.log('Storage write:', {
         key: step.stack[step.stack.length - 1].toString(16),
         value: step.stack[step.stack.length - 2].toString(16)
       })
     }
     next?.()
   }
   ```

### Related Topics

* [Tevm Call API](../api/tevm-call)
* [Methods](../api/methods)
* [Performance Profiler](../advanced/performance-profiler)
* [Gas Estimation](../api/methods)


## JSON-RPC Support

Tevm Node provides comprehensive [JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/) support through an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible interface. This allows seamless integration with popular Ethereum libraries and tools.

### EIP-1193 Provider

The node can be extended to expose an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible request interface:

```ts
import { createTevmNode } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Use standard JSON-RPC methods
const blockNum = await node.request({
  method: 'eth_blockNumber',
  params: [],
})
```

### Supported Methods

#### Core Ethereum Methods

* **Block & Chain**
  * [`eth_blockNumber`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/blockNumberHandler.md) - Get current block number
  * [`eth_getBlockByHash`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetBlockByHashProcedure.md) - Get block by hash
  * [`eth_getBlockByNumber`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetBlockByNumberProcedure.md) - Get block by number
  * [`eth_chainId`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/chainIdHandler.md) - Get current chain ID

* **State & Account**
  * [`eth_getBalance`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/getBalanceHandler.md) - Get account balance
  * [`eth_getCode`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/getCodeHandler.md) - Get contract code
  * [`eth_getStorageAt`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/getStorageAtHandler.md) - Get storage value
  * [`eth_getTransactionCount`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetTransactionCountProcedure.md) - Get account nonce

* **Transaction**
  * [`eth_call`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethCallHandler.md) - Execute contract call
  * [`eth_estimateGas`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethEstimateGasProcedure.md) - Estimate gas usage
  * [`eth_sendTransaction`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethSendTransactionHandler.md) - Send transaction
  * [`eth_sendRawTransaction`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethSendRawTransaction.md) - Send signed transaction
  * [`eth_getTransactionByHash`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetTransactionByHashProcedure.md) - Get transaction details
  * [`eth_getTransactionReceipt`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetTransactionReceipt.md) - Get transaction receipt

* **Logs & Events**
  * [`eth_getLogs`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetLogsHandler.md) - Get event logs
  * [`eth_newFilter`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethNewFilterProcedure.md) - Create new filter
  * [`eth_newBlockFilter`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethNewBlockFilterProcedure.md) - Create block filter
  * [`eth_getFilterChanges`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetFilterChangesProcedure.md) - Get filter updates
  * [`eth_getFilterLogs`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetFilterLogsProcedure.md) - Get all filter logs
  * [`eth_uninstallFilter`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethUninstallFilterProcedure.md) - Remove filter

#### Extended Methods

Tevm also supports additional methods commonly found in development environments:

* **Debug Methods**
  * [`debug_traceTransaction`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/debugTraceTransactionProcedure.md) - Trace transaction execution
  * [`debug_dumpState`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/debugDumpStateProcedure.md) - Dump current state

* **Anvil Methods** (For [Foundry](https://book.getfoundry.sh/reference/anvil/) compatibility)
  * [`anvil_setCode`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilSetCodeProcedure.md) - Set contract code
  * [`anvil_setBalance`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilSetBalance.md) - Set account balance
  * [`anvil_setNonce`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilSetNonceProcedure.md) - Set account nonce
  * [`anvil_setStorageAt`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilSetStorageAtProcedure.md) - Set storage value
  * [`anvil_impersonateAccount`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilImpersonateAccount.md) - Impersonate account
  * [`anvil_stopImpersonatingAccount`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/anvilStopImpersonatingAccountProcedure.md) - Stop impersonating

### Client Integration

#### Using with Viem

For more information, see the [Viem Documentation](https://viem.sh/docs/clients/custom.html).

```ts
import { createTevmNode } from 'tevm'
import { createPublicClient, custom } from 'viem'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

const client = createPublicClient({
  chain: mainnet,
  transport: custom(node.request),
})
```

#### Using with Ethers

For more information, see the [Ethers Documentation](https://docs.ethers.org/v6/api/providers/#Provider).

```ts
import { createTevmNode } from 'tevm'
import { BrowserProvider } from 'ethers'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())
const provider = new BrowserProvider(node)
```

### Error Handling

JSON-RPC errors follow the [standard format](https://www.jsonrpc.org/specification#error_object) and are fully typed. See the [error types documentation](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/JsonRpcError.md) for more details:

```ts
interface JsonRpcError {
  code: number
  message: string
  data?: unknown
}
```

Common error codes (see [Error Types](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/variables/ErrorCodes.md)):

* `-32700`: Parse error ([`ParseError`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/ParseError.md))
* `-32600`: Invalid request ([`InvalidRequest`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/InvalidRequest.md))
* `-32601`: Method not found ([`MethodNotFound`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/MethodNotFound.md))
* `-32602`: Invalid params ([`InvalidParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/InvalidParams.md))
* `-32603`: Internal error ([`InternalError`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/InternalError.md))
* `-32000` to `-32099`: Server error ([`ServerError`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/ServerError.md))

For detailed error handling examples and best practices, see the [Error Handling Guide](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/variables/ErrorHandling.md).

### Best Practices

1. **Error Handling**: Always wrap RPC calls in try-catch blocks to handle potential errors gracefully. See [Error Types](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/variables/ErrorCodes.md) for all possible errors.

2. **Gas Estimation**: For transactions, use [`eth_estimateGas`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethEstimateGasProcedure.md) before sending to ensure sufficient gas:

```ts
const gasEstimate = await node.request({
  method: 'eth_estimateGas',
  params: [tx],
})
```

3. **Receipt Confirmation**: Wait for transaction receipts to confirm state changes using [`eth_getTransactionReceipt`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethGetTransactionReceipt.md):

```ts
const txHash = await node.request({
  method: 'eth_sendTransaction',
  params: [tx],
})

const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash],
})
```

4. **Event Filtering**: Use filters efficiently by:
   * Setting appropriate block ranges
   * Using specific [topics](https://docs.soliditylang.org/en/latest/abi-spec.html#events)
   * Cleaning up unused filters with [`eth_uninstallFilter`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/ethUninstallFilterProcedure.md)

For more examples and detailed API documentation, see:

* [Complete Actions Documentation](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs)
* [Type Definitions](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases)
* [Function Reference](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions)
* [Variables and Constants](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/variables)

### Related Topics

* [Using with Viem](../examples/viem)
* [Using with Ethers](../examples/ethers)
* [Managing State](../core/managing-state)
* [Receipts & Logs](../advanced/receipts-and-logs)
* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [EIP-1193: Ethereum Provider JavaScript API](https://eips.ethereum.org/EIPS/eip-1193)
* [Tevm API Documentation](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs)

### Using Tevm Actions

Tevm provides a set of high-level actions that can be imported from `tevm/actions`. See the [complete actions documentation](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs) for all available actions.

```ts
import {
  tevmCall, // See: https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/callHandler.md
  tevmMine, // See: https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/mineHandler.md
  tevmGetAccount, // See: https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/getAccountHandler.md
  tevmSetAccount // See: https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/setAccountHandler.md
} from 'tevm/actions'
import { createTevmNode } from 'tevm'

const node = createTevmNode()

// Call a contract
const result = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  value: 0n,
  createTransaction: true
})

// Mine pending transactions
await tevmMine(node)

// Get account state
const account = await tevmGetAccount(node, {
  address: '0x...',
  blockTag: 'latest'
})

// Set account state
await tevmSetAccount(node, {
  address: '0x...',
  balance: 100n,
  nonce: 0n,
  deployedBytecode: '0x...'
})
```

For detailed type information, see:

* [`CallParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/CallParams.md)
* [`MineParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/MineParams.md)
* [`GetAccountParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/GetAccountParams.md)
* [`SetAccountParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/type-aliases/SetAccountParams.md)

Note: By default, tevm actions require manual mining via [`tevmMine()`](https://github.com/evmts/tevm-monorepo/blob/main/packages/actions/docs/functions/mineHandler.md). If you want transactions to be automatically applied, you can either:

1. Use the lower level API `vm.runCall`
2. Configure the client with `miningConfig: { type: 'auto' }`

### Optimistic Updates with Receipt Manager

For more information on transaction receipts and logs, see the [Ethereum Receipts Documentation](https://ethereum.org/en/developers/docs/transactions/transaction-receipts/).

```ts
import { createTevmNode } from 'tevm'
import { tevmCall, tevmMine } from 'tevm/actions'

const node = createTevmNode()
const receiptsManager = await node.getReceiptsManager()

// Submit transaction
const { txHash } = await tevmCall(node, {
  method: 'eth_sendTransaction',
  params: [tx],
  createTransaction: true
})

// Get optimistic receipt
const pendingReceipt = await receiptsManager.getReceiptByTxHash(txHash)

// Update UI optimistically
updateUI(pendingReceipt)

// Wait for real receipt
const realReceipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash]
})

// Eject optimistic tx if real receipt differs
if (receiptsAreDifferent(pendingReceipt, realReceipt)) {
  await receiptsManager.removeReceipt(txHash)
  updateUI(realReceipt)
}

// Advanced: Rebase on new blocks
node.on('block', async (blockNumber) => {
  // Get new block
  const block = await node.request({
    method: 'eth_getBlockByNumber',
    params: [blockNumber, true]
  })

  // Get our pending transactions
  const pendingTxs = await receiptsManager.getPendingTransactions()

  // Rebase our transactions on top of new block
  for (const tx of pendingTxs) {
    const result = await tevmCall(node, {
      ...tx,
      blockTag: 'pending'
    })

    // Update receipt
    await receiptsManager.putReceipt(tx.hash, result)
  }

  // Mine rebased transactions
  await tevmMine(node)
})
```


import { Callout } from 'vocs/components'

## Tevm Node Methods

Tevm Node provides a comprehensive API for interacting with the Ethereum Virtual Machine. This reference covers all core methods and capabilities.

### Core Methods

#### Initialization

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')
  }
})

await node.ready() // Wait for initialization
```

#### Virtual Machine Access

```ts
import { createImpersonatedTx } from '@tevm/tx'
import { Block } from '@tevm/block'
import { EthjsAddress } from '@tevm/utils'

const vm = await node.getVm()

// Create a block for the transaction
const block = new Block()

// Create an impersonated transaction
const tx = createImpersonatedTx({
  impersonatedAddress: EthjsAddress.fromString('0x1234...'),
  nonce: 0n,
  gasLimit: 21064n,
  maxFeePerGas: 8n,
  maxPriorityFeePerGas: 1n,
  to: EthjsAddress.fromString('0x5678...'),
  value: 1000000000000000000n, // 1 ETH
})

// Execute the transaction
const result = await vm.runTx({
  tx,
  block,
  skipNonce: true,  // Skip nonce check
  skipBalance: true, // Skip balance check
})

// Check execution result
if (!result.execResult.exceptionError) {
  console.log('Transaction successful')
  console.log('Gas used:', result.totalGasSpent)
}
```

#### Transaction Pool

```ts
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### Receipts & Logs

```ts
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

### State Management

#### Account Impersonation

```ts
// Impersonate an account (fork mode only)
node.setImpersonatedAccount('0x1234...')

// Get current impersonated account
const impersonated = node.getImpersonatedAccount()

// Stop impersonating
node.setImpersonatedAccount(undefined)
```

Note: account impersonating doesn't actually do anything on tevmnode other than set the account property and is only used to implement it at the json-rpc level in actions like eth\_sendRawTransaction to let those actions know they should impersonate.

#### Event Filtering

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

### Node Properties

#### Status

The `status` property indicates the current state of the node:

```ts
console.log(node.status) // One of: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
```

#### Mode

The `mode` property indicates whether the node is running in fork or normal mode:

```ts
console.log(node.mode) // 'fork' or 'normal'
```

#### Logger

Built-in logging capabilities:

```ts
node.logger.debug('Detailed debugging information')
node.logger.info('General information')
node.logger.warn('Warning messages')
node.logger.error('Error information')
```

### Tevm Call Methods

The `tevmCall` family of methods provides direct EVM execution with extensive control and debugging capabilities:

#### tevmCall

Execute low-level EVM calls with detailed control:

```ts
import { tevmCall } from 'tevm/actions'
import { encodeFunctionData } from 'viem'
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

const result = await tevmCall(client, {
  to: '0x1234...',
  data: encodeFunctionData({
    abi,
    functionName: 'myFunction',
    args: [arg1, arg2]
  }),
  // Monitor EVM execution steps
  onStep: (step, next) => {
    console.log(`Opcode: ${step.opcode.name}, PC: ${step.pc}`)
    next?.()
  },
  // Monitor contract creation
  onNewContract: (data, next) => {
    console.log(`New contract at: ${data.address.toString()}`)
    next?.()
  },
  // Monitor call execution
  onBeforeMessage: (message, next) => {
    console.log(`Call to: ${message.to?.toString()}`)
    next?.()
  },
  onAfterMessage: (result, next) => {
    console.log(`Return: ${result.execResult.returnValue.toString('hex')}`)
    next?.()
  }
})
```

#### tevmContract

High-level contract interaction with EVM event monitoring:

```ts
import { tevmContract } from 'tevm/actions'
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

const result = await tevmContract(client, {
  abi,
  address: '0x1234...',
  functionName: 'myFunction',
  args: [arg1, arg2],
  // Monitor EVM execution
  onStep: (step, next) => {
    console.log(`Opcode: ${step.opcode.name}, Stack: ${step.stack.length}`)
    next?.()
  },
  onNewContract: (data, next) => {
    console.log(`New contract created: ${data.address.toString()}`)
    next?.()
  }
})
```

#### tevmDeploy

Contract deployment with execution monitoring:

```ts
import { tevmDeploy } from 'tevm/actions'
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

const result = await tevmDeploy(client, {
  abi,
  bytecode,
  args: [constructorArg1, constructorArg2],
  // Monitor deployment execution
  onStep: (step, next) => {
    console.log(`Executing: ${step.opcode.name}`)
    next?.()
  },
  onNewContract: (data, next) => {
    console.log(`Deployed at: ${data.address.toString()}`)
    next?.()
  }
})
```

### Extensibility

#### Adding Custom Functionality

```ts
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### State Copying

```ts
// Create a deep copy with independent state
const nodeCopy = await node.deepCopy()

// Fork from another node
const forkedNode = createTevmNode({
  fork: { transport: node }
})
```

### JSON-RPC Support

Tevm Node implements standard Ethereum JSON-RPC methods through its EIP-1193 interface:

#### Using EIP-1193

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard JSON-RPC calls
const blockNumber = await node.request({
  method: 'eth_blockNumber',
  params: []
})
```

#### Using Actions

```ts
import { ethActions } from 'tevm/decorators'

const node = createTevmNode().extend(ethActions())

// Using action methods
const blockNumber = await node.eth.getBlockNumber()
const balance = await node.eth.getBalance('0x1234...')
```

#### Supported Methods

* **State Access**
  * \`


## Package Reference

Tevm Node is built as a collection of modular packages. You can install the complete suite with `npm install tevm` or individual packages based on your needs.

### Installation Options

#### Complete Package

```bash
npm install tevm
```

```typescript
// Import from the main package
import { createTevmNode } from 'tevm'
import { callHandler } from 'tevm/actions'
import { http } from 'tevm/transport'
```

#### Individual Packages

```bash
npm install @tevm/node @tevm/actions
```

```typescript
// Import directly from packages
import { createTevmNode } from '@tevm/node'
import { callHandler } from '@tevm/actions'
```

### Core Packages

#### Node & Client

* **@tevm/node** - Core node implementation and management
  * Main entry point for creating and managing Tevm nodes
  * Blockchain and state management
  * Mining and block production

* **@tevm/memory-client** - In-memory Ethereum client
  * Viem-compatible client interface
  * Local state management
  * Transaction handling

#### EVM & Execution

* **@tevm/vm** - Virtual Machine implementation
  * EVM execution environment
  * Opcode handling
  * State transitions

* **@tevm/evm** - Low-level EVM operations
  * Bytecode execution
  * Gas calculation
  * Stack management

#### State & Storage

* **@tevm/state** - State management
  * Account state handling
  * Storage manipulation
  * State transitions

* **@tevm/blockchain** - Blockchain implementation
  * Block management
  * Chain reorganization
  * Header validation

### Transaction Handling

#### Transaction Processing

* **@tevm/tx** - Transaction utilities
  * Transaction signing
  * Gas estimation
  * Receipt generation

* **@tevm/txpool** - Transaction pool management
  * Pending transaction queue
  * Transaction ordering
  * Replacement handling

#### Block & Receipt Management

* **@tevm/block** - Block utilities
  * Block creation
  * Block validation
  * Chain management

* **@tevm/receipt-manager** - Transaction receipts
  * Receipt storage
  * Event logging
  * Gas usage tracking

### Client Integration

#### Communication

* **@tevm/jsonrpc** - JSON-RPC implementation
  * Standard Ethereum methods
  * Custom Tevm methods
  * Error handling

* **@tevm/http-client** - HTTP client
  * Remote node communication
  * Request batching
  * Error handling

#### Actions & Procedures

* **@tevm/actions** - High-level actions
  * Contract interaction
  * Account management
  * State queries

* **@tevm/procedures** - Common operations
  * State manipulation
  * Chain operations
  * Utility functions

### Smart Contract Tools

#### Contract Interaction

* **@tevm/contract** - Contract utilities
  * ABI handling
  * Function encoding
  * Event parsing

* **@tevm/precompiles** - Precompiled contracts
  * Standard precompiles
  * Custom implementations
  * Gas calculation

#### Contract Management

* **@tevm/predeploys** - Pre-deployed contracts
  * Standard contracts
  * Network-specific contracts
  * Contract deployment

### Utilities & Helpers

#### Core Utilities

* **@tevm/utils** - Common utilities
  * Address handling
  * Data encoding
  * Type conversion

* **@tevm/common** - Shared constants
  * Chain configurations
  * Network parameters
  * Common types

#### Development Tools

* **@tevm/decorators** - Function decorators
  * Method extension
  * Behavior modification
  * Utility wrappers

* **@tevm/errors** - Error handling
  * Error types
  * Error messages
  * Stack traces

#### Data Structures

* **@tevm/rlp** - RLP encoding/decoding
  * Data serialization
  * Network protocol
  * Storage format

* **@tevm/trie** - Merkle Patricia Tree
  * State storage
  * Proof verification
  * Tree manipulation

### Development & Debugging

#### Logging & Debugging

* **@tevm/logger** - Logging system
  * Configurable levels
  * Output formatting
  * Debug information

* **@tevm/effect** - Effect system
  * Side effect handling
  * Async operations
  * Error recovery

#### Storage & Types

* **@tevm/sync-storage-persister** - Storage persistence
  * State synchronization
  * Data persistence
  * Cache management

* **@tevm/client-types** - Type definitions
  * Interface definitions
  * Type exports
  * API documentation

### Best Practices

1. **Start Simple**
   * Begin with the complete `tevm` package
   * Only split into individual packages if you need to optimize bundle size

2. **Bundle Optimization**
   * Import from specific subpaths: `tevm/actions` instead of `@tevm/actions`
   * Use tree-shaking friendly imports

3. **Version Management**
   * Keep all @tevm/\* packages on the same version
   * Update packages together to avoid compatibility issues

4. **Development Workflow**
   * Use TypeScript for better type safety
   * Leverage provided type definitions
   * Follow the documentation for each package

### Related Topics

* [Architecture Overview](../introduction/architecture-overview)
* [API Reference](./methods)
* [GitHub Repository](https://github.com/evmts/tevm-monorepo)


import { Callout } from 'vocs/components'

## Call API

The Call API is one of the most important APIs in Tevm, covering 90% of use cases along with mining. It provides a powerful interface for executing EVM calls with extensive configuration options.

### Basic Usage

Tevm offers two API styles for using the Call API:

#### Client-based API (batteries included)

```ts
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

// Use tevmCall directly on the client object
const result = await client.tevmCall({
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // Default account
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH on mainnet
  data: '0x' // Empty call
})
```

#### Tree-shakable API

```ts
import { tevmCall } from 'tevm/actions'
import { createClient, custom } from 'viem'
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Viem client
const client = createClient({
  transport: custom(node),
})

// Use the tree-shakable action
const result = await tevmCall(client, {
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // Default account
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH on mainnet
  data: '0x' // Empty call
})
```

### Parameters

The `CallParams` type includes:

```ts
type CallParams = {
  // Required for most calls (except contract deployment)
  to?: Address
  // Input data for the call
  data?: Hex
  // Value in wei to send
  value?: bigint
  // Gas limit for the call
  gas?: bigint
  // Block tag to execute against
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to create a transaction
  createTransaction?: 'on-success' | 'always' | 'never' | boolean
  // Whether to skip balance checks
  skipBalance?: boolean
  // Whether to create an access list
  createAccessList?: boolean
  // Whether to create a debug trace
  createTrace?: boolean
  // From address (defaults to first account)
  from?: Address
  // Gas price settings
  maxFeePerGas?: bigint
  maxPriorityFeePerGas?: bigint
  // State overrides
  stateOverrideSet?: StateOverrideSet
  // Block overrides
  blockOverrideSet?: BlockOverrideSet
  // Event handlers for EVM execution
  onStep?: (data: InterpreterStep, next?: () => void) => void
  onNewContract?: (data: NewContractEvent, next?: () => void) => void
  onBeforeMessage?: (data: Message, next?: () => void) => void
  onAfterMessage?: (data: EVMResult, next?: () => void) => void
}
```

### Return Type

The `CallResult` includes:

```ts
type CallResult = {
  // Return data from the call
  rawData: Hex
  // Gas used by the EVM
  executionGasUsed: bigint
  // Total gas including intrinsic costs
  totalGasSpent?: bigint
  // Transaction hash if created
  txHash?: Hex
  // Logs emitted
  logs?: Log[]
  // Created contract address
  createdAddress?: Address
  // Access list if requested
  accessList?: Record<Address, Set<Hex>>
  // Debug trace if requested
  trace?: DebugTraceCallResult
  // Any errors that occurred
  errors?: TevmCallError[]
}
```

### Examples

#### 1. Simple Contract Call

Using client-based API:

```ts
import { createMemoryClient } from 'tevm'
import { encodeFunctionData, decodeFunctionResult, parseAbi } from 'viem'

// Example ERC20 ABI for 'balanceOf'
const abi = parseAbi([
  'function balanceOf(address account) view returns (uint256 balance)'
])

const client = createMemoryClient()

const result = await client.tevmCall({
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: encodeFunctionData({
    abi,
    functionName: 'balanceOf',
    args: ['0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266']
  })
})

const balance = decodeFunctionResult({
  abi,
  functionName: 'balanceOf',
  data: result.rawData
})
```

#### 2. Contract Deployment

Using client-based API:

```ts
import { createMemoryClient } from 'tevm'

// Simple contract bytecode (returns 42)
const bytecode = '0x6080604052348015600f57600080fd5b50602a60808190526040516100929190810190830190829052565b604051601f19601f830116810160405280815292829060208401853c80601f830112156100c057600080fd5b505b50505050610047806100d36000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80632096525514602d575b600080fd5b60336047565b604051603e91906059565b60405180910390f35b602a81565b6000819050919050565b6053816040565b82525050565b6000602082019050606c6000830184604c565b9291505056fea2646970667358221220f1c69e125f1a9f0c5e22a6fb4f9cb134c5b43496922c563e13731844a6e4d12d64736f6c63430008130033'

const client = createMemoryClient()

const result = await client.tevmCall({
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  data: bytecode,
  createTransaction: true
})

console.log('Contract deployed at:', result.createdAddress)
```

#### 3. State Override

Using client-based API:

```ts
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

const result = await client.tevmCall({
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  data: '0x',
  stateOverrideSet: {
    ['0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266']: {
      balance: 4096n, // 0x1000 as bigint
      nonce: 2n,
      code: '0x',
      state: {}
    }
  }
})
```

#### 4. Debug Trace

Using client-based API:

```ts
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

const result = await client.tevmCall({
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  data: '0x',
  createTrace: true
})

// Analyze the execution trace
if (result.trace) {
  result.trace.structLogs.forEach(log => {
    console.log(log.op, log.stack, log.memory)
  })
}
```

#### 5. EVM Event Handlers

You can attach event handlers to monitor EVM execution in real-time.

Using client-based API:

```ts
import { createMemoryClient } from 'tevm'
import { encodeFunctionData } from 'viem'

const client = createMemoryClient()

// Use EVM event handlers to monitor execution
const result = await client.tevmCall({
  from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
  to: contractAddress,
  data: encodeFunctionData({
    abi,
    functionName: 'myFunction',
    args: [arg1, arg2]
  }),
  // Monitor each EVM step
  onStep: (step, next) => {
    console.log(
      `Executing ${step.opcode.name} at PC=${step.pc}`,
      `Gas left: ${step.gasLeft.toString()}`,
      `Stack depth: ${step.stack.length}`
    )
    // Important: Call next to continue execution
    next?.()
  },
  // Monitor contract creation events
  onNewContract: (data, next) => {
    console.log(`New contract created at: ${data.address.toString()}`)
    next?.()
  },
  // Monitor messages (calls) before execution
  onBeforeMessage: (message, next) => {
    console.log(`Call to: ${message.to?.toString()}`, 
                `Value: ${message.value.toString()}`, 
                `Gas limit: ${message.gasLimit.toString()}`)
    next?.()
  },
  // Monitor messages (calls) after execution
  onAfterMessage: (result, next) => {
    console.log(`Call result: ${result.execResult.returnValue.toString('hex')}`,
                `Gas used: ${result.execResult.executionGasUsed.toString()}`)
    if (result.execResult.exceptionError) {
      console.error(`Error: ${result.execResult.exceptionError.error}`)
    }
    next?.()
  }
})
```

### Higher Level APIs

While `tevmCall`


***

title: VM & Submodules
description: Overview of the internal EVM, blockchain, state, receipts, and more

## VM & Submodules

[Tevm Node](https://github.com/evmts/tevm-monorepo) is built on a modular architecture that separates concerns into distinct submodules. This guide covers the internal components and their APIs.

### Overview

The main submodules are:

1\. **EVM (Ethereum Virtual Machine)** - Core [execution engine](https://ethereum.org/en/developers/docs/evm/)
2\. **Blockchain** - [Block and chain state](https://ethereum.org/en/developers/docs/blocks/) management
3\. **StateManager** - [Account and storage state](https://ethereum.org/en/developers/docs/accounts/) management
4\. **TxPool** - [Transaction mempool](https://ethereum.org/en/developers/docs/transactions/)
5\. **ReceiptsManager** - [Transaction receipts and logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)

### EVM Module

The EVM module handles bytecode execution and state transitions. It is based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm).

```ts
const vm = await node.getVm()
const evm = await vm.evm

// Direct EVM execution
const result = await evm.runCall({
  to: '0x...',
  data: '0x...',
  value: 0n,
  caller: '0x...',
})

// Full transaction execution (recommended)
const txResult = await vm.runTx({
  tx: transaction,
  block: block,
})
```

#### Key Features

\- **State Management**: Handles [account state](https://ethereum.org/en/developers/docs/accounts/), storage, and code execution
\- **Gas Metering**: Tracks [gas consumption](https://ethereum.org/en/developers/docs/gas/) during execution
\- **Precompiles**: [Built-in contract implementations](https://www.evm.codes/precompiled)
\- **EIP Support**: Implements various [Ethereum Improvement Proposals](https://eips.ethereum.org/)

#### Common Operations

```ts
// Check execution result
if (result.execResult.exceptionError) {
  console.error('Execution failed:', result.execResult.exceptionError)
} else {
  console.log('Return value:', result.execResult.returnValue)
  console.log('Gas used:', result.execResult.executionGasUsed)
}

// Access logs from execution
for (const log of result.execResult.logs) {
  console.log('Event:', {
    address: log.address,
    topics: log.topics,
    data: log.data
  })
}
```

### Blockchain Module

The blockchain module manages blocks and chain state. It is based on [`@ethereumjs/blockchain`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/blockchain).

```ts
const chain = (await node.getVm()).blockchain

// Get block by number or hash
const block = await chain.getBlock('latest')
const blockByHash = await chain.getBlock(blockHash)

// Add new block
await chain.putBlock(block)

// Delete block
await chain.delBlock(blockHash)

// Get block details
console.log({
  number: block.header.number,
  hash: block.hash(),
  parentHash: block.header.parentHash,
  stateRoot: block.header.stateRoot
})
```

#### Fork Support

```ts
// When forking, blocks are fetched from the parent chain
const forkedBlock = await chain.getBlock(blockNumber)

// Local blocks override forked blocks
await chain.putBlock(localBlock)
```

### StateManager

The StateManager handles account state and storage. It is based on [`@ethereumjs/statemanager`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/statemanager).

```ts
const state = (await node.getVm()).stateManager

// Account operations
const account = await state.getAccount(address)
await state.putAccount(address, account)

// Contract operations
await state.putContractCode(address, bytecode)
const code = await state.getContractCode(address)

// Storage operations
await state.putContractStorage(address, key, value)
const value = await state.getContractStorage(address, key)

// State snapshots
const snapshot = await state.dumpCanonicalGenesis()
await state.commit()
await state.revert()
```

#### Working with Accounts

```ts
// Create or update account
const account = {
  nonce: 1n,
  balance: 100n,
  storageRoot: EMPTY_ROOT,
  codeHash: EMPTY_HASH
}
await state.putAccount(address, account)

// Delete account
await state.deleteAccount(address)
```

### Transaction Pool

The TxPool manages pending transactions. It is based on [`@ethereumjs/tx-pool`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx-pool).

```ts
const pool = await node.getTxPool()

// Add transaction
await pool.add(transaction)

// Get pending transactions
const pending = await pool.getPendingTransactions()

// Remove transaction
await pool.removeByHash(txHash)

// Get transactions ordered by price
const ordered = await pool.txsByPriceAndNonce({
  baseFee: 10n
})
```

#### Transaction Validation

```ts
// Validate transaction before adding
try {
  await pool.validateTx(transaction)
  await pool.add(transaction)
} catch (error) {
  console.error('Invalid transaction:', error)
}
```

### ReceiptsManager

The ReceiptsManager handles [transaction receipts](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) and event logs.

```ts
const receipts = await node.getReceiptsManager()

// Get receipts for block
const blockReceipts = await receipts.getReceipts(blockHash)

// Get receipt by transaction hash
const txReceipt = await receipts.getReceiptByTxHash(txHash)

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: contractAddress,
  topics: [eventSignature]
})
```

#### Working with Logs

```ts
// Process event logs
for (const log of logs) {
  console.log({
    address: log.address,
    topics: log.topics,
    data: log.data,
    blockNumber: log.blockNumber,
    transactionHash: log.transactionHash,
    logIndex: log.logIndex
  })
}
```

### Best Practices

1\. **Use High-Level APIs**: Prefer `vm.runTx()` over direct EVM execution for full transaction support.

2\. **State Management**:
\- Use checkpoints for atomic operations
\- Clean up state after tests
\- Handle reverts properly

3\. **Gas Optimization**:
\- [Estimate gas](https://ethereum.org/en/developers/docs/gas/#why-are-gas-fees-necessary) before execution
\- Monitor gas usage in hot paths
\- Use appropriate gas limits

4\. **Error Handling**:
\- Check execution results
\- Handle exceptions gracefully
\- Validate inputs

### Related Topics

\- [JSON-RPC Support](./json-rpc)
\- [Managing State](../core/managing-state)
\- [Transaction Pool](../advanced/txpool)
\- [Receipts & Logs](../advanced/receipts-and-logs)
\- [EVM Opcodes Reference](https://www.evm.codes/)
\- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
\- [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)

**Up Next**\
\- [JSON-RPC Guide](./json-rpc)
\- [Advanced Usage](../advanced/txpool)


## Building a Debugger UI

These docs have not been checked for correctness yet. Use with caution

This example demonstrates how to create a minimal EVM debugger interface using [Svelte](https://svelte.dev) and Tevm Node. The debugger will show:

* Live opcode execution
* Stack contents
* Memory state
* Error messages
* Gas usage

### Project Setup

First, create a new Svelte project and install dependencies:

```bash
npm create vite@latest tevm-debugger -- --template svelte-ts
cd tevm-debugger
npm install tevm tevm/contract
```

### Components

#### 1. EVMDebugger.svelte

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte'
  import { createTevmNode } from 'tevm/node'
  import type { InterpreterStep } from 'tevm/evm'

  // Store execution state
  let steps: InterpreterStep[] = []
  let currentStep: InterpreterStep | null = null
  let errors: string[] = []
  let gasUsed = 0n
  let isRunning = false

  // Create Tevm Node
  const node = createTevmNode()
  let vm: Awaited<ReturnType<typeof node.getVm>>

  onMount(async () => {
    vm = await node.getVm()
    setupEventListeners()
  })

  function setupEventListeners() {
    // Track execution steps
    vm.evm.events?.on('step', (step, next) => {
      currentStep = step
      steps = [...steps, step]
      next?.()
    })

    // Track errors
    vm.evm.events?.on('afterMessage', (result, next) => {
      if (result.execResult.exceptionError) {
        errors = [...errors, result.execResult.exceptionError.error]
      }
      gasUsed = result.execResult.executionGasUsed
      next?.()
    })
  }

  // Clean up
  onDestroy(() => {
    vm?.evm.events?.removeAllListeners()
  })

  // Execute sample transaction
  async function runSampleTx() {
    isRunning = true
    steps = []
    errors = []

    try {
      await vm.runTx({
        tx: {
          to: '0x1234...',
          data: '0x...',  // Your transaction data
        }
      })
    } catch (error) {
      errors = [...errors, error.message]
    }

    isRunning = false
  }
</script>

<div class="debugger">
  <div class="controls">
    <button on:click={runSampleTx} disabled={isRunning}>
      {isRunning ? 'Running...' : 'Run Transaction'}
    </button>
    <div class="gas">Gas Used: {gasUsed.toString()}</div>
  </div>

  <div class="execution">
    <h3>Current Step</h3>
    {#if currentStep}
      <div class="step">
        <div>PC: {currentStep.pc}</div>
        <div>Opcode: {currentStep.opcode.name}</div>
        <div>Gas Left: {currentStep.gasLeft.toString()}</div>
        <div>Depth: {currentStep.depth}</div>
      </div>
    {/if}
  </div>

  <div class="stack">
    <h3>Stack</h3>
    {#if currentStep?.stack}
      <div class="stack-items">
        {#each currentStep.stack as item}
          <div class="stack-item">{item.toString(16)}</div>
        {/each}
      </div>
    {/if}
  </div>

  <div class="errors">
    <h3>Errors</h3>
    {#each errors as error}
      <div class="error">{error}</div>
    {/each}
  </div>

  <div class="history">
    <h3>Execution History ({steps.length} steps)</h3>
    <div class="steps">
      {#each steps as step}
        <div class="history-step">
          {step.opcode.name} (Gas: {step.gasLeft.toString()})
        </div>
      {/each}
    </div>
  </div>
</div>

<style>
  .debugger {
    padding: 1rem;
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(2, 1fr);
  }

  .controls {
    grid-column: 1 / -1;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  button {
    padding: 0.5rem 1rem;
    background: #4a5568;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .execution, .stack, .errors, .history {
    background: #2d3748;
    padding: 1rem;
    border-radius: 0.5rem;
    color: #e2e8f0;
  }

  .stack-items {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .stack-item {
    font-family: monospace;
    padding: 0.25rem;
    background: #4a5568;
    border-radius: 0.25rem;
  }

  .error {
    color: #fc8181;
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: #742a2a;
    border-radius: 0.25rem;
  }

  .steps {
    height: 200px;
    overflow-y: auto;
  }

  .history-step {
    padding: 0.25rem;
    border-bottom: 1px solid #4a5568;
    font-family: monospace;
  }
</style>
```

#### 2. App.svelte

```svelte
<script lang="ts">
  import EVMDebugger from './lib/EVMDebugger.svelte'
</script>

<main>
  <h1>Tevm Debugger</h1>
  <EVMDebugger />
</main>

<style>
  main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  h1 {
    color: #2d3748;
    margin-bottom: 2rem;
  }
</style>
```

### Advanced Features

#### Memory Viewer Component

```svelte
<script lang="ts">
  export let memory: Uint8Array
  export let startOffset = 0
  export let bytesPerRow = 16

  $: rows = chunk(memory, bytesPerRow)

  function chunk(array: Uint8Array, size: number) {
    const chunks = []
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size))
    }
    return chunks
  }

  function formatByte(byte: number) {
    return byte.toString(16).padStart(2, '0')
  }

  function formatAscii(byte: number) {
    return byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'
  }
</script>

<div class="memory-viewer">
  {#each rows as row, i}
    <div class="memory-row">
      <span class="offset">
        {(startOffset + i * bytesPerRow).toString(16).padStart(8, '0')}:
      </span>
      <span class="hex">
        {#each row as byte}
          {formatByte(byte)}
        {/each}
      </span>
      <span class="ascii">
        {#each row as byte}
          {formatAscii(byte)}
        {/each}
      </span>
    </div>
  {/each}
</div>

<style>
  .memory-viewer {
    font-family: monospace;
    white-space: pre;
  }

  .memory-row {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
  }

  .offset {
    color: #718096;
  }

  .hex {
    letter-spacing: 0.1em;
  }

  .ascii {
    color: #718096;
  }
</style>
```

#### Storage Viewer Component

```svelte
<script lang="ts">
  import type { Address } from 'tevm/utils'
  import { createTevmNode } from 'tevm/node'

  export let address: Address

  let storage = new Map<string, string>()
  let loading = false

  const node = createTevmNode()

  async function loadStorage() {
    loading = true
    try {
      const vm = await node.getVm()
      const dump = await vm.stateManager.dumpStorage(address)
      storage = new Map(Object.entries(dump))
    } catch (error) {
      console.error('Failed to load storage:', error)
    }
    loading = false
  }
</script>

<div class="storage">
  <button on:click={loadStorage} disabled={loading}>
    {loading ? 'Loading...' : 'Load Storage'}
  </button>

  {#if storage.size > 0}
    <div class="storage-items">
      {#each [...storage] as [slot, value]}
        <div class="storage-item">
          <span class="slot">{slot}:</span>
          <span class="value">{value}</span>
        </div>
      {/each}
    </div>
  {/if}
</div>

<style>
  .storage {
    padding: 1rem;
  }

  .storage-items {
    margin-top: 1rem;
  }

  .storage-item {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
    font-family: monospace;
  }

  .slot {
    color: #718096;
  }
</style>
```

### Usage

1. Create the project structure:

```
tevm-debugger/
├── src/
│   ├── lib/
│   │   ├── EVMDebugger.svelte
│   │   ├── MemoryViewer.svelte
│   │   └── StorageViewer.svelte
│   ├── App.svelte
│   └── main.ts
└── package.json
```

2. Run the development server:

```bash
npm run dev
```

3. Use the debugger:

```ts
// Example contract deployment
const bytecode = '0x...' // Your contract bytecode
await vm.runTx({
  tx: {
    data: bytecode
  }
})

// Example contract interaction
await vm.runTx({
  tx: {
    to: '0x...',    // Contract address
    data: '0x...',  // Encoded function call
  }
})
```

### Customization

#### Adding Transaction History

```svelte
<script lang="ts">
  import { writable } from 'svelte/store'

  const transactions = writable<{
    hash: string
    to: string
    data: string
    status: 'success' | 'error'
  }[]>([])

  vm.evm.events?.on('afterMessage', (result, next) => {
    transactions.update(txs => [...txs, {
      hash: result.execResult.hash?.toString() ?? '',
      to: result.execResult.to?.toString() ?? '',
      data: result.execResult.data?.toString('hex') ?? '',
      status: result.execResult.exceptionError ? 'error' : 'success'
    }])
    next?.()
  })
</script>

<div class="transactions">
  <h3>Transaction History</h3>
  {#each $transactions as tx}
    <div class="transaction" class:error={tx.status === 'error'}>
      <div>Hash: {tx.hash}</div>
      <div>To: {tx.to}</div>
      <div>Data: {tx.data}</div>
    </div>
  {/each}
</div>
```

#### Adding Gas Profiling

```svelte
<script lang="ts">
  const gasProfile = new Map<string, { count: number, totalGas: bigint }>()

  vm.evm.events?.on('step', (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = gasProfile.get(opName) ?? { count: 0, totalGas: 0n }
    stats.count++
    stats.totalGas += gasCost
    gasProfile.set(opName, stats)

    next?.()
  })
</script>

<div class="gas-profile">
  <h3>Gas Profile</h3>
  <table>
    <thead>
      <tr>
        <th>Opcode</th>
        <th>Count</th>
        <th>Total Gas</th>
      </tr>
    </thead>
    <tbody>
      {#each [...gasProfile] as [opcode, stats]}
        <tr>
          <td>{opcode}</td>
          <td>{stats.count}</td>
          <td>{stats.totalGas.toString()}</td>
        </tr>
      {/each}
    </tbody>
  </table>
</div>
```

### Related Topics

* [EVM Events](../api/evm-events)
* [Performance Profiler](../advanced/performance-profiler)


## Using with Ethers.js

This guide demonstrates how to use Tevm Node with Ethers.js, enabling seamless integration with the popular Ethereum development library.

### Basic Setup

```ts
import { createTevmNode } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'
import { BrowserProvider } from 'ethers'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Ethers provider
const provider = new BrowserProvider(node)

// Basic provider usage
const block = await provider.getBlockNumber()
const balance = await provider.getBalance('0x1234...')
```

### Contract Interaction

#### 1. Reading Contract State

```ts
import { Contract } from '@tevm/ethers'
import { parseAbi } from 'tevm'

// Contract setup
const abi = parseAbi([
  'function balanceOf(address) view returns (uint256)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
])

const tokenAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' // USDC
const contract = new Contract(tokenAddress, abi, provider)

// Read multiple values
const [balance, symbol, decimals] = await Promise.all([
  contract.balanceOf('0x1234...'),
  contract.symbol(),
  contract.decimals(),
])

console.log(`${symbol} Balance: ${formatUnits(balance, decimals)}`)
```

#### 2. Writing to Contracts

```ts
import { ContractTransactionResponse } from 'ethers'

// Get signer
const signer = await provider.getSigner()

const abi = parseAbi([
  'function transfer(address to, uint256 amount) returns (bool)',
])

const contract = new Contract(tokenAddress, abi, signer)

// Send transaction
const tx = await contract.transfer(
  '0x5678...',
  parseUnits('100', 6)
) as ContractTransactionResponse

// Wait for confirmation
const receipt = await tx.wait()
console.log('Transaction confirmed:', receipt.hash)
```

### Event Handling

#### 1. Listening for Events

```ts
const abi = parseAbi([
  'event Transfer(address indexed from, address indexed to, uint256 value)',
  'function transfer(address to, uint256 amount) returns (bool)',
])

const contract = new Contract(tokenAddress, abi, provider)

// Type-safe event handling
type TransferEvent = {
  from: string
  to: string
  amount: bigint
  event: any
}

const events: TransferEvent[] = []
contract.on('Transfer', (from, to, amount, event) => {
  events.push({ from, to, amount, event })
})

// Remove listener when done
contract.off('Transfer')
```

#### 2. Querying Past Events

```ts
const abi = parseAbi([
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])

const contract = new Contract(tokenAddress, abi, provider)

// Create filter
const filter = contract.filters.Transfer()

// Get past events
const events = await contract.queryFilter(filter, -1000, 'latest')

for (const event of events) {
  const { from, to, value } = event.args
  console.log('Historical transfer:', {
    from,
    to,
    value: formatUnits(value, 6),
  })
}
```

### Advanced Usage

#### 1. Contract Deployment

```ts
import { ContractFactory } from 'ethers'

const abi = parseAbi([
  'function getValue() view returns (uint256)',
])

// Get signer
const signer = await provider.getSigner()

// Create factory
const factory = new ContractFactory(abi, bytecode, signer)

// Deploy contract
const contract = await factory.deploy()
await contract.waitForDeployment()

console.log('Contract deployed to:', await contract.getAddress())
```

#### 2. Low-level Transaction Handling

```ts
// Create transaction
const tx = {
  to: '0x1234...',
  value: parseEther('1'),
  data: '0x',
}

// Sign transaction
const signer = await provider.getSigner()
const signedTx = await signer.signTransaction(tx)

// Send raw transaction
const hash = await provider.send('eth_sendRawTransaction', [signedTx])

// Wait for confirmation
const receipt = await provider.waitForTransaction(hash)
```

#### 3. Interface Encoding/Decoding

```ts
import { Interface } from 'ethers'
import { parseAbi } from 'tevm'

// Create interface
const abi = parseAbi([
  'function transfer(address to, uint256 amount) returns (bool)',
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])
const iface = new Interface(abi)

// Encode function data
const data = iface.encodeFunctionData('transfer', [
  '0x1234...',
  parseUnits('100', 6),
])

// Decode event logs
const log = receipt.logs[0]
const decodedLog = iface.parseLog({
  topics: log.topics,
  data: log.data,
})
```

### Testing with Ethers

```ts
import { expect } from 'chai'
import { loadFixture } from '@nomicfoundation/hardhat-network-helpers'
import { parseAbi } from 'tevm'

describe('Token Contract', () => {
  async function deployTokenFixture() {
    // Setup Tevm Node
    const node = createTevmNode()
    const provider = new BrowserProvider(node)
    const signer = await provider.getSigner()

    const abi = parseAbi([
      'function balanceOf(address) view returns (uint256)',
      'function transfer(address to, uint256 amount) returns (bool)',
    ])

    // Deploy contract
    const factory = new ContractFactory(abi, bytecode, signer)
    const token = await factory.deploy()
    await token.waitForDeployment()

    return { token, signer, provider }
  }

  it('Should handle basic operations', async () => {
    const { token, signer } = await loadFixture(deployTokenFixture)

    // Test initial state
    expect(await token.balanceOf(signer.address)).to.equal(initialSupply)

    // Test transfer
    await token.transfer('0x1234...', 100)
    expect(await token.balanceOf('0x1234...')).to.equal(100)
  })
})
```

### Best Practices

1. **Contract Initialization**:
   ```ts
   import { parseAbi } from 'tevm'
   import { Contract } from '@tevm/ethers'

   // Reuse contract instances
   const contracts = new Map<string, Contract>()

   function getContract(address: string): Contract {
     let contract = contracts.get(address)
     if (!contract) {
       const abi = parseAbi([
         'function balanceOf(address) view returns (uint256)',
         'function transfer(address to, uint256 amount) returns (bool)',
       ])
       contract = new Contract(address, abi, provider)
       contracts.set(address, contract)
     }
     return contract
   }
   ```

2. **Error Handling**:
   ```ts
   const abi = parseAbi([
     'function riskyFunction() returns (uint256)',
   ])
   const contract = new Contract(address, abi, provider)

   try {
     const tx = await contract.riskyFunction()
     await tx.wait()
   } catch (error) {
     if (error.code === 'CALL_EXCEPTION') {
       console.error('Contract call failed:', error.reason)
     } else if (error.code === 'NETWORK_ERROR') {
       console.error('Network error:', error.message)
     }
     throw error
   }
   ```

3. **Gas Management**:
   ```ts
   const abi = parseAbi([
     'function transfer(address to, uint256 amount) returns (bool)',
   ])
   const contract = new Contract(address, abi, provider)

   // Estimate gas with buffer
   const gasEstimate = await contract.transfer.estimateGas(
     recipient,
     amount
   )

   const tx = await contract.transfer(
     recipient,
     amount,
     {
       gasLimit: gasEstimate * 120n / 100n, // 20% buffer
     }
   )
   ```

4. **Event Management**:
   ```ts
   const abi = parseAbi([
     'event Transfer(address indexed from, address indexed to, uint256 value)',
   ])
   const contract = new Contract(address, abi, provider)

   // Clean up listeners
   function setupEventListeners(contract: Contract) {
     const handler = (...args) => {
       // Handle event
     }

     contract.on('Transfer', handler)

     return () => {
       contract.off('Transfer', handler)
     }
   }

   const cleanup = setupEventListeners(contract)
   // Later...
   cleanup()
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [Local Testing](./local-testing)
* [Forking Mainnet](./forking-mainnet)


## Forking Mainnet Example

These docs have not been checked for correctness yet. Use with caution

### Basic Fork Setup

```ts
import { createTevmNode } from 'tevm'
import { http } from 'viem'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 17_000_000n,
  },
  loggingLevel: 'debug',
})

await node.ready()

// Now any calls to an unknown account or contract
// will fetch the data from mainnet, but store the result locally for caching.
```

### Account Impersonation

```ts
// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60') // Binance 14

// Now you can run transactions "as" that address, no signature needed
const tx = createImpersonatedTx({
  to: '0x1234...',
  value: 1000000000000000000n, // 1 ETH
})

const vm = await node.getVm()
await vm.runTx({ tx })
```

### Working with Forked Contracts

```ts
// Example: Interacting with USDC on mainnet
const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

// Get the contract state from mainnet
const usdcContract = new Contract(USDC_ADDRESS, USDC_ABI)
const balance = await usdcContract.read.balanceOf(['0x1234...'])

// Modify state locally
await usdcContract.write.transfer(['0x5678...', 1000000]) // 1 USDC

// Changes only affect your local fork
const newBalance = await usdcContract.read.balanceOf(['0x1234...'])
```

### Fork at Specific Block

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 15_000_000n, // Fork from a specific block
  },
})

// Test historical state
const historicalBalance = await getBalance(address)
```

### Multiple Network Support

```ts
// Fork from different networks
const optimismNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io'),
  },
})

const arbitrumNode = createTevmNode({
  fork: {
    transport: http('https://arb1.arbitrum.io/rpc'),
  },
})
```

**Related**

* [Forking Guide](../core/forking)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)


## Local Testing

These docs have not been checked for correctness yet. Use with caution

This guide demonstrates how to use Tevm Node for local testing of [smart contracts](https://ethereum.org/en/developers/docs/smart-contracts/) and [transactions](https://ethereum.org/en/developers/docs/transactions/). For more background on testing Ethereum applications, see the [Smart Contract Testing Guide](https://ethereum.org/en/developers/docs/smart-contracts/testing/).

### Basic Test Setup

```ts
import { createTevmNode } from 'tevm'
import { createImpersonatedTx } from 'tevm/tx'
import { expect, test } from 'vitest' // or jest, mocha, etc.

test('Basic ETH transfer', async () => {
  // Create a new node instance
  const node = createTevmNode({
    miningConfig: { type: 'auto' }, // Mine blocks automatically
  })
  await node.ready()

  const vm = await node.getVm()

  // Create and run a transaction
  const tx = createImpersonatedTx({
    from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    value: 1000000000000000000n, // 1 ETH
  })

  const result = await vm.runTx({ tx })

  // Assert transaction succeeded
  expect(result.execResult.exceptionError).toBeUndefined()

  // Check recipient balance
  const account = await vm.stateManager.getAccount(tx.to)
  expect(account.balance).toBe(1000000000000000000n)
})
```

For more information on transaction execution, see the [EVM Execution Model](https://ethereum.org/en/developers/docs/evm/execution/).

### Contract Testing

#### 1. Deployment & Interaction

For background on contract deployment and interaction, see the [Contract Deployment Guide](https://ethereum.org/en/developers/docs/smart-contracts/deploying/).

```ts
import { Contract } from 'tevm/contract'
import { bytecode, abi } from './MyContract.json'

test('Deploy and interact with contract', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Deploy contract
  const deployTx = createImpersonatedTx({
    data: bytecode,
  })

  const result = await vm.runTx({ tx: deployTx })
  expect(result.execResult.exceptionError).toBeUndefined()

  const contractAddress = result.createdAddress
  expect(contractAddress).toBeDefined()

  // Create contract instance
  const contract = new Contract(contractAddress, abi)

  // Call contract method
  const callResult = await contract.read.getValue()
  expect(callResult).toBe(expectedValue)

  // Send transaction to contract
  const tx = await contract.write.setValue([newValue])
  const txResult = await vm.runTx({ tx })
  expect(txResult.execResult.exceptionError).toBeUndefined()

  // Verify state change
  const updatedValue = await contract.read.getValue()
  expect(updatedValue).toBe(newValue)
})
```

#### 2. Event Testing

For more information on events and logs, see the [Events and Logs Guide](https://ethereum.org/en/developers/docs/smart-contracts/anatomy/#events-and-logs).

```ts
test('Contract events', async () => {
  const node = createTevmNode()
  await node.ready()

  // Deploy contract
  const contract = await deployContract(node)

  // Create event filter
  node.setFilter({
    id: '0x1',
    address: contract.address,
    topics: [
      contract.interface.getEventTopic('ValueChanged'),
    ],
  })

  // Trigger event
  const tx = await contract.write.setValue([123])
  await vm.runTx({ tx })

  // Get event logs
  const receipts = await node.getReceiptsManager()
  const logs = await receipts.getLogs({
    fromBlock: 0n,
    toBlock: 'latest',
    address: contract.address,
  })

  expect(logs.length).toBe(1)
  expect(logs[0].topics[0]).toBe(contract.interface.getEventTopic('ValueChanged'))
})
```

### Complex Testing Scenarios

#### 1. State Management

For more information on state management, see the [Ethereum State Guide](https://ethereum.org/en/developers/docs/evm/state-machine/).

```ts
test('Complex state changes', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Create checkpoint
  await vm.stateManager.checkpoint()

  try {
    // Perform multiple state changes
    await performStateChanges(vm)

    // Verify intermediate state
    const intermediateState = await getState(vm)
    expect(intermediateState).toMatchSnapshot()

    // More changes
    await performMoreChanges(vm)

    // Commit changes
    await vm.stateManager.commit()
  } catch (error) {
    // Revert on failure
    await vm.stateManager.revert()
    throw error
  }
})
```

#### 2. Fork Testing

For more information on network forking, see the [Forking Guide](../core/forking).

```ts
test('Mainnet fork testing', async () => {
  const node = createTevmNode({
    fork: {
      transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      blockTag: 17_000_000n,
    },
  })
  await node.ready()

  // Impersonate a whale account
  node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

  // Test DeFi interactions
  const uniswap = new Contract(UNISWAP_ADDRESS, UNISWAP_ABI)
  const tx = await uniswap.write.swapExactTokensForTokens([/* ... */])

  const result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

#### 3. Time-based Testing

For more information on block timestamps and time-based operations, see the [Block Time Guide](https://ethereum.org/en/developers/docs/blocks/blocks-and-time/).

```ts
test('Time-dependent behavior', async () => {
  const node = createTevmNode({
    miningConfig: { type: 'interval', interval: 1000 },
  })
  await node.ready()
  const vm = await node.getVm()

  // Deploy time-locked contract
  const contract = await deployTimeLock(vm)

  // Try to withdraw (should fail)
  let tx = await contract.write.withdraw()
  let result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeDefined()

  // Advance time by mining blocks
  for (let i = 0; i < 100; i++) {
    await vm.blockchain.putBlock(createBlock({ timestamp: Date.now() + i * 1000 }))
  }

  // Try withdraw again (should succeed)
  tx = await contract.write.withdraw()
  result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

### Testing Utilities

#### 1. Account Management

For more information on Ethereum accounts, see the [Accounts Guide](https://ethereum.org/en/developers/docs/accounts/).

```ts
// Helper to setup test accounts
async function setupAccounts(vm) {
  const accounts = [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  ]

  for (const address of accounts) {
    await vm.stateManager.putAccount(address, {
      nonce: 0n,
      balance: 10000000000000000000n, // 10 ETH
    })
  }

  return accounts
}
```

#### 2. Transaction Helpers

For more information on transaction types and formats, see the [Transaction Types Guide](https://ethereum.org/en/developers/docs/transactions/transaction-types/).

```ts
// Helper to send ETH
async function sendEth(vm, from, to, value) {
  const tx = createImpersonatedTx({
    from,
    to,
    value,
  })

  return vm.runTx({ tx })
}

// Helper to deploy contract
async function deployContract(vm, bytecode, args = []) {
  const tx = createImpersonatedTx({
    data: bytecode + encodeConstructor(args),
  })

  const result = await vm.runTx({ tx })
  return result.createdAddress
}
```

### Related Topics

* [Viem Testing Guide](https://viem.sh/docs/testing/overview.html)
* [EthereumJS VM](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/vm)
* [JSON-RPC Methods](../api/json-rpc)
* [Contract reference](/reference/contract)
* [State Management](../core/managing-state)

### Replaying Contracts with Shadow Events

```ts
import { createTevmNode } from 'tevm'
import { http } from 'viem'

// Create a node that forks from mainnet
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Get the transaction receipt to find its index
const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: ['0x...'] // Original tx hash
})

// Get the block and its transactions
const block = await node.request({
  method: 'eth_getBlockByNumber',
  params: [(receipt.blockNumber - 1n).toString(16), true]
})

// Replay all transactions before our target tx
for (let i = 0; i < receipt.transactionIndex; i++) {
  const tx = block.transactions[i]
  await node.getVm().runTx({ tx })
}

// Deploy modified contract with new event
const modifiedBytecode = '0x...' // Contract bytecode with new event
await node.setAccount({
  address: receipt.contractAddress,
  deployedBytecode: modifiedBytecode
})

// Now run the target transaction
const result = await node.getVm().runTx({
  tx: block.transactions[receipt.transactionIndex]
})

// The result will include the new shadow event
console.log(result.execResult.logs)
```

### Estimating Gas for Token Approval

```ts
import { createTevmNode } from 'tevm/node'
import { encodeFunctionData } from 'viem'

const node = createTevmNode()
const vm = await node.getVm()

// First approve the token
const approveTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'approve',
    args: [spenderAddress, amount]
  })
}

// Estimate gas by running the tx
const result = await vm.runTx({ tx: approveTx })
console.log('Gas used:', result.execResult.executionGasUsed)

// Now we can estimate transferFrom
const transferFromTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'transferFrom',
    args: [ownerAddress, recipientAddress, amount]
  })
}

const transferResult = await vm.runTx({ tx: transferFromTx })
console.log('TransferFrom gas:', transferResult.execResult.executionGasUsed)
```


## Using with Viem

This guide demonstrates how to use Tevm Node with Viem, enabling seamless integration with Viem's powerful Ethereum development tools.

Note the package that owns the viem integration is the [tevm/memory-client](https://github.com/evmts/tevm-monorepo/blob/main/packages/memory-client/docs/globals.md) package.

### Basic Setup

The recomended API for interacting with viem is the tree-shakable API using `createClient` and importing actions from `viem/actions` and `tevm` packages.

```ts
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'
import { createClient, custom } from 'viem'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Viem client
const client = createClient({
  // Use Tevm node as the viem transport
  transport: custom(node),
})

// use viem actions
import {getBlockNumber} from 'viem/actions'
await getBlockNumber(client)

// use custom tevm actions too
import {tevmDumpState} from 'tevm'
await tevmDumpState(client)
```

For a more convenient API when tree shaking isn't a concern use `createMemoryClient` which produces a batteries included client with every viem and tevm action attatched.

```ts
import { createMemoryClient } from 'tevm'

// Create Viem client
const client = createMemoryClient()

// use viem actions
await client.getBlockNumber(client)

await client.tevmDumpState(client)
```

### Using viem

Use [viem](/examples/viem) via actions. All viem and tevm actions are available as tree shakable actions.

#### 1. Public actions

Use [viem's public actions](https://viem.sh/docs/actions/public/introduction) to read from locally running evm node

```ts
// Get latest block
const block = await client.getBlock()

// Get balance
const balance = await client.getBalance({
  address: '0x1234...',
})

// Get transaction count
const nonce = await client.getTransactionCount({
  address: '0x1234...',
})
```

#### 2. Wallet actions

All of [viem's](/examples/viem) [`Wallet actions`](https://viem.sh/docs/actions/wallet/introduction) are available via passing in an `account`

```ts
// Import PREFUNDED_ACCOUNTS from tevm
import { PREFUNDED_ACCOUNTS } from 'tevm'

// Create client with prefunded test account
const client = createMemoryClient({
  account: PREFUNDED_ACCOUNTS[0], // First prefunded account with 10000 ETH
})

// Send transaction using prefunded account
const hash = await client.sendTransaction({
  to: '0x1234567890123456789012345678901234567890',
  value: parseEther('1'),
})

// Deploy contract using prefunded account
const { contractAddress } = await client.deployContract({
  abi,
  bytecode,
  account: PREFUNDED_ACCOUNTS[0],
})

```

#### 3. Test actions

All of viem's [`Test actions`](https://viem.sh/docs/actions/test/introduction) are available for testing and debugging

```ts
// Import test actions
import { mine, setBalance, setNextBlockTimestamp, setBlockTimestamp } from 'viem/test'

// Mine blocks
await client.mine({ blocks: 1 })

// Set account balance
await client.setBalance({
  address: '0x1234567890123456789012345678901234567890',
  value: parseEther('100')
})

// Manipulate block timestamps
await client.setNextBlockTimestamp(1695311333n)
await client.setBlockTimestamp(1695311333n)

// Combine actions for test scenarios
await client.setBalance({
  address: '0x1234567890123456789012345678901234567890',
  value: parseEther('100')
})
await client.mine({ blocks: 5 })
```

These test actions are particularly useful for:

* Setting up specific test scenarios
* Manipulating blockchain state for testing
* Time-traveling through blocks
* Debugging smart contract interactions

### Tevm Actions

Tevm provides additional actions beyond standard [viem](/examples/viem) functionality for enhanced testing and debugging capabilities.

#### 1. Contract Interactions

```ts
import { tevmContract, tevmCall, tevmDeploy } from 'tevm/actions'

// Call a contract method
const result = await tevmContract(client, {
  abi: myContractAbi,
  functionName: 'balanceOf',
  args: ['0x1234...'],
})

// Low-level contract call
const callResult = await tevmCall(client, {
  to: '0x1234...',
  data: '0x...',
})

// Deploy a contract
const deployResult = await tevmDeploy(client, {
  abi: myContractAbi,
  bytecode: '0x...',
})
```

#### 2. Account Management

```ts
import { tevmGetAccount, tevmSetAccount } from 'tevm/actions'

// Get account state
const account = await tevmGetAccount(client, {
  address: '0x1234...',
})

// Modify account state
await tevmSetAccount(client, {
  address: '0x1234...',
  balance: parseEther('100'),
  code: '0x...',  // Optional contract bytecode
  storage: {      // Optional storage slots
    '0x0': '0x1'
  }
})
```

#### 3. Other Tevm actions

You can use `tevmLoadState` and `tevmDumpState` to persist state to disk or local storage.

`tevmMine` is an important action for mining new blocks.

```ts
// the viem actions are prefixed with tevm and exported from tevm and tevm/memory-client
import { tevmDumpState, tevmLoadState, tevmMine } from 'tevm'

// Save current state
const state = await tevmDumpState(client)

// Load previously saved state
await tevmLoadState(client, {
  state: state
})

// Mine blocks with Tevm
await tevmMine(client, {
  blocks: 5
})
```

These Tevm-specific actions provide powerful capabilities for:

* Direct contract interactions and deployment
* Fine-grained account state manipulation
* Complete EVM state management
* Advanced testing scenarios

### Complete Action Reference

#### Public Actions

All [viem's public actions](https://viem.sh/docs/actions/public/introduction) are supported:

##### Contract Interactions

* [`call`](https://viem.sh/docs/actions/public/call)
* [`readContract`](https://viem.sh/docs/contract/readContract)
* [`simulateContract`](https://viem.sh/docs/contract/simulateContract)
* [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas)
* [`estimateGas`](https://viem.sh/docs/actions/public/estimateGas)
* [`getBytecode`](https://viem.sh/docs/contract/getBytecode)

##### Block & Transaction

* [`getBlock`](https://viem.sh/docs/actions/public/getBlock)
* [`getBlockNumber`](https://viem.sh/docs/actions/public/getBlockNumber)
* [`getBlockTransactionCount`](https://viem.sh/docs/actions/public/getBlockTransactionCount)
* [`getTransaction`](https://viem.sh/docs/actions/public/getTransaction)
* [`getTransactionCount`](https://viem.sh/docs/actions/public/getTransactionCount)
* [`getTransactionReceipt`](https://viem.sh/docs/actions/public/getTransactionReceipt)
* [`waitForTransactionReceipt`](https://viem.sh/docs/actions/public/waitForTransactionReceipt)

##### Account & Chain

* [`getBalance`](https://viem.sh/docs/actions/public/getBalance)
* [`getChainId`](https://viem.sh/docs/actions/public/getChainId)
* [`getGasPrice`](https://viem.sh/docs/actions/public/getGasPrice)
* [`estimateFeesPerGas`](https://viem.sh/docs/actions/public/estimateFeesPerGas)
* [`getStorageAt`](https://viem.sh/docs/actions/public/getStorageAt)

#### Test Actions

All [viem's test actions](https://viem.sh/docs/actions/test/introduction) are supported:

##### Block & Mining

* [`mine`](https://viem.sh/docs/actions/test/mine)
* [`setAutomine`](https://viem.sh/docs/actions/test/setAutomine)
* [`setIntervalMining`](https://viem.sh/docs/actions/test/setIntervalMining)
* [`setBlockGasLimit`](https://viem.sh/docs/actions/test/setBlockGasLimit)
* [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval)
* [`setNextBlockBaseFeePerGas`](https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas)
* [`setNextBlockTimestamp`](https://viem.sh/docs/actions/test/setNextBlockTimestamp)

##### Account & State

* [`setBalance`](https://viem.sh/docs/actions/test/setBalance)
* [`setCode`](https://viem.sh/docs/actions/test/setCode)
* [`setNonce`](https://viem.sh/docs/actions/test/setNonce)
* [`setStorageAt`](https://viem.sh/docs/actions/test/setStorageAt)
* [`setCoinbase`](https://viem.sh/docs/actions/test/setCoinbase)
* [`setMinGasPrice`](https://viem.sh/docs/actions/test/setMinGasPrice)

##### State Management

* [`snapshot`](https://viem.sh/docs/actions/test/snapshot)
* [`revert`](https://viem.sh/docs/actions/test/revert)
* [`reset`](https://viem.sh/docs/actions/test/reset)
* [`dumpState`](https://viem.sh/docs/actions/test/dumpState)
* [`loadState`](https://viem.sh/docs/actions/test/loadState)

#### Wallet Actions

All [viem's wallet actions](https://viem.sh/docs/actions/wallet/introduction) are supported:

##### Account Management

* [`getAddresses`](https://viem.sh/docs/actions/wallet/getAddresses)
* [`requestAddresses`](https://viem.sh/docs/actions/wallet/requestAddresses)

##### Transaction Operations

* [`prepareTransactionRequest`](https://viem.sh/docs/actions/wallet/prepareTransactionRequest)
* [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction)
* [`sendRawTransaction`](https://viem.sh/docs/actions/wallet/sendRawTransaction)
* [`signTransaction`](https://viem.sh/docs/actions/wallet/signTransaction)

##### Signing Operations

* [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage)
* [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData)

##### Chain Management

* [`addChain`](https://viem.sh/docs/actions/wallet/addChain)
* [`switchChain`](https://viem.sh/docs/actions/wallet/switchChain)

##### Permissions & Assets

* [`getPermissions`](https://viem.sh/docs/actions/wallet/getPermissions)
* [`requestPermissions`](https://viem.sh/docs/actions/wallet/requestPermissions)
* [`watchAsset`](https://viem.sh/docs/actions/wallet/watchAsset)

### What is a Memory Client Exactly?

Like the viem PublicClient or WalletClient, a MemoryClient is just a viem client with a bunch of actions attatched to it.

Below we make a `MemoryClient` from scratch

```typescript
// We are going to create a MemoryClient from scratch
// const memoryClient = createMemoryClient({
//   common: optimism,
//   fork: {
//     transport: http('https://mainnet.optimism.io')
//   }
// })

/**
 * Step 1: Create a Fork transport
 * This is the transport tevm will fork the latest block of similar to anvil or hardhat
 * Use any viem transport or EIP-1193 provider for this
 */
import { http } from 'viem'

const forkTransport = http('https://mainnet.optimism.io')

/**
 * Step 2: Create a TevmNode
 * This is the low level ethereum node powering the memory client
 * Extend the provider with an EIP-1193 node.request function
 * This is a function viem will use to resolve json-rpc requests
 */
import {createTevmNode} from 'tevm'
import {requestEip1193} from 'tevm/decorators'

const node = createTevmNode({
  fork: {
    transport: forkTransport
  }
  // extend into EIP-1193 request provider
}).extend(requestEip1193())

/**
 * Step 3: Create a viem client extending with tevm
 * Tevm doesn't have it's own API it just plugs into Viem and ethers
 */
import { custom, createClient, publicActions, testActions, walletActions } from 'viem'
import { tevmViemActions } from 'tevm/memory-client'

const memoryClientFromScratch = createClient({
  // Use the tevm node as the viem transport
  transport: custom(node),
})
// Add powerful custom tevm actions such as tevmCall tevmContract tevmMine tevmDeploy tevmSetAccount and more
// All actions available as tree shakable actions too
  .extend(tevmViemActions())
// Add viem public actions like call readContract estimateGas etc.
  .extend(publicActions)
// Add viem wallet actions like writeContract sendRawTransaction etc
  .extend(walletActions)
// Add viem test actions like setBalance setCode etc.
  .extend(testActions({ mode: 'anvil' }))
```

The above code breaks down what a MemoryClient is

Breaking down a MemoryClient succinctly breaks down all of Tevm

##### 1. Based on Viem Transports like `http`

Tevm uses EIP-1193 so it composes with all libraries including viem wagmi ethers and more. In the above code we fork a network using a viem transport that follows EIP-1193.

##### 2. In memory EVM with `createTevmNode`

We create a TevmNode in memory rather than talking to one over http. This can be done using `createTevmNode`. We then turn our node into an EIP-1193 provider so it can be used as a transport.

##### 3. Plugs into viem

We use our TevmNode as our transport and build a client using viem actions imported directly from viem along with some tevm actions that follow viem patterns but add advanced functionality.


## Architecture Overview

These are advanced docs for those looking to contribute to Tevm or those looking to learn more about it's internals.  These docs will go into the low level architecture of [TevmNode](https://github.com/evmts/tevm-monorepo/blob/main/packages/node/docs/type-aliases/TevmNode.md). To focus on the high level api go straight to the [viem docs](../examples/viem.mdx).

Note: for most people it is recomended to use the higher level [viem api](../getting-started/viem.mdx).

### Actions api

To focus on being tree shakable, Tevm is broken up into Objects and Actions. This pattern will be familiar to those who have used [viem](https://viem.sh/).

#### Objects

Objects in Tevm are:

* Stateful components that maintain data and state
* Come in tree shakable forms or with actions on the object
* Similar to structs in other languages

#### Actions

Actions in Tevm are:

* Pure functions that take an object as their first parameter
* Tree-shakable operations that can be imported individually
* Can also optionally be on prototype
* Single-purpose utilities that perform specific tasks
* Composable pieces that can be combined for complex operations

For example, an action like `getAccountHandler` takes a `TevmNode` object and returns a function for getting account details:

Objects in Tevm include:

* [`TevmNode`](/reference/node)
* Low level Node components such as [`Evm`](/reference/evm) and [`Blockchain`](/reference/blockchain)
* Tevm shares objects with viem such as the [ViemClient](https://viem.sh/docs/clients/public.html)

These objects have tree shakable actions that can be imported from their respective actions. Here's an example:

```typescript
import { createTevmNode } from 'tevm'
import { getAccountHandler } from 'tevm/actions'

const node = createTevmNode()
const getAccount = getAccountHandler(node)

// Use the action
const account = await getAccount({
  address: '0x...'
})
```

The most important actions are the `TevmNode` actions from [`tevm/actions`](/reference/actions). There are also viem actions in [tevm/memory-client](/reference/memory-client).

### MemoryClient

MemoryClient is a viem client with every viem and tevm action included on prototype so you don't need to import them as actions. This is more convenient but less tree shakable.

```typescript
import { createMemoryClient } from 'tevm/memory-client'

const client = createMemoryClient()

// All viem actions are available directly on memory client
await client.getContractCode({
  address: '0x...'
})

// custom tevm actions corresponding to the most popular TevmNode actions
// are available prefixed with tevm
const state = await client.tevmDumpState()
```

See [viem guide on tree shakable actions](https://wagmi.sh/react/guides/viem) for more.

To use in tree shakable way you must create a TevmTransport and pass that into `createClient`. See [viem tevm docs](../examples/viem.mdx)

### What is Tevm Node?

[Tevm Node](https://github.com/evmts/tevm-monorepo) is a JavaScript implementation of an Ethereum node that can run in any JavaScript environment - browsers, Node.js, or other runtimes. It provides a complete [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/) with state management, transaction processing, and JSON-RPC support.

To use in tree shakable way simply import actions to use with tevm node

```typescript
// create a tevm node
import {createTevmNode} from 'tevm'
// import actions from tevm/actions
import {getAccountHandler} from 'tevm/actions'

const node = createTevmNode()

const getAccount = getAccountHandler(node)

const account = getAccount({address: `0x...`})
```

You can also interact with lower level components like evm, statemanager, blockchain and more via [advanced apis](../reference/index.mdx).

### What can you do with Tevm Node?

Tevm has a lot of use cases many which are covered in the examples section

1. Anything viem can do as tevm is an extension of viem's capabilities
2. Simulate blocks and transactions locally. Hook directly into evm execution
3. Estimate gas with no network requests and no loading setupEventListeners
4. Build an EVM simulator like [svvy.sh](https://svvy.sh)
5. Test your JavaScript against an anvil compatible fork in JavaScript
6. Debug evm tx step by step
7. Optimistic ui updates when tx are sent
8. And more!

### Core Architecture

[TevmNode](/reference/node) is built on several key components that work together:

#### 1. Virtual Machine (EVM)

* Core execution engine that runs [EVM bytecode](https://ethereum.org/en/developers/docs/evm/opcodes/)
* Handles state transitions and gas metering
* Based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm)

Example usage:

```typescript
const vm = await node.getVm()
const result = await vm.runCode({
  code: '0x60806040...',
  gasLimit: 21000n
})
```

#### 2. State Manager

* Manages account balances, contract code, and storage
* Supports forking from live networks
* Implements caching and lazy loading

See [State](/reference/state) for api info

#### 3. Transaction Pool (Mempool)

* Manages pending transactions
* Orders transactions by gas price
* Validates transaction requirements

See [Transaction Pool](/reference/txpool) for api info

#### 4. Blockchain

* Maintains block history and chain state
* Handles block production (mining)
* Manages chain reorganizations

See [Blockchain](/reference/blockchain) for api info

#### 5. Receipts Manager

* Caches transaction outcomes
* Manages event logs and filters
* Useful for implementing optimistic updates

See [Receipt Manager](/reference/receipt-manager) for api info

### Available APIs

Tevm Node provides several layers of APIs for different use cases:

#### 1. High-Level Actions

Most functionality in Tevm is done via tree shakable actions including JSON-RPC compatabile actions.

The most commonly used actions are provided as handlers:

```ts
import { createTevmNode } from 'tevm'
import { callHandler, mineHandler, getAccountHandler } from 'tevm/actions'

// Create a Tevm node
const node = createTevmNode()

// Execute contract calls
const result = await callHandler(node)({
  to: contractAddress,
  data: calldata
})

// Mine pending transactions
await mineHandler(node)()

// Read account state
const account = await getAccountHandler(node)({
  address: accountAddress
})
```

#### 2. JSON-RPC Interface

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard Ethereum JSON-RPC calls
const balance = await node.request({
  method: 'eth_getBalance',
  params: [address, 'latest']
})
```

#### 3. Direct VM Access

```ts
const vm = await node.getVm()

// Low-level EVM execution
const result = await vm.runTx({
  tx: transaction,
  block: block
})

// State management
await vm.stateManager.putAccount(address, account)
```

#### 4. Contract Utilities

```typescript
import { createContract } from 'tevm/contract'

// Type-safe contract interactions
const contract = createContract({
  humanReadableAbi: ['function transfer(address to, uint256 amount)'],
  address: '0x123...'
})

// Write operations
const action = contract.write.transfer('0x456...', 100n)

// Read operations
const balance = await contract.read.balanceOf('0x789...')
```

You can also use the tevm bundler for automatic contract compilation:

```typescript
// Import Solidity contracts directly
import { ERC20 } from './ERC20.sol'

// Contract type information is automatically generated
const contract = createContract({
  abi: ERC20.abi,
  address: '0x123...'
})
```

### Key Features

#### 1. Forking

Fork from any live network or another Tevm instance:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest'
  }
})
```

#### 2. Mining Modes

Configure how transactions are processed:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto' // Mine every transaction
    // Or 'interval', 'manual', 'gas'
  }
})
```

#### 3. Custom Precompiles

Extend the EVM with JavaScript functions:

```ts
const precompile = definePrecompile({
  address: '0x123...',
  call: async (input) => {
    // Custom logic
    return {
      returnValue: result,
      executionGasUsed: 100n
    }
  }
})
```

#### 4. State Management

Direct control over blockchain state:

```ts
// Modify account state
await node.setAccount({
  address: '0x123...',
  balance: 100n,
  code: '0x...',
  storage: { /* ... */ }
})

// Create checkpoints
await vm.stateManager.checkpoint()
await vm.stateManager.commit() // or .revert()
```

### Common Use Cases

1. **Local Development**
   * Run a complete Ethereum environment locally
   * Test contracts without external networks
   * Simulate complex scenarios

2. **Testing**
   * Unit test smart contracts
   * Integration test DApp interactions
   * Fork mainnet for realistic tests

3. **Transaction Simulation**
   * Preview transaction outcomes
   * Estimate gas costs accurately
   * Debug failed transactions

4. **State Manipulation**
   * Modify account balances
   * Override contract state
   * Test edge cases

### Integration Examples

#### With Viem

```typescript
import { createPublicClient, custom, http } from 'viem'
import { mainnet } from 'viem/chains'

// Create a Tevm node
const node = createTevmNode({
  fork: {
    url: 'https://mainnet.infura.io/v3/YOUR-KEY'
  }
})

// Create a viem client using Tevm
const client = createPublicClient({
  transport: custom(node.request),
  chain: mainnet
})

// Use viem actions
const balance = await client.getBalance({
  address: '0x...'
})
```

#### With Ethers.js

```typescript
import { BrowserProvider } from 'ethers'

const node = createTevmNode()
const provider = new BrowserProvider(node)

// Use ethers.js functionality
const balance = await provider.getBalance('0x...')
const block = await provider.getBlock('latest')
```

### Next Steps

* [Core Concepts](../core/create-tevm-node)
* [Viem docs](../examples/viem.mdx)
* [API Reference](../api/methods)
* [Examples](../examples/local-testing)
* [GitHub Repository](https://github.com/evmts/tevm-monorepo)


## What is Tevm Node?

Tevm Node is an in-browser & Node.js-compatible Ethereum Virtual Machine (EVM) environment. It provides a complete Ethereum execution environment, powered by JavaScript, that you can run:

* **In Node.js** for local development and testing
* **In the Browser** for advanced user experiences (offline simulation, real-time testing)
* **In Deno, Bun**, or any modern JavaScript runtime

### Key Features

* **Forking:** Fork from any EVM-compatible network (mainnet, testnet) with efficient caching
* **Transaction Pool:** Track and manage pending transactions locally
* **Flexible Mining:** Choose between automatic, interval-based, manual, or gas-limit-based mining
* **Zero Native Dependencies:** Works seamlessly in browsers and JavaScript runtimes
* **Highly Extensible:** Customize the VM, add precompiles, handle receipts, and more

### Quick Example

Tevm is a viem transport along with a viem extension to add the functionality of running an in memory node to viem.

The tevmNode can be seen via `client.transport.tevm`

```ts
import { createMemoryClient, http } from 'tevm'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io')
  }
})

const tevmNode = client.transport.tevm

const vm = await tevmNode.getVm()
console.log(await vm.blockchain.getBlockByTag('latest'))
```

It is not recomended to interact directly with the TevmNode but to instead use the viem actions api along with custom tevm actions.

### Why Tevm Node?

* **Browser & Local Execution:** Improved latency and advanced debugging capabilities
* **Optimistic Updates:** Preview transaction effects before on-chain confirmation
* **Lightweight:** Minimal overhead compared to full Ethereum nodes
* **Network Independent:** Test and develop without real network constraints

### Why viem

Tevm minimizes it's api surface and is easy to use because it [uses viem](../getting-started/viem.mdx) as it's API rather than forcing users to learn a bespoke api. If you know viem you already know ethers.

Note: [ethers is also supported](../getting-started/ethers.mdx)

### Next Steps

* [Why JavaScript for Ethereum?](./why-run-ethereum-in-js)
* [Architecture Overview](./architecture-overview)


## Why run Ethereum in JavaScript?

### 1. Advanced Gas Estimation & Local Execution

Running the EVM locally removes round-trip latency to a remote node. You can do:

* Bulk simulation or multi-tx simulation
* Real-time "dry run" of transactions
* Faster dev/test cycles

### 2. User Experience Enhancements

* **Offline** or *local-first* capabilities
* **Optimistic UI** updates with local simulation
* No reliance on ephemeral test networks

### 3. Testing & Debugging

* Fine-grained EVM introspection
* Deterministic environment
* Light footprint – no external server needed

### 4. Ecosystem & Portability

* Portable across Node.js, browsers, and serverless
* Works with standard EVM interfaces
* Integrates well with modern JS/TS tooling


import { Callout } from 'vocs/components'

## Getting Started with Ethers

Tevm is an EIP-1193 provider and works with any library that follows the same standared including `ethers`, `thirdweb`, `ponder` and many others.
Though it is primarily built for `viem` it stays provider-agnostic.

### Installation

:::code-group
```bash [npm]
npm install tevm ethers@latest
```

```bash [pnpm]
pnpm install tevm ethers@latest
```

```bash [yarn]
yarn add tevm ethers@latest
```
:::

### Sample code

```ts [ethers-quickstart.mts]
import {createMemoryClient, http, parseAbi} from 'tevm'
import {optimism} from 'tevm/common'
import {requestEip1193} from 'tevm/decorators'
import {BrowserProvider, Wallet} from 'ethers'
import {parseUnits} from 'ethers/utils'
// The tevm/ethers package has a typesafe contract instance but you can use regular ethers contract too
import {Contract} from '@tevm/ethers'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism
  },
})

const provider = new BrowserProvider(client)
const signer = Wallet.createRandom(provider)

const blockNumber = await provider.getBlockNumber()
console.log(blockNumber)

const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"

const greeterAbi = parseAbi([
    'function greet() view returns (string)',
    'function setGreeting(string memory _greeting) public',
])

const greeter = new Contract(greeterContractAddress, greeterAbi, signer)


const getGreeting = async () => await greeter.greet()

const setGreeting = async newGreeting => {
  const txn = await greeter.setGreeting(newGreeting)
  return txn.hash
}

await client.setBalance({
  address: signer.address,
  value: parseUnits("1.0", "ether")
})

console.log(`Original greeting: ${await getGreeting()}`)
console.log(`Txn hash: ${await setGreeting("Hi")}`)
await client.mine({blocks: 1})
console.log(`Changed greeting: ${await getGreeting()}`)
```

:::details[Explanation]
:::


import { Callout } from 'vocs/components'

## Overview

Tevm Node is an Ethereum Node that runs in all JavaScript environments.
It's like [hardhat](https://hardhat.org/) or [anvil](https://book.getfoundry.sh/anvil/), but provides these advantages:

* Zero native dependencies (runs in browser and Node.js)
* Connects directly to [`viem`](https://viem.sh/) or [`ethers`](https://docs.ethers.org/v6/)
* Provides fine-grained control over the EVM execution environment for advanced use cases and speedy ux
* Implement advanced feature like zero-spinner gas estimation, optimistic updates, and advanced transaction simulation

If you know how to use `viem` or `ethers`, you already know how to use Tevm Node and can get started right away.

### Quick Example

The following code simple deploys, writes, and reads from a contract.

* The API for interacting with Tevm is [viem](https://viem.sh)
* TevmNode runs an ethereum node in memory rather than using json-rpc over http

```ts
import { createMemoryClient, PREFUNDED_ACCOUNTS } from 'tevm'
import { SimpleContract } from 'tevm/contract'

const client = createMemoryClient()

const contract = SimpleContract.withAddress(`0x${'40'.repeat(20)}`)

await client.setCode({
  address: contract.address,
  bytecode: contract.deployedBytecode,
})

await client.writeContract({
  account: PREFUNDED_ACCOUNTS[0],
  abi: contract.abi,
  functionName: 'set',
  args: [420n],
  address: contract.address,
})

await client.tevmMine()

const value = await client.readContract({
  abi: contract.abi,
  functionName: 'get',
  address: contract.address,
})

console.log(value)
```

If you don't know how to use `viem` or `ethers`, don't worry, Tevm is a great way to learn both Ethereum and TypeScript.


## Getting Started with Viem

### Installation

:::code-group
```bash [npm]
npm install tevm viem@latest
```

```bash [pnpm]
pnpm install tevm viem@latest
```

```bash [yarn]
yarn add tevm viem@latest
```
:::

### Sample code

Fork an existing blockchain and use [`viem` actions](https://viem.sh).

```ts [viem-quickstart.mts]
import {createMemoryClient, http} from 'tevm'
import {optimism} from 'tevm/common'
import {encodeFunctionData, parseAbi, decodeFunctionResult, parseEther} from 'viem'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

const blockNumber = await client.getBlockNumber()
console.log(blockNumber)

const account = `0x${"baD60A7".padStart(40, "0")}` as const
const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"

const greetAbi = parseAbi(['function greet() view returns (string)'])
const setGreetingAbi = parseAbi(['function setGreeting(string memory _greeting) public'])

// Use viem test actions to modify the blockchain
// There are also powerful tevm actions that are prefixed with tevm like tevmSetAccount
await client.setBalance({
  address: account,
  value: parseEther("1")
})

// Read contracts using normal viem apis
const callResult = await client.readContract({
  to: greeterContractAddress,
  abi: greetAbi,
  functionName: 'greet',
})

// use writecontract to send a eth_sendRawTransaction
const writeResult = await client.writeContract({
  account,
  to: greeterContractAddress,
  abi: setGreetingAbi,
  args: [newGreeting]
  chain: optimism,
})

// mine a new block to include your tx in the blockchain
await client.mine({blocks: 1})
```

:::details[Explanation]
```ts
import {createMemoryClient, http} from 'tevm'
import {optimism} from 'tevm/common'
import {encodeFunctionData, parseAbi, decodeFunctionResult, parseEther} from 'viem'
```

Import functions we need, which will be explained when we call them.
Notice that most functions we call are from `viem`, not `tevm`.

```ts
const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism
  },
})

await client.tevmReady()
```

Create a client as a fork of the Optimism mainnet, and wait until it is ready.

```ts
const blockNumber = await client.getBlockNumber()
console.log(blockNumber)
```

Report the fork block number. Any changes on the Optimism mainnet after this point will not be reflected in the `tevm` client.

```ts
const account = "0x" + "baD60A7".padStart(40, "0")
const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"
```

A couple of addresses. `0x0...0baD60A7` is just a random unused address which we'll use as our address.
[`0x10ed0b176048c34d69ffc0712de06CbE95730748`](https://optimism.blockscout.com/address/0x10ed0b176048c34d69ffc0712de06CbE95730748?tab=read_write_contract) is a `Greeter` contract we can use to experiment.

```ts
const greetAbi = parseAbi(['function greet() view returns (string)'])
const setGreetingAbi = parseAbi(['function setGreeting(string memory _greeting) public'])
```

Use [`viem`'s `parseAbi`](https://viem.sh/docs/abi/parseAbi#parseabi) to get the ABI for the two functions we need.

```ts
const getGreeting = async () => {
  const callResult = await client.call({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: greetAbi
    })
  })

  const greeting = decodeFunctionResult({
    abi: greetAbi,
    data: callResult.data
  })

  return greeting
}
```

This function is identical to what you would use to call an actual node using `viem` to get the greeting.

```ts
const setGreeting = async newGreeting => {
  const callResult = await client.sendTransaction({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: setGreetingAbi,
      args: [newGreeting]
    }),
    chain: optimism
  })

  return callResult
}
```

This function is similar to what you'd use with `viem`.
Normally `viem` does not support specifying the account as an address, because it needs the private key to sign the transaction.
However, this is supported when using `viem` with a [test client](https://viem.sh/docs/clients/test).

```ts
await client.setBalance({
  address: account,
  value: parseEther("1")
})
```

Mint 1 ETH for our address so we'll be able to send transactions.
The function we use is identical to [`viem`s `setBalance`](https://viem.sh/docs/actions/test/setBalance#setbalance).

```ts
console.log(`Original greeting: ${await getGreeting()}`)
```

The way you get a greeting is identical to the way you'd do it with `viem`.

```ts
console.log(`Txn hash: ${await setGreeting("Hi")}`)
await client.mine({blocks: 1})
console.log(`Changed greeting: ${await getGreeting()}`)
```

Because we control the "node", we control when it mines a new block and processes transactions.
So after we use [`<client>.sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction) we need to use [`<client>.mine`](https://viem.sh/docs/actions/test/mine) for the transaction to take effect.
:::

You can also use the tree-shakeable API. See [`viem` tevm docs](../examples/viem.mdx)

### Hooking into the evm

You can watch the EVM run in real time via hooking into it when you make your calls.

```typescript
await client.tevmContract({
  abi,
  functionName,
  args,
  onStep: (stepInfo, next) => {
    console.log(stepInfo.opcode)
    next?.()
  }
})
```

This method is supported on all tevmCall methods including tevmContract, and tevmDeploy.

### Tevm actions

Some `tevm` actions are available directly in the client.
They are [tree-shakable](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking), which makes them more efficient when writing code to run in a web browser.

The most common actions used are the following

* `tevmCall`, `tevmContract`, and `tevmDeploy` are used to do calls, contract calls, and deploy contracts with Tevm. These methods provide more functionality such as running a callback as the evm runs that are not supported by normal viem methods like `readContract` as well as returning more information.
* `tevmMine` Is how you mine a new block with Tevm
* `tevmSetAccount` and `tevmGetAccount` are convenient ways to update the EVM state
* `readContract`, and `writeContract` are commonly used viem methods but can be done using `tevmContract` for more advanced features such as account impersonating

Remember, all viem actions are supported.

[See here for more information](/reference/memory-client#tevm-actions).


## @tevm/actions

The `@tevm/actions` package provides a comprehensive set of actions for interacting with the Tevm client. It includes both standard Ethereum JSON-RPC methods and Tevm-specific functionality.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/actions/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs) folder.

### Installation

```bash
npm install @tevm/actions
```

### Overview

The `@tevm/actions` package provides handlers for:

* Executing EVM calls and contract interactions
* Managing blockchain state and accounts
* Standard Ethereum JSON-RPC methods
* Testing and development utilities (Anvil-compatible)
* Debugging and tracing functionality

### API Reference

#### Error Classes

* [BlobGasLimitExceededError](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/classes/BlobGasLimitExceededError.md) - Error thrown when blob gas limit is exceeded
* [MissingAccountError](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/classes/MissingAccountError.md) - Error thrown when an account doesn't exist
* [NoForkUrlSetError](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/classes/NoForkUrlSetError.md) - Error thrown when fork URL is required but not set

#### Core Types

* [Address](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/Address.md) - Ethereum address type
* [Abi](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/Abi.md) - Contract ABI type
* [Block](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/Block.md) - Ethereum block type
* [BlockTag](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/BlockTag.md) - Block reference tag (latest, earliest, etc)

#### Base Actions

##### Call Actions

* [CallHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/CallHandler.md) - Handler for executing EVM calls
* [CallParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/CallParams.md) - Parameters for call operations
* [CallResult](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/CallResult.md) - Result of call execution
* [BaseCallParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/BaseCallParams.md) - Common parameters for all call operations

##### Contract Actions

* [ContractHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/ContractHandler.md) - Handler for contract interactions
* [ContractParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/ContractParams.md) - Parameters for contract calls
* [ContractResult](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/ContractResult.md) - Result of contract execution

##### Deploy Actions

* [DeployHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/DeployHandler.md) - Handler for contract deployment
* [DeployParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/DeployParams.md) - Parameters for deployment
* [DeployResult](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/DeployResult.md) - Result of deployment

#### Validation Functions

* [validateBaseCallParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateBaseCallParams.md) - Validate base call parameters
* [validateCallParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateCallParams.md) - Validate call parameters
* [validateContractParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateContractParams.md) - Validate contract parameters
* [validateGetAccountParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateGetAccountParams.md) - Validate get account parameters
* [validateLoadStateParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateLoadStateParams.md) - Validate load state parameters
* [validateMineParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateMineParams.md) - Validate mine parameters
* [validateSetAccountParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/validateSetAccountParams.md) - Validate set account parameters

#### JSON-RPC Procedures

* [anvilImpersonateAccountJsonRpcProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/anvilImpersonateAccountJsonRpcProcedure.md) - Impersonate account procedure
* [callProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/callProcedure.md) - Call procedure
* [getAccountProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/getAccountProcedure.md) - Get account procedure
* [mineProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/mineProcedure.md) - Mine procedure
* [requestProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/requestProcedure.md) - Request procedure
* [requestBulkProcedure](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/requestBulkProcedure.md) - Bulk request procedure

#### Internal Utilities

* [forkAndCacheBlock](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/forkAndCacheBlock.md) - Fork and cache block utility
* [handlePendingTransactionsWarning](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/handlePendingTransactionsWarning.md) - Handle pending transactions warning
* [shouldCreateTransaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/functions/shouldCreateTransaction.md) - Check if transaction should be created

#### Ethereum JSON-RPC Actions

##### Account & Network

* [EthAccountsHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthAccountsHandler.md) - List available accounts
* [EthChainIdHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthChainIdHandler.md) - Get current chain ID
* [EthCoinbaseHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthCoinbaseHandler.md) - Get coinbase address
* [EthGasPriceHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGasPriceHandler.md) - Get current gas price
* [EthBlockNumberHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthBlockNumberHandler.md) - Get current block number

##### State Reading

* [EthGetBalanceHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGetBalanceHandler.md) - Get account balance
* [EthGetCodeHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGetCodeHandler.md) - Get contract code
* [EthGetStorageAtHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGetStorageAtHandler.md) - Get storage at position
* [EthCallHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthCallHandler.md) - Execute call without state changes

##### Block Operations

* [EthGetBlockByHashHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGetBlockByHashHandler.md) - Get block by hash
* [EthGetBlockByNumberHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/EthGetBlockByNumberHandler.md) - Get block by number

#### Anvil (Testing & Development) Actions

##### State Manipulation

* [AnvilSetBalanceHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilSetBalanceHandler.md) - Set account balance
* [AnvilSetCodeHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilSetCodeHandler.md) - Set contract code
* [AnvilSetNonceHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilSetNonceHandler.md) - Set account nonce
* [AnvilSetStorageAtHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilSetStorageAtHandler.md) - Set storage at position

##### Mining & Chain Control

* [AnvilMineHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilMineHandler.md) - Mine blocks
* [AnvilSetChainIdHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilSetChainIdHandler.md) - Set chain ID
* [AnvilResetHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/AnvilResetHandler.md) - Reset to initial state

#### Debug Actions

* [DebugTraceCallHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/DebugTraceCallHandler.md) - Trace a call execution
* [DebugTraceTransactionHandler](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/type-aliases/DebugTraceTransactionHandler.md) - Trace a transaction execution

### Usage Examples

#### Basic Call Example

```typescript
import { createTevmNode } from 'tevm/node'
import { callHandler } from '@tevm/actions'

const client = createTevmNode()
const call = callHandler(client)

const result = await call({
  to: '0x123...',
  data: '0x456...',
  value: 1000n
})
```

#### Contract Interaction Example

```typescript
import { contractHandler } from '@tevm/actions'

const contract = contractHandler(client)
const result = await contract({
  to: '0x123...',
  abi: [...],
  function: 'transfer',
  args: ['0x456...', 1000n]
})
```

#### Deployment Example

```typescript
import { deployHandler } from '@tevm/actions'

const deploy = deployHandler(client)
const result = await deploy({
  bytecode: '0x...',
  abi: [...],
  args: ['constructor arg']
})
```

#### JSON-RPC Example

```typescript
import { ethCallHandler } from '@tevm/actions'

const ethCall = ethCallHandler(client)
const result = await ethCall({
  to: '0x123...',
  data: '0x456...'
})
```

### Error Handling

All actions support a `throwOnFail` parameter to control error handling:

```typescript
const result = await call({
  to: '0x123...',
  throwOnFail: false // Return errors in result instead of throwing
})
```

### See Also

* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [Anvil Documentation](https://book.getfoundry.sh/reference/anvil/)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs/globals.md)


## @tevm/address

The `@tevm/address` package provides utilities for handling Ethereum addresses. It wraps the functionality from [`@ethereumjs/utils` address](https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/util/src/address.ts) with a Tevm-style API.

### Installation

```bash
npm install @tevm/address
```

### Overview

This package provides a set of utilities for working with Ethereum addresses, including:

* Creating and validating addresses
* Generating contract addresses (both regular and CREATE2)
* Converting between different address formats
* Handling checksummed addresses

### API Reference

#### Classes

##### `Address`

A utility class for Ethereum addresses that extends `EthjsAddress`. It provides a more user-friendly API and ensures checksummed address output.

```typescript
import { createAddress } from '@tevm/address'

// Create from hex string
const address = createAddress(`0x${'00'.repeat(20)}`)

// Create from number or bigint
const address2 = createAddress(0n)

// Create from bytes
const address3 = createAddress(new Uint8Array(20))

// Create from non-hex string
const address4 = createAddress('55'.repeat(20))
```

**Methods:**

* `toString()`: Returns the checksummed address as a string
* `toBytes()`: Returns the address as a Uint8Array
* `equals(address: Address)`: Checks if two addresses are equal
* `isZero()`: Checks if the address is zero
* `isPrecompileOrSystemAddress()`: Checks if the address is a precompile or system address

#### Functions

##### `createAddress(address: string | number | bigint | Address | Uint8Array): Address`

Creates an `Address` instance from various input types.

```typescript
import { createAddress } from '@tevm/address'

// From hex string
const address = createAddress('0x1234...')

// From number
const address2 = createAddress(123)

// From bytes
const address3 = createAddress(new Uint8Array(20))
```

**Parameters:**

* `address`: The input to create an address from (hex string, number, bigint, Address instance, or Uint8Array)

**Returns:**

* An `Address` instance

**Throws:**

* `InvalidAddressError` if the input is not a valid address

##### `createContractAddress(from: Address, nonce: bigint): Address`

Generates an address for a newly created contract using the standard CREATE operation.

```typescript
import { createAddress, createContractAddress } from '@tevm/address'

const from = createAddress('0x1234...')
const nonce = 0n
const contractAddress = createContractAddress(from, nonce)
```

**Parameters:**

* `from`: The address of the account creating the contract
* `nonce`: The nonce of the account creating the contract

**Returns:**

* The generated contract address

**Throws:**

* `InvalidAddressError` if the 'from' parameter is not a valid address

##### `create2ContractAddress(from: Address, salt: string, code: string): Address`

Generates an address for a contract created using CREATE2 (EIP-1014).

```typescript
import { createAddress, create2ContractAddress } from '@tevm/address'

const from = createAddress('0x1234...')
const salt = `0x${'00'.repeat(32)}`
const code = '0x...' // Contract creation code
const contractAddress = create2ContractAddress(from, salt, code)
```

**Parameters:**

* `from`: The address creating the contract
* `salt`: A 32-byte salt value as a hex string
* `code`: The contract creation code

**Returns:**

* The generated contract address

**Throws:**

* `InvalidSaltError` if the salt is not 32 bytes
* `InvalidAddressError` if inputs are invalid

### Error Handling

The package provides specific error types for different validation scenarios:

* `InvalidAddressError`: Thrown when an invalid address is provided
* `InvalidSaltError`: Thrown when an invalid salt is provided for CREATE2
* `Create2ContractAddressError`: Union type of both error types above

### Examples

#### Basic Address Creation and Validation

```typescript
import { createAddress } from '@tevm/address'

// Create an address
const address = createAddress('0x742d35Cc6634C0532925a3b844Bc454e4438f44e')

// Get checksummed string representation
console.log(address.toString())
// '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'

// Check if it's a zero address
console.log(address.isZero())
// false

// Compare addresses
const address2 = createAddress('0x742d35Cc6634C0532925a3b844Bc454e4438f44e')
console.log(address.equals(address2))
// true
```

#### Contract Address Generation

```typescript
import { createAddress, createContractAddress, create2ContractAddress } from '@tevm/address'

// Generate regular contract address
const from = createAddress('0x742d35Cc6634C0532925a3b844Bc454e4438f44e')
const nonce = 1n
const contractAddress = createContractAddress(from, nonce)

// Generate CREATE2 contract address
const salt = `0x${'00'.repeat(32)}`
const code = '0x608060405234801561001057600080fd5b506101...' // Contract bytecode
const create2Address = create2ContractAddress(from, salt, code)
```

### See Also

* [Ethereum Address Format (EIP-55)](https://eips.ethereum.org/EIPS/eip-55)
* [CREATE2 Opcode (EIP-1014)](https://eips.ethereum.org/EIPS/eip-1014)
* [@tevm/utils Documentation](https://tevm.sh/reference/tevm/utils/)


## @tevm/block

The `@tevm/block` package provides functionality for working with Ethereum blocks. It includes classes and utilities for handling block headers, block data, and block-related operations.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/block/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs) folder.

### Installation

```bash
npm install @tevm/block
```

### Overview

The `@tevm/block` package provides:

* Block creation and manipulation
* Block header management
* RLP serialization/deserialization
* JSON-RPC block formatting
* Verkle tree support

### API Reference

#### Core Classes

* [Block](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/classes/Block.md) - Main class for Ethereum block operations
* [BlockHeader](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/classes/BlockHeader.md) - Class for managing block headers
* [ClRequest](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/classes/ClRequest.md) - Class for client requests

#### Interfaces

* [BlockData](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/BlockData.md) - Block data structure
* [BlockOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/BlockOptions.md) - Options for block creation
* [HeaderData](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/HeaderData.md) - Block header data structure
* [JsonBlock](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/JsonBlock.md) - JSON representation of a block
* [JsonHeader](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/JsonHeader.md) - JSON representation of a header
* [JsonRpcBlock](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/JsonRpcBlock.md) - JSON-RPC block format

#### Verkle Tree Types

* [VerkleExecutionWitness](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/VerkleExecutionWitness.md) - Verkle execution witness
* [VerkleProof](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/VerkleProof.md) - Verkle proof structure
* [VerkleStateDiff](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/interfaces/VerkleStateDiff.md) - Verkle state difference

#### Block Types

* [BlockBodyBytes](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/type-aliases/BlockBodyBytes.md) - Block body byte representation
* [BlockBytes](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/type-aliases/BlockBytes.md) - Full block byte representation
* [BlockHeaderBytes](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/type-aliases/BlockHeaderBytes.md) - Block header byte representation
* [ExecutionPayload](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/type-aliases/ExecutionPayload.md) - Execution payload structure
* [BeaconPayloadJson](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/type-aliases/BeaconPayloadJson.md) - Beacon chain payload JSON

#### Utility Functions

* [blockFromRpc](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/functions/blockFromRpc.md) - Create block from RPC response
* [executionPayloadFromBeaconPayload](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/functions/executionPayloadFromBeaconPayload.md) - Convert beacon payload to execution payload
* [getDifficulty](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/functions/getDifficulty.md) - Calculate block difficulty
* [valuesArrayToHeaderData](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/functions/valuesArrayToHeaderData.md) - Convert array to header data

### Usage Examples

#### Creating a New Block

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

// Create a new block
const block = new Block({
  common: createCommon({ ...mainnet })
})
```

#### Creating a Block from Data

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'
import { EthjsAddress } from '@tevm/utils'

const common = createCommon({ ...mainnet })

const blockData = {
  header: {
    parentHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    uncleHash: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
    coinbase: EthjsAddress.fromString('0x0000000000000000000000000000000000000000'),
    stateRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
    transactionsTrie: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    receiptTrie: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
    difficulty: 0n,
    number: 0n,
    gasLimit: 30000000n,
    gasUsed: 0n,
    timestamp: BigInt(Math.floor(Date.now() / 1000)),
    extraData: '0x',
    mixHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    nonce: '0x0000000000000000',
    baseFeePerGas: 1000000000n
  }
}

const block = Block.fromBlockData(blockData, { common })
```

#### Working with Block Headers

```typescript
// Get block hash
const hash = block.hash()

// Serialize block
const serialized = block.serialize()

// Convert to JSON
const json = block.toJSON()
```

#### Creating from RLP Data

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const serializedBlock = new Uint8Array([/* ... */])
const block = Block.fromRLPSerializedBlock(serializedBlock, { common })
```

### See Also

* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [Block Structure](https://ethereum.org/en/developers/docs/blocks/)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs/globals.md)


## @tevm/blockchain

The `@tevm/blockchain` package provides a custom implementation of the Ethereum blockchain, extending the functionality of `ethereumjs/blockchain`. It's responsible for managing blocks, handling chain reorganizations, and maintaining the blockchain state.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/blockchain/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/blockchain/docs) folder.

### Installation

```bash
npm install @tevm/blockchain
```

### Overview

The blockchain package provides:

* Block management and validation
* Chain reorganization handling
* Support for forking from live networks
* Block iteration and traversal
* Chain state management

### API Reference

#### Core Types

##### `Chain`

The main blockchain interface that provides methods for interacting with the blockchain.

```typescript
import { createChain } from '@tevm/blockchain'
import { createCommon } from '@tevm/common'

const chain = await createChain({
  common: createCommon({ /* chain config */ }),
})
```

**Methods:**

* `putBlock(block: Block)`: Adds a block to the blockchain
* `delBlock(blockHash: Uint8Array)`: Deletes a block and its children
* `getBlock(blockId: number | bigint | Uint8Array)`: Gets a block by hash or number
* `getBlockByTag(blockTag: BlockTag)`: Gets a block by tag (latest, earliest, etc.)
* `getCanonicalHeadBlock()`: Gets the latest block in the canonical chain
* `validateHeader(header: BlockHeader)`: Validates a block header
* `iterator(name: string, onBlock: OnBlock)`: Iterates through blocks
* `deepCopy()`: Creates a deep copy of the blockchain
* `shallowCopy()`: Creates a shallow copy sharing state with original

##### `ChainOptions`

Configuration options for creating a blockchain instance.

```typescript
type ChainOptions = {
  common: Common                    // Chain configuration
  loggingLevel?: LogLevel          // Logging configuration
  genesisBlock?: Block             // Custom genesis block
  genesisStateRoot?: Uint8Array    // Custom genesis state
  fork?: {                         // Fork configuration
    transport: { request: EIP1193RequestFn }
    blockTag?: BlockTag | bigint | `0x${string}`
  }
}
```

#### Functions

##### `createChain(options: ChainOptions): Promise<Chain>`

Creates a new blockchain instance.

```typescript
import { createChain } from '@tevm/blockchain'
import { createCommon } from '@tevm/common'
import { mainnet } from '@tevm/common'

const chain = await createChain({
  common: createCommon({ ...mainnet }),
  loggingLevel: 'debug',
  fork: {
    transport: { request: /* EIP-1193 provider */ },
    blockTag: 'latest'
  }
})
```

##### `createBaseChain(options: ChainOptions): BaseChain`

Creates the internal blockchain implementation used by `createChain`.

#### Block Operations

##### Getting Blocks

```typescript
// Get by number
const block = await chain.getBlock(1234n)

// Get by hash
const block = await chain.getBlock(blockHash)

// Get by tag
const latest = await chain.getBlockByTag('latest')
const pending = await chain.getBlockByTag('pending')
```

##### Adding & Removing Blocks

```typescript
// Add a block
await chain.putBlock(block)

// Delete a block and its children
await chain.delBlock(blockHash)
```

##### Block Validation

```typescript
// Validate a block header
await chain.validateHeader(header)
```

#### Chain Traversal

##### Block Iterator

```typescript
// Iterate through blocks
await chain.iterator('vm', async (block, reorg) => {
  // Process each block
  console.log(block.header.number)
}, maxBlocks)
```

##### Iterator Head Management

```typescript
// Get iterator head
const head = await chain.getIteratorHead('vm')

// Set iterator head
await chain.setIteratorHead('vm', blockHash)
```

#### Forking

The blockchain can be forked from a live network:

```typescript
import { createChain } from '@tevm/blockchain'
import { http } from 'viem'

const chain = await createChain({
  common: createCommon({ /* chain config */ }),
  fork: {
    transport: {
      request: http('https://mainnet.infura.io/v3/YOUR-KEY')
    },
    blockTag: 'latest' // or specific block number/hash
  }
})
```

#### Error Handling

The package throws specific error types for different scenarios:

* `BlockNotFoundError`: When a requested block doesn't exist
* `InvalidBlockError`: When block validation fails
* `InvalidHeaderError`: When header validation fails
* `InvalidChainError`: When chain configuration is invalid

### Examples

#### Basic Chain Management

```typescript
import { createChain } from '@tevm/blockchain'
import { createCommon } from '@tevm/common'
import { Block } from '@tevm/block'

// Create chain
const chain = await createChain({
  common: createCommon({ /* chain config */ })
})

// Add blocks
await chain.putBlock(block1)
await chain.putBlock(block2)

// Get latest block
const head = await chain.getCanonicalHeadBlock()

// Validate headers
await chain.validateHeader(newBlock.header)
```

#### Chain Forking

```typescript
import { createChain } from '@tevm/blockchain'
import { http } from 'viem'

const chain = await createChain({
  common: createCommon({ /* chain config */ }),
  fork: {
    transport: {
      request: http('https://mainnet.infura.io/v3/YOUR-KEY')
    },
    blockTag: 15000000n // Fork from specific block
  }
})

// Work with forked chain
const block = await chain.getBlock(15000000n)
```

#### Chain Iteration

```typescript
import { createChain } from '@tevm/blockchain'

const chain = await createChain({ /* options */ })

// Process blocks sequentially
await chain.iterator('vm', async (block, reorg) => {
  if (reorg) {
    console.log('Chain reorganization detected')
  }

  // Process block
  console.log(`Processing block ${block.header.number}`)
}, 1000) // Process up to 1000 blocks
```

### See Also

* [EthereumJS Blockchain Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/blockchain)
* [Block Package Documentation](https://tevm.sh/reference/tevm/block/)
* [Common Package Documentation](https://tevm.sh/reference/tevm/common/)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/blockchain/docs/globals.md)


## @tevm/common

The `@tevm/common` package provides chain-specific configuration and utilities for Tevm clients. It extends the functionality of `ethereumjs/common` and integrates with Viem's chain definitions.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/common/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs) folder.

### Installation

```bash
npm install @tevm/common
```

### Overview

The `@tevm/common` package provides:

* Chain configuration management
* Hardfork settings and EIP support
* Consensus algorithm configuration
* Network-specific settings
* Extensive chain definitions

### API Reference

#### Enumerations

* [ConsensusAlgorithm](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/enumerations/ConsensusAlgorithm.md) - Supported consensus algorithms
* [ConsensusType](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/enumerations/ConsensusType.md) - Types of consensus mechanisms

#### Interfaces

* [CustomCrypto](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/interfaces/CustomCrypto.md) - Custom cryptographic implementations
* [EvmStateManagerInterface](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/interfaces/EvmStateManagerInterface.md) - EVM state manager interface
* [StorageDump](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/interfaces/StorageDump.md) - Storage dump format
* [StorageRange](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/interfaces/StorageRange.md) - Storage range specification

#### Type Aliases

* [AccountFields](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/AccountFields.md) - Account field definitions
* [CliqueConfig](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/CliqueConfig.md) - Clique consensus configuration
* [Common](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/Common.md) - Main chain configuration type
* [CommonOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/CommonOptions.md) - Configuration options
* [Hardfork](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/Hardfork.md) - Supported hardforks
* [MockKzg](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/type-aliases/MockKzg.md) - Mock KZG implementation

#### Functions

* [createCommon](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/functions/createCommon.md) - Create a new Common instance
* [createMockKzg](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/functions/createMockKzg.md) - Create a mock KZG implementation

#### Supported Networks

The package includes configurations for numerous networks, including:

##### Layer 1 Networks

* [mainnet](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/mainnet.md) - Ethereum Mainnet
* [sepolia](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/sepolia.md) - Sepolia Testnet
* [goerli](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/goerli.md) - Goerli Testnet
* [holesky](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/holesky.md) - Holesky Testnet

##### Layer 2 Networks

* [arbitrum](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/arbitrum.md) - Arbitrum One
* [optimism](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/optimism.md) - Optimism
* [base](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/base.md) - Base
* [zksync](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/zksync.md) - zkSync Era
* [polygon](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/polygon.md) - Polygon PoS
* [polygonZkEvm](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/polygonZkEvm.md) - Polygon zkEVM

##### Alternative Networks

* [bsc](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/bsc.md) - BNB Smart Chain
* [avalanche](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/avalanche.md) - Avalanche C-Chain
* [fantom](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/fantom.md) - Fantom Opera
* [gnosis](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/gnosis.md) - Gnosis Chain

##### Development Networks

* [hardhat](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/hardhat.md) - Hardhat Network
* [foundry](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/foundry.md) - Foundry Network
* [anvil](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/anvil.md) - Anvil Network
* [localhost](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/variables/localhost.md) - Local Network

### Usage Examples

#### Basic Configuration

```typescript
import { createCommon } from '@tevm/common'
import { mainnet } from '@tevm/common'

const common = createCommon({
  ...mainnet,
  hardfork: 'shanghai'
})
```

#### Custom Chain Configuration

```typescript
import { createCommon } from '@tevm/common'

const common = createCommon({
  name: 'Custom Chain',
  chainId: 1337,
  networkId: 1337,
  defaultHardfork: 'shanghai',
  consensus: {
    type: 'poa',
    algorithm: 'clique',
    clique: {
      period: 15,
      epoch: 30000
    }
  }
})
```

#### Using with Custom Crypto

```typescript
import { createCommon, createMockKzg } from '@tevm/common'

const common = createCommon({
  ...mainnet,
  customCrypto: {
    kzg: createMockKzg()
  }
})
```

#### Network-Specific Configuration

```typescript
import { createCommon, optimism, arbitrum } from '@tevm/common'

// Optimism configuration
const optimismCommon = createCommon({
  ...optimism,
  hardfork: 'bedrock'
})

// Arbitrum configuration
const arbitrumCommon = createCommon({
  ...arbitrum,
  hardfork: 'nitro'
})
```

### Error Handling

The package throws specific errors for invalid configurations:

```typescript
try {
  const common = createCommon({
    chainId: -1 // Invalid chain ID
  })
} catch (error) {
  if (error.code === 'INVALID_CHAIN_ID') {
    console.error('Invalid chain ID provided')
  }
}
```

### See Also

* [EthereumJS Common Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/common)
* [Viem Chains Documentation](https://viem.sh/docs/chains/introduction.html)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs/globals.md)


## @tevm/contract

The `@tevm/contract` package provides powerful utilities for working with Ethereum smart contracts, offering type-safe contract interactions and simplified deployment workflows.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/contract/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs) folder.

### Installation

```bash
npm install @tevm/contract
```

### Overview

The contract package provides:

* Type-safe contract interactions
* Support for human-readable and JSON ABIs
* Contract deployment utilities
* Read and write method handling
* Event filtering and subscription
* Pre-built contract templates (ERC20, ERC721)

### API Reference

#### Type Aliases

* [Contract](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/Contract.md) - Core contract type definition
* [CreateContractFn](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/CreateContractFn.md) - Contract creation function type
* [CreateContractParams](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/CreateContractParams.md) - Parameters for contract creation
* [EventActionCreator](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/EventActionCreator.md) - Event action creator type
* [MaybeExtractEventArgsFromAbi](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/MaybeExtractEventArgsFromAbi.md) - Event args extraction utility
* [ReadActionCreator](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/ReadActionCreator.md) - Read action creator type
* [ValueOf](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/ValueOf.md) - Utility type for value extraction
* [WriteActionCreator](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/type-aliases/WriteActionCreator.md) - Write action creator type

#### Functions

* [createContract](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/functions/createContract.md) - Create a new contract instance

#### Pre-built Contracts

* [ERC20](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/variables/ERC20.md) - Standard ERC20 token implementation
* [ERC721](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/variables/ERC721.md) - Standard ERC721 NFT implementation
* [SimpleContract](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/variables/SimpleContract.md) - Basic contract for testing

### Usage Examples

#### Creating a Contract Instance

```typescript
import { createContract } from '@tevm/contract'

// Using human-readable ABI
const contract = createContract({
  // Use as const for type safety
  humanReadableAbi: [
    'function balanceOf(address) view returns (uint256)',
    'function transfer(address to, uint256 amount) returns (bool)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ] as const,
  name: 'MyToken',
})

// Type-safe read actions
const readAction = contract.read.balanceOf('0x...')

// Type-safe write actions
const writeAction = contract.write.transfer('0x...', 1000n)
```

#### Contract with Address

```typescript
const token = contract.withAddress('0x1234...')

// Now includes address in all actions
const balanceAction = token.read.balanceOf('0x...')
// balanceAction.to will be set to the token address
```

#### Using Standard Contracts

```typescript
import { ERC20, ERC721 } from '@tevm/contract'

// ERC20 token with all standard methods
const token = ERC20.withAddress('0x...')

// Read token info
const nameAction = token.read.name()
const symbolAction = token.read.symbol()
const supplyAction = token.read.totalSupply()

// Transfer tokens
const transferAction = token.write.transfer('0x...', 1000n)

// ERC721 NFT contract
const nft = ERC721.withAddress('0x...')
const ownerAction = nft.read.ownerOf(1n)
```

#### Deployless Scripts

```typescript
import { ERC20 } from '@tevm/contract'

// Create a script that deploys and initializes a token
const script = ERC20.script({
  bytecode: '0x...',  // Contract bytecode
  args: ['MyToken', 'MTK', 1000000n], // Constructor args
})

// Use with any compatible client
const name = await client.contract(script.read.name())
const symbol = await client.contract(script.read.symbol())
```

#### Event Handling

```typescript
// Create event filter
const filter = contract.events.Transfer({
  fromBlock: 'latest',
})

// Process events
client.watchEvent(filter, (event) => {
  console.log('Transfer:', {
    from: event.args.from,
    to: event.args.to,
    value: event.args.value,
  })
})
```

### Best Practices

#### 1. Type Safety

Always use `as const` with ABIs to get full type inference:

```typescript
const abi = [
  'function example(uint256 value) returns (bool)',
] as const

const contract = createContract({
  humanReadableAbi: abi,
  name: 'Example',
})
// contract.write.example will have proper types
```

#### 2. Error Handling

Handle contract errors appropriately:

```typescript
try {
  const result = await client.contract(contract.write.transfer('0x...', 1000n))
} catch (e) {
  if (e.message.includes('insufficient balance')) {
    // Handle specific error case
  }
  throw e
}
```

#### 3. Gas Management

Consider gas costs in write operations:

```typescript
const tx = contract.write.complexOperation('0x...', {
  gas: 500000n,  // Set gas limit
  maxFeePerGas: 30000000000n,  // Set max fee
})
```

### Contract Types

The package exports useful types for contract development:

```typescript
import type {
  Contract,
  CreateContractFn,
  CreateContractParams,
  EventActionCreator,
  ReadActionCreator,
  WriteActionCreator,
} from '@tevm/contract'

// Use with your own contracts
type MyContract = Contract<typeof myAbi>
```

### See Also

* [ERC-20 Token Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
* [ERC-721 NFT Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/)
* [Solidity Documentation](https://docs.soliditylang.org/)
* [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs/globals.md)


## @tevm/decorators

The `@tevm/decorators` package provides action decorators and utilities for extending Tevm clients with additional functionality. It includes EIP-1193 compatible providers, Ethereum JSON-RPC methods, and Tevm-specific actions.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/decorators/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs) folder.

### Installation

```bash
npm install @tevm/decorators
```

### Overview

The `@tevm/decorators` package provides:

* EIP-1193 compatible provider decorators
* Ethereum JSON-RPC method implementations
* Tevm-specific action decorators
* Type-safe request and response handling
* Chain and network utilities

### API Reference

#### Core Functions

##### [`ethActions()`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/functions/ethActions.md)

Creates an extension providing standard Ethereum JSON-RPC methods.

##### [`requestEip1193()`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/functions/requestEip1193.md)

Creates an EIP-1193 compatible provider extension.

##### [`tevmActions()`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/functions/tevmActions.md)

Creates an extension providing Tevm-specific actions.

##### [`tevmSend()`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/functions/tevmSend.md)

Creates an extension for sending Tevm JSON-RPC requests.

#### Core Types

##### Provider Types

* [`Eip1193RequestProvider`](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs/type-aliases/Eip1193RequestProvider.md) - EIP-1193 compatible provider interface
* [`EIP1193Parameters`](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs/type-aliases/EIP1193Parameters.md) - Parameters for EIP-1193 requests
* [`EIP1193RequestFn`](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs/type-aliases/EIP1193RequestFn.md) - Request function type for EIP-1193
* [`EIP1193RequestOptions`](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs/type-aliases/EIP1193RequestOptions.md) - Options for EIP-1193 requests

##### Action Types

* [`EthActionsApi`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/EthActionsApi.md) - Standard Ethereum JSON-RPC actions
* [`TevmActionsApi`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/TevmActionsApi.md) - Tevm-specific actions
* [`TevmSendApi`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/TevmSendApi.md) - API for sending Tevm requests

##### RPC Schema Types

* [`RpcSchema`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/RpcSchema.md) - Base RPC schema type
* [`RpcSchemaOverride`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/RpcSchemaOverride.md) - Schema override type
* [`DerivedRpcSchema`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/DerivedRpcSchema.md) - Derived schema type
* [`JsonRpcSchemaPublic`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/JsonRpcSchemaPublic.md) - Public JSON-RPC schema
* [`JsonRpcSchemaTevm`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/JsonRpcSchemaTevm.md) - Tevm-specific JSON-RPC schema
* [`JsonRpcSchemaWallet`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/JsonRpcSchemaWallet.md) - Wallet JSON-RPC schema
* [`TestRpcSchema`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/TestRpcSchema.md) - Test-specific RPC schema

##### Ethereum Types

* [`AddEthereumChainParameter`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/AddEthereumChainParameter.md) - Parameters for adding a chain
* [`WatchAssetParams`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/WatchAssetParams.md) - Parameters for watching assets
* [`WalletPermission`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/WalletPermission.md) - Wallet permission type
* [`WalletPermissionCaveat`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/WalletPermissionCaveat.md) - Wallet permission caveat type

##### Utility Types

* [`Hash`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/Hash.md) - Ethereum hash type
* [`LogTopic`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/LogTopic.md) - Log topic type
* [`NetworkSync`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/NetworkSync.md) - Network sync status type
* [`Quantity`](https://github.com/evmts/tevm-monorepo/blob/main/packages/decorators/docs/type-aliases/Quantity.md) - Ethereum quantity type

### Usage Examples

#### Creating an EIP-1193 Provider

```typescript
import { requestEip1193 } from '@tevm/decorators'

const provider = requestEip1193()
const client = createClient({
  transport: provider
})

// Make EIP-1193 requests
const result = await client.request({
  method: 'eth_call',
  params: [{
    to: '0x...',
    data: '0x...'
  }]
})
```

#### Using Ethereum Actions

```typescript
import { ethActions } from '@tevm/decorators'

const eth = ethActions()
const client = createClient({
  transport: eth
})

// Use standard Ethereum methods
const balance = await client.eth.getBalance({
  address: '0x...'
})

const code = await client.eth.getCode({
  address: '0x...'
})
```

#### Using Tevm Actions

```typescript
import { tevmActions } from '@tevm/decorators'

const tevm = tevmActions()
const client = createClient({
  transport: tevm
})

// Use Tevm-specific actions
const result = await client.transport.tevm.call({
  to: '0x...',
  data: '0x...'
})

const state = await client.transport.tevm.dumpState()
```

#### Error Handling

```typescript
try {
  const result = await client.request({
    method: 'eth_call',
    params: [{
      to: '0x...',
      data: '0x...'
    }]
  })
} catch (error) {
  if (error.code === -32000) {
    // Handle execution error
  }
  throw error
}
```

### Best Practices

#### 1. Type Safety

Always leverage TypeScript types for request parameters and responses:

```typescript
import type { EIP1193RequestFn } from '@tevm/decorators'

const request: EIP1193RequestFn = async (params) => {
  // Type-safe parameters and return value
}
```

#### 2. Error Handling

Handle both standard JSON-RPC errors and Tevm-specific errors:

```typescript
try {
  await client.request(...)
} catch (error) {
  if (error.code === 4001) {
    // User rejected request
  } else if (error.code === -32000) {
    // Execution error
  }
}
```

#### 3. Chain Management

Use proper chain parameters when adding new chains:

```typescript
const chainParams: AddEthereumChainParameter = {
  chainId: '0x1',
  chainName: 'Ethereum Mainnet',
  nativeCurrency: {
    name: 'Ether',
    symbol: 'ETH',
    decimals: 18
  },
  rpcUrls: ['https://...']
}
```

### See Also

* [JSON-RPC API](/api/json-rpc)
* [Actions Guide](/reference/actions)
* [EIP-1193 Specification](https://eips.ethereum.org/EIPS/eip-1193)
* [Ethereum JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/)


## @tevm/evm

The `@tevm/evm` package provides a custom implementation of the Ethereum Virtual Machine (EVM), extending the functionality of `ethereumjs/evm`. It's responsible for executing Ethereum bytecode and managing the execution environment.

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/evm/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs) folder.

### Installation

```bash
npm install @tevm/evm
```

### API Reference

#### Enumerations

* [EvmErrorMessage](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/enumerations/EvmErrorMessage.md) - EVM error message types

#### Core Classes

* [Evm](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/classes/Evm.md) - Main EVM implementation class
* [EthjsMessage](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/classes/EthjsMessage.md) - EVM message handling
* [EvmError](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/classes/EvmError.md) - EVM error handling

#### Interfaces

* [EvmResult](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/interfaces/EvmResult.md) - Result of EVM execution
* [EvmRunCallOpts](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/interfaces/EvmRunCallOpts.md) - Options for running calls
* [ExecResult](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/interfaces/ExecResult.md) - Execution result details
* [InterpreterStep](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/interfaces/InterpreterStep.md) - Interpreter step information
* [PrecompileInput](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/interfaces/PrecompileInput.md) - Input for precompiles

#### Type Aliases

* [CreateEvmOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/type-aliases/CreateEvmOptions.md) - Options for creating an EVM
* [CustomPrecompile](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/type-aliases/CustomPrecompile.md) - Custom precompile definition
* [EVMOpts](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/type-aliases/EVMOpts.md) - EVM configuration options

#### Variables

* [Eof](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/variables/Eof.md) - EOF-related constants

#### Functions

* [createEvm](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/functions/createEvm.md) - Create a new EVM instance
* [getActivePrecompiles](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/functions/getActivePrecompiles.md) - Get active precompiles

### Usage Examples

#### Creating an EVM Instance

```typescript
import { createEvm } from '@tevm/evm'
import { mainnet } from '@tevm/common'
import { createStateManager } from '@tevm/state'
import { createChain } from '@tevm/chain'

const evm = await createEvm({
  common: mainnet,
  stateManager: createStateManager,
  blockchain: await createChain({ common: mainnet }),
  customPrecompiles: [], // Optional custom precompiles
  profiler: false, // Enable/disable profiling
  loggingLevel: 'warn', // Logging configuration
})
```

#### Running EVM Calls

```typescript
const result = await evm.runCall({
  to: '0x1234...',
  caller: '0x5678...',
  data: new Uint8Array([/* bytecode */]),
  value: 1000n,
  gasLimit: 100000n
})

console.log(result.execResult.returnValue)
console.log(result.execResult.executionGasUsed)
```

#### Custom Precompiles

```typescript
import { definePrecompile, defineCall, createContract, parseAbi } from '@tevm/evm'
import { createAddress } from '@tevm/utils'

const MyContract = createContract({
  address: createAddress(2424).toString(),
  abi: parseAbi([
    'function addTwo(uint256) returns (uint256)',
  ])
})

const customPrecompile = definePrecompile({
  contract: MyContract,
  call: defineCall(MyContract.abi, {
    addTwo: async ({ args }) => {
      return {
        returnValue: args[0] + 5n,
        executionGasUsed: 0n
      }
    }
  })
})

evm.addCustomPrecompile(customPrecompile.precompile())
```

#### Error Handling

```typescript
try {
  const result = await evm.runCall({
    to: '0x1234...',
    gasLimit: 100n // Very low gas limit
  })
} catch (error) {
  if (error instanceof EvmError) {
    console.log(error.error) // e.g. EvmErrorMessage.OUT_OF_GAS
  }
}
```

#### Debugging and Performance

```typescript
// Enable debug logging
const evm = await createEvm({
  loggingLevel: 'trace'
})

// Get performance logs
const logs = evm.getPerformanceLogs()
console.log(logs.opcodes) // Opcode execution stats
console.log(logs.precompiles) // Precompile execution stats
```

### See Also

* [EthereumJS EVM Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm)
* [Tevm State Documentation](https://tevm.sh/reference/tevm/state/)
* [Tevm Precompiles Documentation](https://tevm.sh/reference/tevm/precompiles/)
* [Full API Reference](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs/globals.md)


## Package Reference Documentation

This section contains detailed API reference documentation for all Tevm packages.

* [@tevm/actions](/reference/actions) - Core action handlers for interacting with the EVM
* [@tevm/address](/reference/address) - Ethereum address utilities
* [@tevm/block](/reference/block) - Block creation and manipulation
* [@tevm/blockchain](/reference/blockchain) - Blockchain data structures and utilities
* [@tevm/common](/reference/common) - Shared utilities and constants
* [@tevm/contract](/reference/contract) - Library for using contracts in typesafe way
* [@tevm/decorators](/reference/decorators) - Extension decorators
* [@tevm/evm](/reference/evm) - Core EVM implementation
* [@tevm/memory-client](/reference/memory-client) - Batteries included viem client along with tree shakable actions
* [@tevm/receipt-manager](/reference/receipt-manager) - Transaction receipt handling
* [@tevm/state](/reference/state) - State management utilities
* [@tevm/tx](/reference/tx) - Transaction handling utilities
* [@tevm/txpool](/reference/txpool) - Transaction pool management
* [@tevm/utils](/reference/utils) - General utility functions
* [@tevm/vm](/reference/vm) - Virtual Machine implementation

Each package's documentation includes:

* Complete API reference
* Type definitions
* Usage examples
* Configuration options


## @tevm/memory-client

The `@tevm/memory-client` package provides a powerful in-memory Ethereum client implementation for Tevm. It combines the capabilities of viem with Tevm's custom EVM implementation to offer a complete testing and development environment.

### Installation

```bash
npm install @tevm/memory-client
```

### API Reference

#### Type Aliases

* [CreateMemoryClientFn](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/CreateMemoryClientFn.md) - Function type for creating memory clients
* [MemoryClient](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/MemoryClient.md) - Core memory client type
* [MemoryClientOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/MemoryClientOptions.md) - Configuration options
* [TevmActions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/TevmActions.md) - Tevm-specific actions
* [TevmContract](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/TevmContract.md) - Contract interaction type
* [TevmRpcSchema](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/TevmRpcSchema.md) - RPC schema definition
* [TevmTransport](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/TevmTransport.md) - Transport layer type
* [TevmViemActionsApi](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/type-aliases/TevmViemActionsApi.md) - Viem actions API

#### Actions

* [createClient](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/createClient.md) - Create a new client instance
* [createMemoryClient](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/createMemoryClient.md) - Create a memory client
* [createTevmTransport](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/createTevmTransport.md) - Create transport layer
* [publicActions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/publicActions.md) - Public action creators
* [testActions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/testActions.md) - Test action creators
* [tevmCall](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmCall.md) - Execute EVM call
* [tevmContract](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmContract.md) - Contract interaction
* [tevmDeploy](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmDeploy.md) - Deploy contract
* [tevmDumpState](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmDumpState.md) - Export state
* [tevmGetAccount](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmGetAccount.md) - Get account state
* [tevmLoadState](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmLoadState.md) - Import state
* [tevmMine](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmMine.md) - Mine blocks
* [tevmReady](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmReady.md) - Check client readiness
* [tevmSetAccount](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmSetAccount.md) - Set account state
* [tevmViemActions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/tevmViemActions.md) - Viem action creators
* [walletActions](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs/functions/walletActions.md) - Wallet action creators

### Overview

The memory client package provides:

* A complete in-memory Ethereum client implementation
* Support for forking existing networks
* Automatic and manual mining modes
* Full compatibility with viem's actions
* Extended functionality through Tevm-specific actions

### Core Components

#### MemoryClient

The main client class that provides Ethereum client functionality with in-memory state management.

```typescript
import { createMemoryClient } from '@tevm/memory-client'

const client = createMemoryClient({
  fork: {
    transport: http("https://mainnet.optimism.io")
  }
})
```

#### Client Options

```typescript
interface MemoryClientOptions<TCommon, TAccountOrAddress, TRpcSchema> {
  // Chain configuration
  common?: TCommon
  // Fork configuration
  fork?: {
    transport: Transport
    blockTag?: string | number
  }
  // Client configuration
  name?: string
  account?: TAccountOrAddress
  pollingInterval?: number
  cacheTime?: number
}
```

### Features

#### Mining Modes

The client supports two mining modes:

```typescript
// Auto mining (default)
const client = createMemoryClient()

// Manual mining
const client = createMemoryClient({
  mining: {
    mode: 'manual'
  }
})

// Mine blocks manually
await client.mine()
```

#### Network Forking

Fork any EVM-compatible network:

```typescript
import { createMemoryClient, http } from '@tevm/memory-client'
import { optimism } from '@tevm/common'

const client = createMemoryClient({
  fork: {
    transport: http("https://mainnet.optimism.io"),
    blockTag: '0xa6a63cd70fbbe396321ca6fe79e1b6735760c03538208b50d7e3a5dac5226435'
  },
  common: optimism
})
```

#### State Management

```typescript
// Set account state
await client.setAccount({
  address: '0x...',
  balance: 100n,
  nonce: 1n,
  deployedBytecode: '0x...',
  state: {
    '0x...': '0x...'
  }
})

// Get account state
const account = await client.getAccount({
  address: '0x...',
  returnStorage: true
})
```

#### Contract Interactions

```typescript
// Deploy contract
const deployResult = await client.tevmDeploy({
  abi: contractAbi,
  bytecode: contractBytecode,
  args: ['Constructor', 'Args']
})

// Call contract
const result = await client.tevmCall({
  to: contractAddress,
  data: encodeFunctionData(...)
})

// Contract interaction with high-level API
const contractResult = await client.tevmContract({
  contract: myContract,
  method: 'myMethod',
  args: [arg1, arg2]
})
```

#### Transaction Management

```typescript
// Send transaction
const hash = await client.writeContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: 'myFunction',
  args: [arg1, arg2]
})

// Wait for receipt
const receipt = await client.waitForTransactionReceipt({ hash })
```

### Actions API

The client includes several sets of actions:

#### Tevm Actions

* `tevmCall`: Low-level EVM call execution
* `tevmContract`: High-level contract interaction
* `tevmDeploy`: Contract deployment
* `tevmGetAccount`: Account state retrieval
* `tevmSetAccount`: Account state modification
* `tevmMine`: Manual block mining
* `tevmDumpState`: State export
* `tevmLoadState`: State import

#### Viem Actions

* Public actions (e.g., `getBlockNumber`, `getBalance`)
* Wallet actions (e.g., `sendTransaction`, `signMessage`)
* Test actions (e.g., `setBalance`, `impersonateAccount`)

### Advanced Features

#### State Persistence

```typescript
import { createMemoryClient, createSyncPersister } from '@tevm/memory-client'

const client = createMemoryClient({
  persister: createSyncPersister({
    storage: localStorage
  })
})
```

#### HTTP Server Integration

```typescript
import { createServer } from '@tevm/server'
import { createMemoryClient } from '@tevm/memory-client'

const client = createMemoryClient()
const server = createServer({
  request: client.request
})

server.listen(8545)
```

### Network Support

Officially supported networks:

* Ethereum mainnet
* Standard OP Stack chains

Other EVM-compatible chains may work but are not officially supported.

### EIP Support

Always-enabled EIPs:

* EIP-1559 (Fee Market)
* EIP-4895
* EIP-4844 (Blob Transactions)
* EIP-4788

### Types

The package exports several important types:

```typescript
type MemoryClient<TChain, TAccountOrAddress>
type MemoryClientOptions<TCommon, TAccountOrAddress, TRpcSchema>
type TevmActions
type TevmContract
type TevmRpcSchema
type TevmTransport
```

### License

This package is licensed under the MIT License.

### See Also

* [What is Tevm Node?](../introduction/what-is-tevm-node)
* [Creating a Node](../core/create-tevm-node)
* [Viem Documentation](https://viem.sh)


## @tevm/node API Reference

This documentation is generated from the source code. View the full API documentation on GitHub:

[View @tevm/node API Reference on GitHub](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs/globals.md)

### Quick Links

* [Type Aliases](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs/type-aliases)
* [Classes](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs/classes)
* [Functions](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs/functions)
* [Variables](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs/variables)

### Return to Documentation

* [Back to Getting Started](/getting-started/overview)
* [Package Overview](/reference)


## @tevm/receipt-manager

The `@tevm/receipt-manager` package provides a robust transaction receipt management system for the Tevm blockchain. It handles the storage, retrieval, and management of transaction receipts, logs, and related data.

### Installation

```bash
npm install @tevm/receipt-manager
```

### Overview

The receipt manager package is responsible for:

* Managing transaction receipts and their storage
* Handling transaction logs and bloom filters
* Supporting different receipt types (Pre-Byzantium, Post-Byzantium, EIP4844)
* Providing efficient receipt lookup and retrieval

### Core Components

#### ReceiptsManager

The main class that handles receipt management operations.

```typescript
import { ReceiptsManager } from '@tevm/receipt-manager'

const receiptsManager = new ReceiptsManager(mapDb, chain)
```

##### Key Methods

* `saveReceipts(block, receipts)`: Saves receipts to the database
* `getReceipts(blockHash)`: Retrieves receipts for a given block hash
* `getReceiptByTxHash(txHash)`: Gets a receipt by transaction hash
* `getLogs(from, to, addresses?, topics?)`: Returns logs based on filter criteria
* `deleteReceipts(block)`: Removes receipts for a given block

#### Receipt Types

The package supports multiple receipt types to accommodate different Ethereum protocol versions:

##### BaseTxReceipt

```typescript
interface BaseTxReceipt {
  cumulativeBlockGasUsed: bigint
  bitvector: Uint8Array
  logs: Log[]
}
```

##### PreByzantiumTxReceipt

```typescript
interface PreByzantiumTxReceipt extends BaseTxReceipt {
  stateRoot: Uint8Array
}
```

##### PostByzantiumTxReceipt

```typescript
interface PostByzantiumTxReceipt extends BaseTxReceipt {
  status: 0 | 1
}
```

##### EIP4844BlobTxReceipt

```typescript
interface EIP4844BlobTxReceipt extends PostByzantiumTxReceipt {
  blobGasUsed: bigint
  blobGasPrice: bigint
}
```

### Database Management

#### MapDb

The package includes a MapDb implementation for storing receipt data:

```typescript
import { createMapDb } from '@tevm/receipt-manager'

const mapDb = createMapDb({
  cache: new Map()
})
```

#### Configuration Options

```typescript
interface MetaDBManagerOptions {
  cache: Map<`0x${string}`, Uint8Array>
}
```

### Usage Examples

#### Saving and Retrieving Receipts

```typescript
// Save receipts
await receiptsManager.saveReceipts(block, receipts)

// Retrieve receipts by block hash
const receipts = await receiptsManager.getReceipts(blockHash)

// Get receipt by transaction hash
const receipt = await receiptsManager.getReceiptByTxHash(txHash)
```

#### Working with Logs

```typescript
// Query logs with filters
const logs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  addresses,
  topics
)
```

### Constants and Limits

The ReceiptsManager includes several important limits:

```typescript
GET_LOGS_LIMIT = 10000 // Maximum number of logs to return
GET_LOGS_LIMIT_MEGABYTES = 150 // Size limit for getLogs response
GET_LOGS_BLOCK_RANGE_LIMIT = 2500 // Block range limit for getLogs
```

### Error Handling

The package includes proper error handling for common scenarios:

```typescript
try {
  const receipt = await receiptsManager.getReceiptByTxHash(txHash)
  if (!receipt) {
    // Handle missing receipt
  }
} catch (error) {
  // Handle errors
}
```

### Types

The package exports several important types:

```typescript
type TxReceipt = PreByzantiumTxReceipt | PostByzantiumTxReceipt | EIP4844BlobTxReceipt
type TxReceiptWithType = PreByzantiumTxReceiptWithType | PostByzantiumTxReceiptWithType
type DbType = "Receipts" | "TxHash" | "SkeletonBlock" | "SkeletonBlockHashToNumber" |
  "SkeletonStatus" | "SkeletonUnfinalizedBlockByHash" | "Preimage"
```

### License

This package is licensed under the MIT License. Some files are adapted from [ethereumjs](https://github.com/ethereumjs/ethereumjs-monorepo) and are licensed under the Mozilla Public License 2.0.


## @tevm/rlp API Reference

This documentation is generated from the source code. View the full API documentation on GitHub:

[View @tevm/rlp API Reference on GitHub](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs/globals.md)

### Quick Links

* [Type Aliases](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs/type-aliases)
* [Classes](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs/classes)
* [Functions](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs/functions)
* [Variables](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs/variables)

### Return to Documentation

* [Back to Getting Started](/getting-started/overview)
* [Package Overview](/reference)




## @tevm/state

The `@tevm/state` package provides a robust state management system for Tevm, handling Ethereum account states, contract storage, and state transitions. It offers both synchronous and asynchronous APIs for managing the EVM state.

### Installation

```bash
npm install @tevm/state
```

### Overview

The state package is responsible for:

* Managing account states (balance, nonce, code, storage)
* Handling state transitions and checkpoints
* Caching and persistence of state data
* Supporting forked chain states
* Providing efficient state access and modification

### API Reference

#### Enumerations

* [CacheType](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/enumerations/CacheType.md) - Types of caching mechanisms

#### Core Types

##### State Management

* [StateManager](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/interfaces/StateManager.md) - Main interface for state operations
* [BaseState](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/BaseState.md) - Core state data structure
* [TevmState](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/TevmState.md) - Tevm-specific state representation
* [StateAction](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/StateAction.md) - Type for state modification actions
* [StateOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/StateOptions.md) - State configuration options
* [StateRoots](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/StateRoots.md) - State roots mapping
* [ParameterizedTevmState](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/ParameterizedTevmState.md) - Parameterized state type

##### Storage Types

* [AccountStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/interfaces/AccountStorage.md) - Account storage structure
* [ParameterizedAccountStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/interfaces/ParameterizedAccountStorage.md) - Parameterized account storage interface
* [SerializableTevmState](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/SerializableTevmState.md) - Serializable state format
* [ForkOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/interfaces/ForkOptions.md) - Options for forking state

##### Caching

* [StateCache](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/type-aliases/StateCache.md) - State caching structure
* [AccountCache](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/classes/AccountCache.md) - Account-level cache
* [ContractCache](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/classes/ContractCache.md) - Contract-level cache
* [StorageCache](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/classes/StorageCache.md) - Storage-level cache

#### Core Functions

##### State Creation and Management

* [createStateManager](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/createStateManager.md) - Creates a new state manager instance
* [createBaseState](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/createBaseState.md) - Creates the core state data structure
* [deepCopy](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/deepCopy.md) - Creates deep copy of state
* [shallowCopy](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/shallowCopy.md) - Creates shallow copy

##### State Operations

* [getAccount](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getAccount.md) - Retrieves account state
* [putAccount](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/putAccount.md) - Updates account state
* [deleteAccount](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/deleteAccount.md) - Removes an account
* [getContractCode](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getContractCode.md) - Gets contract bytecode
* [putContractCode](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/putContractCode.md) - Updates contract bytecode
* [getContractStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getContractStorage.md) - Gets contract storage
* [putContractStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/putContractStorage.md) - Updates contract storage
* [clearContractStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/clearContractStorage.md) - Clears contract storage
* [getAccountAddresses](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getAccountAddresses.md) - Gets account addresses
* [getAppliedKey](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getAppliedKey.md) - Gets applied storage key
* [modifyAccountFields](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/modifyAccountFields.md) - Modifies account fields

##### State Root Management

* [getStateRoot](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getStateRoot.md) - Gets current state root
* [setStateRoot](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/setStateRoot.md) - Sets new state root
* [hasStateRoot](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/hasStateRoot.md) - Checks if state root exists

##### Checkpointing and Committing

* [checkpoint](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/checkpoint.md) - Creates a state checkpoint
* [commit](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/commit.md) - Commits state changes
* [revert](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/revert.md) - Reverts to previous checkpoint

##### Cache Management

* [clearCaches](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/clearCaches.md) - Clears all state caches
* [originalStorageCache](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/originalStorageCache.md) - Manages original storage cache

##### Genesis and Forking

* [dumpCanonicalGenesis](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/dumpCanonicalGenesis.md) - Dumps canonical genesis state
* [generateCanonicalGenesis](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/generateCanonicalGenesis.md) - Generates canonical genesis
* [getForkBlockTag](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getForkBlockTag.md) - Gets fork block tag
* [getForkClient](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getForkClient.md) - Gets fork client

##### Storage Operations

* [dumpStorage](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/dumpStorage.md) - Dumps storage state
* [dumpStorageRange](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/dumpStorageRange.md) - Dumps storage range
* [getProof](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs/functions/getProof.md) - Gets state proof

### Usage Examples

#### Creating a State Manager

```
```


## @tevm/trie API Reference

This documentation is generated from the source code. View the full API documentation on GitHub:

[View @tevm/trie API Reference on GitHub](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs/globals.md)

### Quick Links

* [Type Aliases](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs/type-aliases)
* [Classes](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs/classes)
* [Functions](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs/functions)
* [Variables](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs/variables)

### Return to Documentation

* [Back to Getting Started](/getting-started/overview)
* [Package Overview](/reference)


## @tevm/tx

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/tx/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs) folder.

The `@tevm/tx` package provides a custom implementation of Ethereum transactions, extending the functionality of `@ethereumjs/tx`. It includes support for various transaction types and introduces impersonated transactions unique to Tevm.

### Installation

```bash
npm install @tevm/tx
```

### API Reference

#### Enumerations

* [Capability](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/enumerations/Capability.md) - Transaction capabilities
* [TransactionType](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/enumerations/TransactionType.md) - Supported transaction types

#### Classes

* [AccessListEIP2930Transaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/classes/AccessListEIP2930Transaction.md) - Type 1 transaction implementation
* [BlobEIP4844Transaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/classes/BlobEIP4844Transaction.md) - Type 3 transaction implementation
* [FeeMarketEIP1559Transaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/classes/FeeMarketEIP1559Transaction.md) - Type 2 transaction implementation
* [LegacyTransaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/classes/LegacyTransaction.md) - Legacy transaction implementation
* [TransactionFactory](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/classes/TransactionFactory.md) - Factory for creating transactions

#### Interfaces

* [EIP1559CompatibleTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/EIP1559CompatibleTx.md) - EIP-1559 transaction interface
* [EIP4844CompatibleTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/EIP4844CompatibleTx.md) - EIP-4844 transaction interface
* [ImpersonatedTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/ImpersonatedTx.md) - Impersonated transaction interface
* [JsonRpcTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/JsonRpcTx.md) - JSON-RPC transaction format
* [JsonTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/JsonTx.md) - JSON transaction format
* [TxData](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/TxData.md) - Transaction data interface
* [TxOptions](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/interfaces/TxOptions.md) - Transaction options interface

#### Type Aliases

* [AccessList](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/type-aliases/AccessList.md) - Access list type definition
* [AccessListItem](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/type-aliases/AccessListItem.md) - Access list item type
* [TypedTransaction](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/type-aliases/TypedTransaction.md) - Union type of all transaction types

#### Functions

* [createImpersonatedTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/functions/createImpersonatedTx.md) - Create an impersonated transaction
* [isAccessListEIP2930Tx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/functions/isAccessListEIP2930Tx.md) - Type guard for EIP-2930 transactions
* [isBlobEIP4844Tx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/functions/isBlobEIP4844Tx.md) - Type guard for EIP-4844 transactions
* [isFeeMarketEIP1559Tx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/functions/isFeeMarketEIP1559Tx.md) - Type guard for EIP-1559 transactions
* [isLegacyTx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs/functions/isLegacyTx.md) - Type guard for legacy transactions

### Main Components

#### Transaction Types

The package supports multiple transaction types:

* **LegacyTransaction**: Pre-EIP-2718 transactions
* **AccessListEIP2930Transaction**: Type 1 transactions with access lists (EIP-2930)
* **FeeMarketEIP1559Transaction**: Type 2 transactions with fee market (EIP-1559)
* **BlobEIP4844Transaction**: Type 3 transactions with blob data (EIP-4844)
* **ImpersonatedTx**: Tevm-specific transaction type for impersonating accounts

#### TransactionFactory

A utility class for creating transactions from various data formats:

```typescript
import { TransactionFactory } from '@tevm/tx'

// Create from serialized data
const tx = TransactionFactory.fromSerializedTx(serializedData)

// Create from RPC data
const tx = await TransactionFactory.fromRPC(rpcTxData)

// Create from block body data
const tx = TransactionFactory.fromBlockBodyData(blockData)
```

#### Impersonated Transactions

A unique feature of Tevm that allows simulating transactions as if they were sent from any address:

```typescript
import { createImpersonatedTx } from '@tevm/tx'

const tx = createImpersonatedTx({
  impersonatedAddress: address,
  to: recipient,
  value: value,
  data: data,
  // ... other EIP-1559 transaction fields
})
```

### Transaction Types

#### Legacy Transactions

Pre-EIP-2718 transactions with basic fields:

```typescript
interface LegacyTxData {
  nonce: bigint
  gasPrice: bigint
  gasLimit: bigint
  to?: Address
  value: bigint
  data: Uint8Array
  v?: bigint
  r?: bigint
  s?: bigint
}
```

#### EIP-2930 Transactions

Type 1 transactions with access lists:

```typescript
interface AccessListEIP2930TxData extends LegacyTxData {
  chainId: bigint
  accessList: AccessList
}
```

#### EIP-1559 Transactions

Type 2 transactions with fee market:

```typescript
interface FeeMarketEIP1559TxData extends AccessListEIP2930TxData {
  maxFeePerGas: bigint
  maxPriorityFeePerGas: bigint
}
```

#### EIP-4844 Transactions

Type 3 transactions with blob data:

```typescript
interface BlobEIP4844TxData extends FeeMarketEIP1559TxData {
  maxFeePerBlobGas: bigint
  blobVersionedHashes: Uint8Array[]
  blobs?: Uint8Array[]
  kzgCommitments?: Uint8Array[]
  kzgProofs?: Uint8Array[]
}
```

### Common Operations

#### Creating Transactions

```typescript
import { TransactionFactory, LegacyTransaction } from '@tevm/tx'

// Using factory
const tx = TransactionFactory.fromTxData({
  nonce: 0n,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: '0x...',
  value: 1000000000000000000n,
  data: new Uint8Array()
})

// Direct instantiation
const legacyTx = new LegacyTransaction({
  nonce: 0n,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: '0x...',
  value: 1000000000000000000n,
  data: new Uint8Array()
})
```

#### Signing Transactions

```typescript
const signedTx = tx.sign(privateKey)
```

#### Transaction Methods

All transaction types provide common methods:

* `hash()`: Get transaction hash
* `getBaseFee()`: Get minimum required gas
* `getDataFee()`: Get gas cost for data
* `getUpfrontCost()`: Get total required balance
* `isSigned()`: Check if transaction is signed
* `serialize()`: Get RLP encoded transaction
* `toJSON()`: Get JSON representation

### Error Handling

The package includes custom error types:

```typescript
import { InvalidGasLimitError } from '@tevm/tx'

try {
  const tx = createImpersonatedTx(txData)
} catch (e) {
  if (e instanceof InvalidGasLimitError) {
    // Handle invalid gas limit
  }
}
```

### See Also

* [EIP-2718: Typed Transaction Envelope](https://eips.ethereum.org/EIPS/eip-2718)
* [EIP-2930: Optional access lists](https://eips.ethereum.org/EIPS/eip-2930)
* [EIP-1559: Fee market change](https://eips.ethereum.org/EIPS/eip-1559)
* [EIP-4844: Shard Blob Transactions](https://eips.ethereum.org/EIPS/eip-4844)


## @tevm/txpool

The `@tevm/txpool` package provides a transaction pool (mempool) implementation for Tevm, managing pending transactions and their lifecycle within the Ethereum Virtual Machine.

### Installation

```bash
npm install @tevm/txpool
```

### Overview

The transaction pool is responsible for:

* Managing pending transactions
* Validating transaction requirements
* Ordering transactions by price and nonce
* Handling transaction replacement
* Cleaning up stale transactions
* Supporting transaction lifecycle management

### API Reference

#### Core Class

##### TxPool

[`TxPool`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts) - The main transaction pool class with the following key features:

##### Constructor

```typescript
new TxPool(options: TxPoolOptions)
```

##### Properties

* `BLOCKS_BEFORE_TARGET_HEIGHT_ACTIVATION`: Number of blocks before chain head to start tx pool preparation
* `POOLED_STORAGE_TIME_LIMIT`: Number of minutes to keep txs in the pool
* `HANDLED_CLEANUP_TIME_LIMIT`: Number of minutes to forget about handled txs
* `pool`: The central pool dataset mapping addresses to transactions
* `running`: Boolean indicating if the pool is running
* `txsInPool`: Number of transactions currently in the pool

##### Methods

* [`add`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L310) - Adds a transaction to the pool
* [`addUnverified`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L280) - Adds an unverified transaction to the pool
* [`getByHash`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L320) - Retrieves transactions by their hashes
* [`removeByHash`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L341) - Removes a transaction by its hash
* [`txsByPriceAndNonce`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L477) - Returns transactions sorted by price and nonce
* [`cleanup`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L374) - Performs pool cleanup
* [`open`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L141) - Opens the transaction pool
* [`close`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L581) - Closes the transaction pool
* [`start`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L153) - Starts transaction processing
* [`stop`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L570) - Stops transaction processing
* [`deepCopy`](https://github.com/evmts/tevm-monorepo/blob/main/packages/txpool/src/TxPool.ts#L128) - Creates a deep copy of the pool

### Usage Examples

#### Creating and Managing a Transaction Pool

```typescript
import { TxPool } from '@tevm/txpool'
import { createCommon } from '@tevm/common'

const common = createCommon({ chain: 'mainnet' })
const txPool = new TxPool({
  common,
  maxPoolSize: 5000,
  minGasPriceBump: 10 // 10% price bump for replacement
})

// Start the pool
txPool.open()
txPool.start()
```

#### Adding Transactions

```typescript
// Add a new transaction
await txPool.add(transaction, {
  requireSignature: true,
  skipBalance: false
})

// Add an unverified transaction
await txPool.addUnverified(transaction)
```

#### Retrieving Transactions

```typescript
// Get transactions by hash
const txs = txPool.getByHash(txHashes)

// Get transactions by sender
const senderTxs = await txPool.getBySenderAddress(senderAddress)

// Get transactions ordered by price and nonce
const orderedTxs = await txPool.txsByPriceAndNonce({
  baseFee: 1000000000n,
  allowedBlobs: 3
})
```

#### Managing Transaction Lifecycle

```typescript
// Remove a transaction
txPool.removeByHash(txHash)

// Remove transactions included in new blocks
txPool.removeNewBlockTxs(newBlocks)

// Perform cleanup of stale transactions
txPool.cleanup()
```

#### Pool Lifecycle Management

```typescript
// Start the pool
txPool.open()
txPool.start()

// Stop the pool
txPool.stop()
txPool.close()

// Create a copy of the pool
const poolCopy = txPool.deepCopy(options)
```

### Configuration

The transaction pool can be configured with various options:

```typescript
interface TxPoolOptions {
  common: Common
  maxPoolSize?: number
  minGasPriceBump?: number
  minFeeBump?: number
  maxPendingTotal?: number
  maxPendingPerAccount?: number
  maxQueuedTotal?: number
  maxQueuedPerAccount?: number
  minPendingNodeBalance?: bigint
  minRemainingGasLimit?: bigint
}
```

#### Configuration Options

* `maxPoolSize`: Maximum number of transactions in the pool
* `minGasPriceBump`: Minimum price bump percentage for transaction replacement
* `minFeeBump`: Minimum fee bump for transaction replacement
* `maxPendingTotal`: Maximum number of pending transactions
* `maxPendingPerAccount`: Maximum pending transactions per account
* `maxQueuedTotal`: Maximum number of queued transactions
* `maxQueuedPerAccount`: Maximum queued transactions per account
* `minPendingNodeBalance`: Minimum balance required for pending transactions
* `minRemainingGasLimit`: Minimum gas limit for remaining transactions

### Error Handling

The transaction pool throws specific errors for various failure scenarios:

```typescript
try {
  await txPool.add(transaction)
} catch (error) {
  if (error.code === 'POOL_FULL') {
    console.error('Transaction pool is full')
  } else if (error.code === 'UNDERPRICED') {
    console.error('Transaction is underpriced')
  } else if (error.code === 'NONCE_TOO_LOW') {
    console.error('Transaction nonce is too low')
  }
}
```

### Best Practices

1. **Regular Cleanup**: Call `cleanup()` periodically to remove stale transactions
2. **Transaction Replacement**: Use appropriate gas price bumps for replacement transactions
3. **Pool Size Management**: Monitor and adjust pool size limits based on network conditions
4. **Error Handling**: Implement proper error handling for transaction additions and removals
5. **Lifecycle Management**: Properly manage pool lifecycle with `open()`, `start()`, `stop()`, and `close()`

### Related Packages

* [@tevm/vm](./vm) - Virtual Machine implementation
* [@tevm/state](./state) - State management
* [@tevm/common](./common) - Chain configuration

### License

MIT


## Utilities & Addresses

Tevm exports a set of lightweight utility functions and classes. Many of these build upon lower-level packages like [`tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) and [`viem`](https://viem.sh) while standardizing usage for Tevm Node. Below are the most commonly used.

### createAddress

Creates an [Ethereum address](https://ethereum.org/en/developers/docs/accounts/#account-creation) from various input formats:

```ts
import { createAddress } from 'tevm/address'

// Creates a TEVM-style Address object from various input forms
let addr = createAddress(`0x${"00".repeat(20)}`)
// from a hex string
addr = createAddress(420n)
// from a bigint
addr = createAddress(new Uint8Array(20))
// from a 20-byte array
```

#### Signature

```ts
declare function createAddress(
  address: number | bigint | string | Uint8Array | EthjsAddress
): Address
```

#### Behavior & Notes

* Accepts various input types: [`0x`-prefixed hex strings](https://ethereum.org/en/developers/docs/data-structures-and-encoding/hex/), unprefixed hex, numbers, bigints, `Uint8Array`s, or `EthjsAddress`.
* Throws `InvalidAddressError` if it can't parse a valid 20-byte address from the input.

### Address Class

A thin wrapper around [`EthjsAddress`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/util) offering a simple, consistent shape for Tevm Node. Created by `createAddress` or by forging your own:

```ts
import { Address } from 'tevm/address'

const a = new Address(Uint8Array.from([ /* 20 bytes */ ]))
console.log(a.bytes)  // a raw 20-byte address
console.log(a.toString()) // 0x....
```

### createContractAddress

Creates a contract address following [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014):

```ts
import { createContractAddress } from 'tevm/address'

// from an existing address + nonce, produce the CREATE address
const from = createAddress("0x1111...1111")
const nonce = 1n
const contractAddr = createContractAddress(from, nonce)
```

#### Usage

1. Follows standard Ethereum's [`keccak256(rlp([senderAddress, nonce]))[-20..]`](https://ethereum.org/en/developers/docs/smart-contracts/deploying/#how-to-deploy-a-smart-contract).
2. Ideal for simulating `CREATE` addresses in test or dev flows.

#### Error Handling

* Throws `InvalidAddressError` if the `from` address is invalid.

### Common Errors

* **InvalidAddressError**
  Thrown when a string/bytes input fails to parse as a valid 20-byte address.

* **UnreachableCodeError**
  Thrown internally if a code path was unexpectedly reached. Generally wrapped into a more descriptive error.

### Other Handy Utilities

Some additional lower-level utility re-exports from [`tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) or [`viem`](https://viem.sh):

* `hexToBytes(hex: string): Uint8Array`
  Convert a hex string to raw bytes (with optional size checks).
* `keccak256(data: Uint8Array | HexString, 'bytes' | 'hex')`
  A standard [keccak256](https://ethereum.org/en/developers/docs/smart-contracts/security/#keccak256-and-sha-3) hasher.
* `encodeFunctionData(...)`, `toRlp(...)`, etc.
  Various encoding helpers used by Tevm Node internally.

> **Tip:** If you are building higher-level code in the browser or Node, you may prefer [`viem`](https://viem.sh)'s standardized utilities for bytes conversions, hashing, and ABIs. Tevm re-exports many of these for convenience.

## @tevm/utils

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/utils/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils/docs) folder.

The `@tevm/utils` package provides a comprehensive collection of utility functions and types for working with Ethereum data structures, encoding/decoding, and common operations. It combines functionality from various Ethereum libraries and adds Tevm-specific utilities.

### Installation

```bash
npm install @tevm/utils
```

### Main Components

#### Data Types and Encoding

##### Hex and Bytes Conversion

```typescript
import {
  bytesToHex,
  hexToBytes,
  bytesToBigInt,
  bytesToNumber,
  hexToBigInt,
  hexToNumber,
  numberToHex,
  stringToHex,
  hexToString
} from '@tevm/utils'

// Convert bytes to hex
const hex = bytesToHex(new Uint8Array([1, 164])) // '0x01a4'

// Convert hex to bytes
const bytes = hexToBytes('0x01a4') // Uint8Array([1, 164])

// Convert to/from numbers
const num = hexToNumber('0x01a4') // 420
const hex2 = numberToHex(420) // '0x01a4'

// String conversion
const str = hexToString('0x48656c6c6f') // 'Hello'
const hex3 = stringToHex('Hello') // '0x48656c6c6f'
```

##### Type Checking

```typescript
import { isHex, isBytes, isAddress } from '@tevm/utils'

isHex('0x123') // true
isBytes(new Uint8Array()) // true
isAddress('0x123...') // true
```

#### Ethereum Specific

##### Unit Conversion

```typescript
import {
  formatEther,
  parseEther,
  formatGwei,
  parseGwei
} from '@tevm/utils'

// Convert wei to ether
formatEther(1000000000000000000n) // '1.0'

// Convert ether to wei
parseEther('1.0') // 1000000000000000000n

// Work with gwei
formatGwei(1000000000n) // '1.0'
parseGwei('1.0') // 1000000000n
```

##### Cryptographic Functions

```typescript
import {
  keccak256,
  ecrecover,
  ecsign,
  randomBytes
} from '@tevm/utils'

// Generate keccak256 hash
const hash = keccak256('0x1234')

// Sign data
const signature = ecsign(messageHash, privateKey)

// Recover address from signature
const address = ecrecover(messageHash, v, r, s)

// Generate random bytes
const random = randomBytes(32)
```

#### ABI Encoding/Decoding

```typescript
import {
  encodeAbiParameters,
  decodeAbiParameters,
  encodeFunctionData,
  decodeFunctionData,
  encodeEventTopics,
  decodeEventLog
} from '@tevm/utils'

// Encode function data
const data = encodeFunctionData({
  abi: [...],
  functionName: 'transfer',
  args: [address, amount]
})

// Decode function data
const result = decodeFunctionData({
  abi: [...],
  data: '0x...'
})

// Work with events
const topics = encodeEventTopics({
  abi: [...],
  eventName: 'Transfer',
  args: [from, to, null]
})
```

#### RLP Encoding/Decoding

```typescript
import { toRlp, fromRlp } from '@tevm/utils'

// Encode to RLP
const rlp = toRlp(['0x123', '0x456'])

// Decode from RLP
const decoded = fromRlp(rlp)
```

#### Memory Database

```typescript
import { createMemoryDb } from '@tevm/utils'

// Create an in-memory database
const db = createMemoryDb()

// Initialize with existing data
const initialData = new Map()
const db2 = createMemoryDb(initialData)
```

#### Event Emitter

```typescript
import { AsyncEventEmitter } from '@tevm/utils'

const emitter = new AsyncEventEmitter()

// Add listener
emitter.on('event', async (data) => {
  // Handle event
})

// Emit event
await emitter.emit('event', data)
```

### Types

#### Basic Types

```typescript
import type {
  Address,
  Hex,
  BlockTag,
  BlockNumber,
  BytesLike,
  BigIntLike
} from '@tevm/utils'

// Example type usage
const address: Address = '0x...'
const hex: Hex = '0x...'
const blockTag: BlockTag = 'latest'
```

#### ABI Types

```typescript
import type {
  Abi,
  AbiFunction,
  AbiEvent,
  AbiConstructor,
  ParseAbi,
  FormatAbi
} from '@tevm/utils'

// Parse ABI
type ParsedAbi = ParseAbi<typeof abiString>

// Format ABI
type FormattedAbi = FormatAbi<typeof parsedAbi>
```

#### Contract Types

```typescript
import type {
  ContractFunctionName,
  ContractConstructorArgs,
  ExtractAbiFunction,
  ExtractAbiEvent
} from '@tevm/utils'

// Extract function from ABI
type TransferFunction = ExtractAbiFunction<typeof abi, 'transfer'>

// Extract event from ABI
type TransferEvent = ExtractAbiEvent<typeof abi, 'Transfer'>
```

### Constants

```typescript
import {
  GWEI_TO_WEI,
  KECCAK256_RLP,
  KECCAK256_RLP_ARRAY
} from '@tevm/utils'

// Common conversion factors and constants
console.log(GWEI_TO_WEI) // 1000000000n
```

### Error Handling

The package uses the `@tevm/errors` package for standardized error handling:

```typescript
import { invariant } from '@tevm/utils'

// Assert conditions
invariant(condition, 'Error message')
```

### See Also

* [Viem Documentation](https://viem.sh/docs/utilities/fromBytes)
* [EthereumJS Util Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/util)
* [ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html)


## @tevm/vm

The `@tevm/vm` package provides a high-performance Ethereum Virtual Machine (EVM) implementation specifically designed for Tevm. It extends the functionality of the base EVM with additional features for testing, debugging, and development purposes.

### Installation

```bash
npm install @tevm/vm
```

### Overview

The VM package is a core component of Tevm that handles the execution of EVM bytecode, transaction processing, and block building. It provides a robust set of tools for:

* Executing EVM bytecode and smart contracts
* Processing transactions and blocks
* Managing state transitions
* Supporting various hardforks and EIPs
* Debugging and profiling execution

### API Reference

#### Core Types

##### Vm

The main VM type that extends the base VM with Tevm-specific functionality:

* [`Vm`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/Vm.ts#L6) - Core VM type with methods for block building, transaction execution, and state management

##### Block Building

* [`BlockBuilder`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/BlockBuilder.ts) - Class for building and managing blocks
* [`BuildBlock`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/buildBlock.ts#L5) - Function type for block building operations
* [`BuildBlockOpts`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/BuildBlockOpts.ts) - Options for block building
* [`BuildStatus`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/BuildStatus.ts) - Enumeration of block building states

##### Transaction Processing

* [`RunTx`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/runTx.ts) - Function type for transaction execution
* [`RunTxOpts`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/RunTxOpts.ts) - Options for transaction execution
* [`RunTxResult`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/RunTxResult.ts) - Result of transaction execution

##### Block Processing

* [`RunBlock`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/runBlock.ts) - Function type for block execution
* [`RunBlockOpts`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/RunBlockOpts.ts) - Options for block execution
* [`RunBlockResult`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/RunBlockResult.ts) - Result of block execution

##### Events

* [`AfterTxEvent`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/events/AfterTxEvent.ts) - Event emitted after transaction execution
* [`AfterBlockEvent`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/events/AfterBlockEvent.ts) - Event emitted after block execution
* [`VMEvents`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/utils/VMEvents.ts) - VM event types and handlers

#### Core Functions

##### VM Creation and Management

* [`createVm`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/createVm.js#L11) - Creates a new VM instance
* [`deepCopy`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/deepCopy.js#L20) - Creates a deep copy of a VM instance

##### Block Operations

* [`applyBlock`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/applyBlock.ts#L24) - Applies a block to the current state
* [`buildBlock`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/buildBlock.ts#L8) - Creates a new block builder instance
* [`genTxTrie`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/genTxTrie.ts#L6) - Generates transaction trie for a block

##### Transaction Operations

* [`validateRunTx`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/validateRunTx.js#L10) - Validates transaction parameters before execution

##### State Management

* [`applyDAOHardfork`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/applyDAOHardfork.js) - Applies the DAO hardfork state changes
* [`execHardfork`](https://github.com/evmts/tevm-monorepo/blob/main/packages/vm/src/actions/execHardfork.js#L14) - Executes hardfork-specific operations

### Usage Examples

#### Creating a VM Instance

```typescript
import { createVm } from '@tevm/vm'
import { Common } from '@tevm/common'

const common = new Common({ chain: 'mainnet' })
const vm = createVm({ common })
```

#### Building and Executing a Block

```typescript
import { createVm, BlockBuilder } from '@tevm/vm'

const vm = createVm({ /* options */ })
const blockBuilder = await vm.buildBlock({
  parentBlock: block,
  blockOpts: { /* options */ }
})

// Add transactions to the block
await blockBuilder.addTransaction(tx)

// Build and execute the block
const block = await blockBuilder.build()
const result = await vm.runBlock({ block })
```

#### Executing a Transaction

```typescript
import { createVm } from '@tevm/vm'

const vm = createVm({ /* options */ })
const txResult = await vm.runTx({ tx })

console.log('Gas used:', txResult.gasUsed.toString())
console.log('Return value:', txResult.execResult.returnValue)
```

### Error Handling

The VM package throws specific error types for different failure scenarios:

* Transaction execution errors (invalid nonce, insufficient balance, etc.)
* Block validation errors (invalid state root, gas limit, etc.)
* VM execution errors (out of gas, invalid opcode, etc.)

Example error handling:

```typescript
try {
  await vm.runTx({ tx })
} catch (error) {
  if (error.code === 'INVALID_OPCODE') {
    console.error('Invalid operation in contract code')
  } else if (error.code === 'OUT_OF_GAS') {
    console.error('Transaction ran out of gas')
  }
}
```

### Configuration

The VM can be configured with various options through the `VMOpts` interface:

```typescript
const vm = createVm({
  common, // Chain configuration
  stateManager, // Custom state manager
  blockchain, // Custom blockchain
  activatePrecompiles: true, // Activate precompiled contracts
  // ... other options
})
```

### Related Packages

* [@tevm/state](./state) - State management for the VM
* [@tevm/common](./common) - Chain configuration and utilities
* [@tevm/blockchain](./blockchain) - Blockchain management

### License

MIT

