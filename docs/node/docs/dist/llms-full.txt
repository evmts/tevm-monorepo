# Tevm Node

> An EVM node that runs in the browser

## Getting Started

Welcome to [Tevm Node](https://github.com/evmts/tevm-monorepo)! This guide will help you navigate our documentation and get started with running [Ethereum](https://ethereum.org) in JavaScript.

If you're impatient, try creating a [memory client](/api/memory-client) and using the [viem API](https://viem.sh) to interact with a locally running blockchain in JavaScript:

```bash
npm install tevm
```

```typescript
import { createMemoryClient, http } from 'tevm'
import { optimism } from 'tevm/common'

// Create a client that forks from Optimism mainnet
const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io')({}),
    blockTag: 'latest',
  },
  common: optimism,
})

// Read block data using viem's public actions
const block = await client.getBlock({ blockTag: 'latest' })
console.log(block)

// Manipulate state using Tevm actions
const testAddress = '0x1234567890123456789012345678901234567890'
await client.tevmSetAccount({
  address: testAddress,
  balance: 1000000000000000000n // 1 ETH
})

// Get account state
const account = await client.tevmGetAccount({ address: testAddress })
console.log(account)
```

### Quick Start

Start here to understand the basics:

* [What is Tevm Node?](./introduction/what-is-tevm-node) - Overview and key features
* [Architecture Overview](./introduction/architecture-overview) - High-level explanation of how Tevm works
* [Why run Ethereum in JS?](./introduction/why-run-ethereum-in-js) - Benefits and use cases
* [Installation & Quickstart](./introduction/installation) - Get up and running

### Learning Path

#### 1. Core Concepts

Learn the fundamental building blocks:

* [Creating a Node](./core/create-tevm-node) - Set up and configure your node
* [Node Interface](./core/tevm-node-interface) - Understand the main API surface
* [Forking & Reforking](./core/forking) - Fork from networks or other Tevm instances
* [Managing State](./core/managing-state) - Handle accounts, storage, and blockchain state
* [Mining Configuration](#TODO) - Configure block production

#### 2. Essential APIs

Most commonly used APIs:

* [tevmCall API](./api/tevm-call) - Execute contract calls and transactions
* [JSON-RPC Support](./api/json-rpc) - Standard Ethereum JSON-RPC interface
* [Account Management](./api/account-management) - Work with accounts and balances
* [Contract Utilities](./api/contracts) - Create and interact with contracts
* [Utilities & Addresses](./api/utils) - Core utilities for addresses and common operations
* [Methods & Properties](./api/methods) - Complete API reference
* [VM & Submodules](./api/vm-and-submodules) - Internal architecture based on ethereumjs
* [EVM Events](./api/evm-events) - Debug and trace EVM execution

#### 3. Integration Examples

Real-world usage examples:

* [Local Testing](./examples/local-testing) - Write tests for your contracts
* [Forking Mainnet](./examples/forking-mainnet) - Work with production state locally
* [Using with Viem](./examples/viem) - Integration with [Viem](https://viem.sh)
* [Using with Ethers](./examples/ethers) - Integration with [Ethers.js](https://docs.ethers.org)

#### 4. Advanced Features

Dive deeper into advanced capabilities:

* [Transaction Pool](./advanced/txpool) - Manage pending transactions
* [Custom Precompiles](./advanced/custom-precompiles) - Extend EVM functionality
* [Performance Profiler](./advanced/performance-profiler) - Optimize performance
* [Receipts & Logs](./advanced/receipts-and-logs) - Handle events and logs

### Key Features

#### Forking & State Management

* Fork from any EVM-compatible network
* Memory-efficient reforking strategies
* Complete state control and manipulation
* Account impersonation for testing

#### Performance & Flexibility

* Automatic or manual block mining
* Lazy loading with caching
* Custom precompiles in JavaScript
* Comprehensive debugging tools

#### Developer Experience

* TypeScript-first design
* Viem & Ethers.js compatibility
* Standard JSON-RPC support
* Rich testing utilities

### Package Documentation

All Tevm packages can be installed individually (e.g., `npm install @tevm/actions`) or together by installing `tevm` and importing from the specific package (e.g., `import { ... } from 'tevm/actions'`). Each package has its own generated API documentation:

#### Core Packages

* [@tevm/actions](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs) - Comprehensive set of actions for interacting with the Tevm client
* [@tevm/vm](https://github.com/evmts/tevm-monorepo/tree/main/packages/vm/docs) - Custom Ethereum Virtual Machine implementation
* [@tevm/state](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs) - State management for accounts, storage, and contracts
* [@tevm/blockchain](https://github.com/evmts/tevm-monorepo/tree/main/packages/blockchain/docs) - Blockchain implementation and block management
* [@tevm/evm](https://github.com/evmts/tevm-monorepo/tree/main/packages/evm/docs) - EVM execution environment and bytecode processing

#### Transaction & Block Handling

* [@tevm/block](https://github.com/evmts/tevm-monorepo/tree/main/packages/block/docs) - Block creation and manipulation utilities
* [@tevm/tx](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs) - Transaction types and handling
* [@tevm/txpool](https://github.com/evmts/tevm-monorepo/tree/main/packages/txpool/docs) - Transaction pool (mempool) implementation
* [@tevm/receipt-manager](https://github.com/evmts/tevm-monorepo/tree/main/packages/receipt-manager/docs) - Transaction receipt management

#### Client & Communication

* [@tevm/memory-client](https://github.com/evmts/tevm-monorepo/tree/main/packages/memory-client/docs) - In-memory Ethereum client implementation
* [@tevm/http-client](https://github.com/evmts/tevm-monorepo/tree/main/packages/http-client/docs) - HTTP client for remote Tevm nodes
* [@tevm/jsonrpc](https://github.com/evmts/tevm-monorepo/tree/main/packages/jsonrpc/docs) - JSON-RPC protocol implementation
* [@tevm/server](https://github.com/evmts/tevm-monorepo/tree/main/packages/server/docs) - Tevm server implementation

#### Smart Contract Tools

* [@tevm/contract](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract/docs) - Smart contract interaction utilities
* [@tevm/precompiles](https://github.com/evmts/tevm-monorepo/tree/main/packages/precompiles/docs) - Precompiled contract implementations
* [@tevm/predeploys](https://github.com/evmts/tevm-monorepo/tree/main/packages/predeploys/docs) - Pre-deployed contract management

#### Utilities & Helpers

* [@tevm/utils](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils/docs) - Common utilities for Ethereum data structures
* [@tevm/common](https://github.com/evmts/tevm-monorepo/tree/main/packages/common/docs) - Shared constants and chain configurations
* [@tevm/decorators](https://github.com/evmts/tevm-monorepo/tree/main/packages/decorators/docs) - Function decorators for extending client functionality
* [@tevm/procedures](https://github.com/evmts/tevm-monorepo/tree/main/packages/procedures/docs) - Common procedures and operations
* [@tevm/rlp](https://github.com/evmts/tevm-monorepo/tree/main/packages/rlp/docs) - RLP encoding/decoding utilities
* [@tevm/trie](https://github.com/evmts/tevm-monorepo/tree/main/packages/trie/docs) - Merkle Patricia Tree implementation

#### Development & Error Handling

* [@tevm/errors](https://github.com/evmts/tevm-monorepo/tree/main/packages/errors/docs) - Error types and handling
* [@tevm/logger](https://github.com/evmts/tevm-monorepo/tree/main/packages/logger/docs) - Logging functionality
* [@tevm/effect](https://github.com/evmts/tevm-monorepo/tree/main/packages/effect/docs) - Effect system for handling side effects

#### Storage & Synchronization

* [@tevm/sync-storage-persister](https://github.com/evmts/tevm-monorepo/tree/main/packages/sync-storage-persister/docs) - Storage persistence and synchronization
* [@tevm/client-types](https://github.com/evmts/tevm-monorepo/tree/main/packages/client-types/docs) - Type definitions for client interfaces
* [@tevm/node](https://github.com/evmts/tevm-monorepo/tree/main/packages/node/docs) - Node implementation and management
* [@tevm/address](https://github.com/evmts/tevm-monorepo/tree/main/packages/address/docs) - Ethereum address utilities and validation

### Additional Resources

* [Ethereum Development Documentation](https://ethereum.org/en/developers/docs/) - Official Ethereum docs
* [EVM Deep Dive](https://ethereum.org/en/developers/docs/evm/) - Understanding the EVM
* [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) - Standard Ethereum API
* [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo) - Core EVM implementation


## Custom Precompiles

[Tevm Node](https://github.com/evmts/tevm-monorepo) allows you to extend the [EVM](https://ethereum.org/en/developers/docs/evm/) with custom [precompiled contracts](https://ethereum.org/en/developers/docs/evm/precompiles/) written in JavaScript. These precompiles can provide native functionality at specific addresses, similar to [Ethereum's built-in precompiles](https://www.evm.codes/precompiled).

### Using tevm/precompiles

The `tevm/precompiles` package provides utilities for creating type-safe precompiles from contract [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html):

```ts
import { createTevmNode, definePrecompile } from 'tevm'
import { createAddress } from 'tevm/address'
import { createContract } from 'tevm/contract'
import { parseAbi } from 'tevm/utils'
import { createImpersonatedTx } from 'tevm/tx'
import { EvmError, EvmErrorMessage } from 'tevm/evm'

// Create a basic precompile
const customPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function double(bytes) returns (bytes)']),
    address: '0x0000000000000000000000000000000000000123'
  }),
  call: async ({ data }) => {
    // Simple precompile that doubles each byte
    const input = Array.from(data)
    return {
      returnValue: new Uint8Array(input.map(byte => Number(byte) * 2)),
      executionGasUsed: 200n,
    }
  },
})

// Create node with precompile
const node = createTevmNode({
  customPrecompiles: [customPrecompile.precompile()],
})

// Create a transaction to interact with the precompile
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: customPrecompile.contract.address,
  data: '0x00',
  gasLimit: 21000n,
})

// Execute the transaction
const vm = await node.getVm()
const result = await vm.runTx({ tx })
```

### Basic Usage

Here's a simple example of creating and using a precompile:

```ts
import { createTevmNode, definePrecompile } from 'tevm'
import { createAddress } from 'tevm/address'
import { createContract } from 'tevm/contract'
import { parseAbi } from 'tevm/utils'
import { createImpersonatedTx } from 'tevm/tx'
import { EvmError, EvmErrorMessage } from 'tevm/evm'

const myPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes) returns (bytes)']),
    address: '0x0000000000000000000000000000000000000123'
  }),
  call: async ({ data, gasLimit }) => {
    const executionGasUsed = 200n
    if (gasLimit <= executionGasUsed) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    // Process input data
    const processedData = data
    return {
      returnValue: new Uint8Array([...processedData]),
      executionGasUsed,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile.precompile()],
})
```

### Precompile Interface

```ts
interface PrecompileInput {
  data: Uint8Array
  gasLimit: bigint
}

interface PrecompileOutput {
  returnValue: Uint8Array
  executionGasUsed: bigint
}

interface PrecompileContract {
  contract: Contract
  call: (input: PrecompileInput) => Promise<PrecompileOutput>
}
```

### Example Implementations

#### 1. State Access Precompile

```ts
const statePrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function store(bytes32,bytes32)']),
    address: '0x0000000000000000000000000000000000000124'
  }),
  call: async ({ data, gasLimit }) => {
    const key = data.slice(0, 32)
    const value = data.slice(32)
    const vm = await node.getVm()
    await vm.stateManager.putContractStorage(
      createAddress(statePrecompile.contract.address),
      hexToBytes(key),
      hexToBytes(value)
    )
    const executionGasUsed = 200n
    if (gasLimit <= executionGasUsed) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed,
    }
  },
})
```

#### 2. Gas Calculation Precompile

```ts
const gasPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processWithGas(bytes)']),
    address: '0x0000000000000000000000000000000000000125'
  }),
  call: async ({ data, gasLimit }) => {
    // Charge 100 gas per byte
    const gasUsed = BigInt(data.length * 100)
    if (gasUsed > gasLimit) {
      throw new Error('Out of gas')
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed: gasUsed,
    }
  },
})
```

#### 3. Error Handling Precompile

```ts
const errorPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process()']),
    address: '0x0000000000000000000000000000000000000126'
  }),
  call: async ({ data }) => {
    if (data.length === 0) {
      throw new Error('Empty input not allowed')
    }
    return {
      returnValue: new Uint8Array(),
      executionGasUsed: 200n,
    }
  },
})
```

#### 4. Multiple Precompiles

```ts
const precompileA = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processA() returns (bytes)']),
    address: '0x0000000000000000000000000000000000000127'
  }),
  call: async () => ({
    returnValue: new Uint8Array([1]),
    executionGasUsed: 200n,
  }),
})

const precompileB = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function processB() returns (bytes)']),
    address: '0x0000000000000000000000000000000000000128'
  }),
  call: async () => ({
    returnValue: new Uint8Array([2]),
    executionGasUsed: 200n,
  }),
})

const node = createTevmNode({
  customPrecompiles: [precompileA.precompile(), precompileB.precompile()],
})
```

### Best Practices

1. **Gas Calculation**:
   * Always calculate gas based on input size or operations performed
   * Check against provided gas limit
   * Return accurate gas usage and proper error types

```ts
const precompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes)']),
    address: createAddress('0x0000000000000000000000000000000000000123')
  }),
  call: async ({ data, gasLimit }) => {
    const gasPerByte = 100n
    const gasUsed = BigInt(data.length) * gasPerByte
    if (gasUsed > gasLimit) {
      return {
        returnValue: new Uint8Array(),
        exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
        executionGasUsed: gasLimit,
      }
    }
    return {
      returnValue: processData(data),
      executionGasUsed: gasUsed,
    }
  },
})
```

2. **Error Handling**:
   * Use proper EvmError types for EVM-specific errors
   * Check input validity
   * Handle gas limits properly

```ts
const precompile = definePrecompile({
  contract: createContract({
    abi: parseAbi(['function process(bytes)']),
    address: createAddress('0x0000000000000000000000000000000000000123')
  }),
  call: async ({ data, gasLimit }) => {
    try {
      if (data.length === 0) {
        throw new Error('Empty input not allowed')
      }
      const executionGasUsed = 200n
      if (gasLimit <= executionGasUsed) {
        return {
          returnValue: new Uint8Array(),
          exceptionError: new EvmError(EvmErrorMessage.OUT_OF_GAS),
          executionGasUsed: gasLimit,
        }
      }
      // Process data
      return {
        returnValue: processData(data),
        executionGasUsed,
      }
    } catch (error) {
      throw new Error(`Precompile error: ${error.message}`)
    }
  },
})
```

3. **State Management**:
   * Use VM state manager for persistent storage
   * Handle state access errors
   * Clean up resources when needed

### Related Topics

* [Contract Utilities](../api/contracts)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)
* [EVM Opcodes Reference](https://www.evm.codes/)
* [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
* [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)


## Performance & Profiler

Tevm Node includes a built-in performance profiler that helps you analyze EVM execution, identify bottlenecks, and optimize your smart contracts.

### Enabling the Profiler

Enable profiling when creating your node:

```ts
import { createTevmNode } from 'tevm'

const node = createTevmNode({
  profiler: {
    enabled: true,
    // Optional: Configure profiling options
    includeOpcodes: true,
    includePrecompiles: true,
  },
})
```

### Collecting Performance Data

```ts
const vm = await node.getVm()

// Execute some transactions
await vm.runTx({ /* ... */ })

// Get performance logs
const logs = vm.evm.getPerformanceLogs()

// Clear logs when done
vm.evm.clearPerformanceLogs()
```

### Log Types

The profiler collects various types of performance data:

```ts
interface PerformanceLog {
  type: 'opcode' | 'precompile' | 'call' | 'create'
  startTime: number
  endTime: number
  executionTime: number
  gasUsed?: bigint
  // Additional data based on type
}

interface OpcodeLog extends PerformanceLog {
  type: 'opcode'
  opcode: string
  pc: number
}

interface PrecompileLog extends PerformanceLog {
  type: 'precompile'
  address: string
  name: string
}
```

### Analyzing Performance

#### 1. Opcode Analysis

```ts
// Group by opcode
const opcodeStats = logs
  .filter(log => log.type === 'opcode')
  .reduce((acc, log) => {
    const key = log.opcode
    acc[key] = acc[key] || { count: 0, totalTime: 0, totalGas: 0n }
    acc[key].count++
    acc[key].totalTime += log.executionTime
    acc[key].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Find expensive operations
const expensiveOps = Object.entries(opcodeStats)
  .sort(([, a], [, b]) => b.totalTime - a.totalTime)
  .slice(0, 10)

console.log('Most expensive operations:', expensiveOps)
```

#### 2. Call Tree Analysis

```ts
// Analyze call depth and patterns
const callTree = logs
  .filter(log => log.type === 'call')
  .map(log => ({
    from: log.from,
    to: log.to,
    value: log.value,
    executionTime: log.executionTime,
    gasUsed: log.gasUsed,
  }))

console.log('Call tree:', callTree)
```

#### 3. Gas Usage Patterns

```ts
// Track gas usage over time
const gasTimeline = logs
  .filter(log => log.gasUsed !== undefined)
  .map(log => ({
    timestamp: log.startTime,
    gasUsed: log.gasUsed,
    type: log.type,
  }))

// Calculate gas efficiency
const gasEfficiency = gasTimeline.reduce((acc, log) => {
  acc.totalGas += log.gasUsed ?? 0n
  acc.totalTime += log.executionTime
  return acc
}, { totalGas: 0n, totalTime: 0 })
```

### Use Cases

#### 1. Contract Optimization

```ts
// Deploy and profile contract
const vm = await node.getVm()
await vm.runTx({ tx: deployTx })

// Clear previous logs
vm.evm.clearPerformanceLogs()

// Profile specific function
await vm.runTx({ tx: functionCallTx })
const logs = vm.evm.getPerformanceLogs()

// Analyze performance
const functionProfile = analyzeLogs(logs)
console.log('Function performance:', {
  totalTime: functionProfile.executionTime,
  gasUsed: functionProfile.gasUsed,
  hotspots: functionProfile.hotspots,
})
```

#### 2. Comparative Analysis

```ts
async function compareImplementations(implementations: string[]) {
  const results = []
  const vm = await node.getVm()

  for (const impl of implementations) {
    vm.evm.clearPerformanceLogs()
    await vm.runTx({ tx: createCallTx(impl) })
    const logs = vm.evm.getPerformanceLogs()
    results.push(analyzePerformance(logs))
  }

  return compareResults(results)
}
```

#### 3. Gas Optimization

```ts
// Track gas usage by contract
const contractGasUsage = logs
  .filter(log => log.type === 'call')
  .reduce((acc, log) => {
    const contract = log.to
    acc[contract] = acc[contract] || { calls: 0, totalGas: 0n }
    acc[contract].calls++
    acc[contract].totalGas += log.gasUsed ?? 0n
    return acc
  }, {})

// Identify gas-intensive contracts
const gasHotspots = Object.entries(contractGasUsage)
  .sort(([, a], [, b]) => Number(b.totalGas - a.totalGas))
```

### Best Practices

1. **Targeted Profiling**:
   ```ts
   // Clear logs before specific operations
   vm.evm.clearPerformanceLogs()
   // Run the operation you want to profile
   await vm.runTx({ /* ... */ })
   // Analyze just that operation
   const logs = vm.evm.getPerformanceLogs()
   ```

2. **Memory Management**:
   * Clear logs periodically
   * Profile specific operations rather than entire sessions
   * Export and analyze large datasets externally

3. **Comparative Analysis**:
   ```ts
   // Compare before/after optimization
   const beforeLogs = await profileOperation(originalCode)
   const afterLogs = await profileOperation(optimizedCode)
   const improvement = compareProfiles(beforeLogs, afterLogs)
   ```

4. **Production Considerations**:
   * Disable profiler in production
   * Use sampling for long-running operations
   * Consider the overhead of profiling itself

### Related Topics

* [VM & Submodules](../api/vm-and-submodules)
* [Gas Estimation](../api/methods)
* [Transaction Pool](./txpool)


## Receipts & Logs

Tevm Node provides robust support for managing transaction receipts and event logs through the ReceiptsManager module and filter system.

### Receipt Management

The ReceiptsManager maintains an index of all transaction receipts and their associated logs.

```ts
import { createTevmNode } from 'tevm'
import { createImpersonatedTx } from 'tevm/tx'
import { runTx } from 'tevm/vm'
import { createAddress, hexToBytes } from 'tevm/utils'

const node = createTevmNode()
const receiptsManager = await node.getReceiptsManager()

// Execute a transaction and get receipt
const vm = await node.getVm()
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: createAddress('0x2345678901234567890123456789012345678901'),
  value: 1000000000000000000n,
  gasLimit: 21000n,
})

const result = await runTx(vm)({ tx })
const receiptResult = await receiptsManager.getReceiptByTxHash(tx.hash())

if (receiptResult) {
  const [receipt, blockHash, txIndex, logIndex] = receiptResult
  // Access receipt data
  console.log({
    status: 'status' in receipt ? receipt.status : undefined,
    gasUsed: receipt.cumulativeBlockGasUsed,
    logs: receipt.logs
  })
}
```

#### Receipt Types

Tevm supports different receipt types based on the Ethereum hardfork:

```ts
interface PreByzantiumReceipt {
  stateRoot: Uint8Array
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface PostByzantiumReceipt {
  status: number // 1 for success, 0 for failure
  cumulativeBlockGasUsed: bigint
  logs: Log[]
}

interface EIP4844Receipt extends PostByzantiumReceipt {
  blobGasUsed: bigint
  blobGasPrice: bigint
}
```

### Event Logs

#### Contract Deployment and Event Emission

Here's how to deploy a contract and capture its events:

```ts
// Deploy contract
const deployTx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  data: CONTRACT_BYTECODE,
  gasLimit: 1000000n,
})

const vm = await node.getVm()
const deployResult = await runTx(vm)({ tx: deployTx })
const contractAddress = deployResult.createdAddress
if (!contractAddress) throw new Error('Contract deployment failed')

// Interact with contract to emit events
const interactTx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234567890123456789012345678901234567890'),
  to: contractAddress,
  data: EMIT_EVENT_SELECTOR, // Function selector that emits events
  gasLimit: 100000n,
})

await runTx(vm)({ tx: interactTx })
```

#### Querying Logs

The ReceiptsManager provides flexible log querying with multiple filter options:

```ts
// Get blocks for filtering
const fromBlock = await vm.blockchain.getBlockByTag('earliest')
const toBlock = await vm.blockchain.getBlockByTag('latest')

// Filter by contract address
const addressLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  [contractAddress.toBytes()],
  undefined
)

// Filter by event topic
const eventTopic = hexToBytes('0x000000000000000000000000000000000000000000000000000000000000abcd')
const topicLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  undefined,
  [eventTopic]
)

// Filter by both address and topic
const combinedLogs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  [contractAddress.toBytes()],
  [eventTopic]
)
```

#### Error Handling

The ReceiptsManager includes robust error handling:

```ts
// Handle non-existent receipts
const nonExistentHash = hexToBytes('0x1234567890123456789012345678901234567890123456789012345678901234')
const receipt = await receiptsManager.getReceiptByTxHash(nonExistentHash)
if (receipt === null) {
  console.log('Receipt not found')
}

// Handle invalid log filters
const invalidAddress = hexToBytes('0x0000')
const logs = await receiptsManager.getLogs(fromBlock, toBlock, [invalidAddress], undefined)
if (logs.length === 0) {
  console.log('No logs found for invalid address')
}
```

### Performance Considerations

The ReceiptsManager includes built-in limits to prevent excessive resource usage:

```ts
// Log query limits
const GET_LOGS_LIMIT = 10000 // Maximum number of logs
const GET_LOGS_LIMIT_MEGABYTES = 150 // Maximum response size
const GET_LOGS_BLOCK_RANGE_LIMIT = 2500 // Maximum block range
```

#### Best Practices

1. **Efficient Log Queries**:
   * Use specific address and topic filters
   * Limit block ranges for large queries
   * Handle null results appropriately

2. **Receipt Storage**:
   * Always check for null/undefined results
   * Handle receipt pruning gracefully
   * Verify contract deployment success

3. **Type Safety**:
   ```ts
   // Ensure contract deployment success
   const contractAddress = deployResult.createdAddress
   if (!contractAddress) throw new Error('Contract deployment failed')

   // Handle receipt types
   if (receiptResult) {
     const [receipt] = receiptResult
     if ('status' in receipt) {
       console.log(`Transaction ${receipt.status === 1 ? 'succeeded' : 'failed'}`)
     }
   }
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Transaction Pool](./txpool)


## Transaction Pool

The Transaction Pool (TxPool) is a crucial component that manages pending transactions before they're included in blocks. It handles transaction ordering, replacement, validation, and lifecycle management.

### Quick Start

```ts
import { createTevmNode } from 'tevm'
import { createAddress } from 'tevm/address'
import { createImpersonatedTx } from 'tevm/tx'

// Initialize node and get txpool
const node = createTevmNode()
const txPool = await node.getTxPool()

// Create and add a transaction
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress('0x1234...'),
  to: createAddress('0x2345...'),
  value: 1000000000000000000n, // 1 ETH
  gasLimit: 21000n,
  maxFeePerGas: 20000000000n,
  maxPriorityFeePerGas: 20000000000n,
  nonce: 0n,
})

await txPool.addUnverified(tx)
```

### Key Features

* 🔍 **Transaction Validation** - Comprehensive validation including nonce, balance, and gas checks
* 🔄 **Transaction Replacement** - Replace pending transactions with higher gas price versions
* 📊 **Nonce Ordering** - Maintains correct transaction sequence per account
* 🧹 **Automatic Pruning** - Removes old transactions to prevent memory bloat
* ⚡ **Performance Optimized** - Efficient handling of large transaction volumes

### Core Concepts

#### Pool Limits

The TxPool enforces several limits to ensure stable operation:

```ts
const LIMITS = {
  MAX_POOL_SIZE: 5000,           // Maximum total transactions
  MAX_TXS_PER_ACCOUNT: 100,      // Maximum per account
  MIN_GAS_PRICE: 100000000n,     // 0.1 GWei minimum
  TX_MAX_DATA_SIZE: 128 * 1024,  // 128KB max transaction size
}
```

#### Transaction Lifecycle

1. **Addition** - Transactions enter the pool via `add()` or `addUnverified()`
2. **Validation** - Optional checks for nonce, balance, and gas parameters
3. **Storage** - Valid transactions are stored and ordered by nonce
4. **Pruning** - Old transactions are removed after `POOLED_STORAGE_TIME_LIMIT` (20 minutes)

### Detailed Usage

#### Adding Transactions

Two methods for adding transactions, each with different validation levels:

```ts
// Method 1: With full validation
try {
  await txPool.add(tx)
} catch (error) {
  if (error.message.includes('insufficient balance')) {
    console.error('Account has insufficient funds')
  }
}

// Method 2: Without validation (faster)
await txPool.addUnverified(tx)
```

#### Transaction Replacement

Replace a pending transaction by submitting a new one with the same nonce and higher gas price:

```ts
const originalTx = createImpersonatedTx({
  // ... base transaction params ...
  maxFeePerGas: 20000000000n,
  nonce: 0n,
})

const replacementTx = createImpersonatedTx({
  // ... same params as original ...
  maxFeePerGas: 30000000000n, // At least 10% higher
  nonce: 0n, // Same nonce as original
})

await txPool.addUnverified(originalTx)
await txPool.addUnverified(replacementTx) // Replaces originalTx
```

> **Note**: Replacement transactions must increase gas price by at least `MIN_GAS_PRICE_BUMP_PERCENT` (10%)

#### Querying Transactions

```ts
// Get transactions by sender
const senderTxs = await txPool.getBySenderAddress(senderAddress)

// Get transactions by hash
const txHashes = [hash1, hash2]
const specificTxs = txPool.getByHash(txHashes)

// Get ordered transactions for mining
const orderedTxs = await txPool.txsByPriceAndNonce({
  baseFee: currentBaseFee,
  allowedBlobs: 6, // For EIP-4844
})
```

#### Block Processing

When new blocks are added, update the pool:

```ts
import { mineHandler } from 'tevm/actions'

// Mine new blocks
await mineHandler(node)()

// Remove included transactions
txPool.removeNewBlockTxs(newBlocks)
```

### Advanced Features

#### Pool Management

```ts
// Start transaction processing
txPool.start()

// Stop processing (but keep transactions)
txPool.stop()

// Clear all transactions
txPool.close()

// Manual cleanup of old transactions
txPool.cleanup()
```

#### Transaction Types

The pool supports all Ethereum transaction types:

* Legacy Transactions
* EIP-2930 (Access Lists)
* EIP-1559 (Fee Market)
* EIP-4844 (Blob Transactions)
* Tevm Impersonated Transactions

### Best Practices

#### 1. Transaction Creation

Always use `createImpersonatedTx` with proper types:

```ts
const tx = createImpersonatedTx({
  impersonatedAddress: createAddress(address),
  to: createAddress(recipient),
  value: parseEther('1'), // Use helper functions for values
  gasLimit: 21000n,
  maxFeePerGas: gweiToWei('20'),
  maxPriorityFeePerGas: gweiToWei('2'),
  nonce: 0n,
})
```

#### 2. Error Handling

Implement comprehensive error handling:

```ts
try {
  await txPool.add(tx)
} catch (error) {
  switch (true) {
    case error.message.includes('insufficient balance'):
      // Handle balance error
      break
    case error.message.includes('nonce too low'):
      // Handle nonce error
      break
    case error.message.includes('gas price too low'):
      // Handle gas price error
      break
    default:
      // Handle unknown errors
  }
}
```

#### 3. Performance Optimization

* Use `addUnverified` for bulk operations
* Implement proper cleanup cycles
* Monitor pool size and transaction age

#### 4. Memory Management

```ts
// Regular cleanup cycle
setInterval(() => {
  txPool.cleanup()
}, 5 * 60 * 1000) // Every 5 minutes

// Monitor pool size
const poolSize = txPool.txsInPool
if (poolSize > MAX_POOL_SIZE * 0.8) {
  console.warn('Pool approaching capacity')
}
```

### API Reference

#### TxPool Class

```ts
class TxPool {
  constructor(options: { vm: Vm })
  async add(tx: Transaction): Promise<void>
  async addUnverified(tx: Transaction): Promise<void>
  async getBySenderAddress(address: Address): Promise<TxPoolObject[]>
  getByHash(hashes: Uint8Array[]): Transaction[]
  removeByHash(hash: string): void
  removeNewBlockTxs(blocks: Block[]): void
  start(): boolean
  stop(): boolean
  cleanup(): void
  close(): void
}
```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [VM & Submodules](../api/vm-and-submodules)
* [Receipts & Logs](./receipts-and-logs)


## Account Management

Tevm provides two key actions for managing account state: `getAccountHandler` and `setAccountHandler`.

### getAccountHandler

The `getAccountHandler` action allows you to retrieve the current state of an account.

#### Parameters

```ts
type GetAccountParams = {
  // Required address of the account
  address: Address
  // Optional block tag to query state from
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to return storage (can be expensive)
  returnStorage?: boolean
}
```

#### Return Type

```ts
type GetAccountResult = {
  // Address of the account
  address: Address
  // Current nonce
  nonce: bigint
  // Balance in wei
  balance: bigint
  // Deployed bytecode (if contract)
  deployedBytecode: Hex
  // Storage root
  storageRoot: Hex
  // Code hash
  codeHash: Hex
  // Whether this is a contract
  isContract: boolean
  // Whether account is empty
  isEmpty: boolean
  // Storage (if returnStorage=true)
  storage?: { [key: Hex]: Hex }
  // Any errors that occurred
  errors?: TevmGetAccountError[]
}
```

#### Example

```ts
import { createTevmNode } from 'tevm'
import { getAccountHandler } from 'tevm/actions'

const node = createTevmNode()

const account = await getAccountHandler(node)({
  address: '0x...',
  blockTag: 'latest',
  returnStorage: true
})

console.log('Balance:', account.balance)
console.log('Nonce:', account.nonce)
if (account.isContract) {
  console.log('Code:', account.deployedBytecode)
  console.log('Storage:', account.storage)
}
```

### setAccountHandler

The `setAccountHandler` action allows you to modify account state directly.

#### Parameters

```ts
type SetAccountParams = {
  // Required address to modify
  address: Address
  // New nonce value
  nonce?: bigint
  // New balance in wei
  balance?: bigint
  // New deployed bytecode
  deployedBytecode?: Hex
  // New storage values
  state?: { [key: Hex]: Hex }
}
```

#### Return Type

```ts
type SetAccountResult = {
  // Any errors that occurred
  errors?: TevmSetAccountError[]
}
```

#### Examples

##### 1. Setting Account Balance

```ts
import { setAccountHandler } from 'tevm/actions'

await setAccountHandler(node)({
  address: '0x...',
  balance: parseEther('100')
})
```

##### 2. Deploying Contract Code

```ts
await setAccountHandler(node)({
  address: contractAddress,
  deployedBytecode: '0x...',
  state: {
    // Initial storage values
    '0x0000...': '0x0000...'
  }
})
```

##### 3. Modifying Multiple Properties

```ts
await setAccountHandler(node)({
  address: '0x...',
  nonce: 5n,
  balance: parseEther('10'),
  state: {
    [slot1]: value1,
    [slot2]: value2
  }
})
```

### Best Practices

1. **Storage Management**:
   ```ts
   // Avoid fetching storage unless needed
   const account = await getAccountHandler(node)({
     address: '0x...',
     returnStorage: false // default
   })
   ```

2. **State Consistency**:
   ```ts
   // Check account exists before modifying
   const account = await getAccountHandler(node)({ address })
   if (!account.isEmpty) {
     await setAccountHandler(node)({
       address,
       balance: account.balance + amount
     })
   }
   ```

3. **Error Handling**:
   ```ts
   const result = await setAccountHandler(node)({
     address: '0x...',
     balance: newBalance,
     throwOnFail: false
   })

   if (result.errors) {
     console.error('Failed to set account:', result.errors)
   }
   ```

### Related Topics

* [State Management](../core/managing-state)
* [Call API](./tevm-call)
* [JSON-RPC Support](./json-rpc)


## @tevm/actions

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/actions/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/actions/docs) folder.

The `@tevm/actions` package provides a comprehensive set of actions for interacting with the Tevm client. It includes both standard Ethereum JSON-RPC methods and Tevm-specific functionality.

### Installation

```bash
npm install @tevm/actions
```

### Main Categories

#### Base Actions

* **Call**: Execute EVM calls
  * `CallHandler`: Execute a call against the VM
  * `BaseCallParams`: Common parameters for call operations
  * `CallResult`: Result of call execution

* **Contract**: Smart contract interactions
  * `ContractHandler`: Execute contract calls with type safety
  * `ContractParams`: Parameters for contract calls
  * `ContractResult`: Result of contract execution

* **Deploy**: Contract deployment
  * `DeployHandler`: Deploy contracts to the VM
  * `DeployParams`: Parameters for contract deployment
  * `DeployResult`: Result of deployment

* **State Management**:
  * `DumpStateHandler`: Dump current VM state
  * `LoadStateHandler`: Load a previously dumped state
  * `GetAccountHandler`: Get account state
  * `SetAccountHandler`: Set account state

#### Ethereum JSON-RPC Actions

Standard Ethereum JSON-RPC methods:

##### Account & Network

* `eth_accounts`: List available accounts
* `eth_chainId`: Get current chain ID
* `eth_coinbase`: Get coinbase address
* `eth_gasPrice`: Get current gas price
* `eth_blockNumber`: Get current block number

##### State Reading

* `eth_getBalance`: Get account balance
* `eth_getCode`: Get contract code
* `eth_getStorageAt`: Get storage at position
* `eth_call`: Execute call without state changes

##### Block Operations

* `eth_getBlockByHash`: Get block by hash
* `eth_getBlockByNumber`: Get block by number
* `eth_getBlockTransactionCountByHash`: Get block transaction count by hash
* `eth_getBlockTransactionCountByNumber`: Get block transaction count by number

##### Transaction Operations

* `eth_getTransactionByHash`: Get transaction by hash
* `eth_getTransactionByBlockHashAndIndex`: Get transaction by block hash and index
* `eth_getTransactionByBlockNumberAndIndex`: Get transaction by block number and index
* `eth_estimateGas`: Estimate gas usage

##### Logs & Filters

* `eth_getLogs`: Get event logs
* `eth_getFilterChanges`: Get filter changes
* `eth_getFilterLogs`: Get filter logs

#### Anvil (Testing & Development) Actions

Anvil-compatible actions for testing and development:

##### State Manipulation

* `anvil_setBalance`: Set account balance
* `anvil_setCode`: Set contract code
* `anvil_setNonce`: Set account nonce
* `anvil_setStorageAt`: Set storage at position
* `anvil_setChainId`: Set chain ID
* `anvil_setCoinbase`: Set coinbase address

##### Account Management

* `anvil_impersonateAccount`: Impersonate an account
* `anvil_stopImpersonatingAccount`: Stop impersonating account

##### Transaction Management

* `anvil_dropTransaction`: Remove transaction from pool
* `anvil_mine`: Mine blocks
* `anvil_automine`: Get/set automine status

##### State Management

* `anvil_dumpState`: Dump current state
* `anvil_loadState`: Load state
* `anvil_reset`: Reset to initial state

#### Debug Actions

Debugging functionality:

* `debug_traceCall`: Trace a call execution
* `debug_traceTransaction`: Trace a transaction execution

### Usage Example

```typescript
import { createTevmNode } from 'tevm/node'
import {
  callHandler,
  contractHandler,
  deployHandler,
  ethCallHandler
} from '@tevm/actions'

// Create base client
const client = createTevmNode()

// Initialize handlers
const call = callHandler(client)
const contract = contractHandler(client)
const deploy = deployHandler(client)
const ethCall = ethCallHandler(client)

// Execute a call
const callResult = await call({
  to: '0x123...',
  data: '0x456...',
  value: 1000n
})

// Execute a contract call
const contractResult = await contract({
  to: '0x123...',
  abi: [...],
  function: 'transfer',
  args: ['0x456...', 1000n]
})

// Deploy a contract
const deployResult = await deploy({
  bytecode: '0x...',
  abi: [...],
  args: ['constructor arg']
})

// Standard eth_call
const ethCallResult = await ethCall({
  to: '0x123...',
  data: '0x456...'
})
```

### Error Handling

The package includes several error types:

* `BlobGasLimitExceededError`: When blob gas limit is exceeded
* `MissingAccountError`: When an account doesn't exist
* `NoForkUrlSetError`: When fork URL is required but not set

All actions support a `throwOnFail` parameter to control error handling:

```typescript
const result = await call({
  to: '0x123...',
  throwOnFail: false // Return errors in result instead of throwing
})
```

### See Also

* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [Anvil Documentation](https://book.getfoundry.sh/reference/anvil/)
* [Tevm Documentation](https://tevm.sh/)


## Block

The `@tevm/block` package provides functionality for working with Ethereum blocks. It includes classes and utilities for handling block headers, block data, and block-related operations.

### Block Class

The main class for working with Ethereum blocks.

#### Constructor

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

// Create a new block
const block = new Block({
  common: createCommon({ ...mainnet })
})
```

#### Static Methods

##### `fromBlockData(blockData: BlockData, opts: BlockOptions): Block`

Creates a block from block data dictionary:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'
import { EthjsAddress } from '@tevm/utils'

const common = createCommon({ ...mainnet })

const blockData = {
  header: {
    parentHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    uncleHash: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
    coinbase: EthjsAddress.fromString('0x0000000000000000000000000000000000000000'),
    stateRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
    transactionsTrie: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    receiptTrie: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
    difficulty: 0n,
    number: 0n,
    gasLimit: 30000000n,
    gasUsed: 0n,
    timestamp: BigInt(Math.floor(Date.now() / 1000)),
    extraData: '0x',
    mixHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    nonce: '0x0000000000000000',
    baseFeePerGas: 1000000000n
  }
}

const block = Block.fromBlockData(blockData, { common })
```

##### `fromRLPSerializedBlock(serialized: Uint8Array, opts: BlockOptions): Block`

Creates a block from RLP-serialized block data:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const serializedBlock = new Uint8Array([/* ... */])
const block = Block.fromRLPSerializedBlock(serializedBlock, { common })
```

##### `fromValuesArray(values: BlockBytes, opts: BlockOptions): Block`

Creates a block from an array of Bytes values:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const values = [/* ... */] // Array of block values
const block = Block.fromValuesArray(values, { common })
```

#### Instance Methods

##### `hash(): Uint8Array`

Returns the hash of the block:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const block = new Block({ common })
const hash = block.hash()
```

##### `serialize(): Uint8Array`

Returns the RLP encoding of the block:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const block = new Block({ common })
const serialized = block.serialize()
```

##### `toJSON(): JsonBlock`

Converts the block to a JSON representation:

```typescript
import { Block } from '@tevm/block'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
const block = new Block({ common })
const json = block.toJSON()
```

### Types

#### HeaderData

```typescript
interface HeaderData {
  parentHash?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  uncleHash?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  coinbase?: string | Uint8Array | Address
  stateRoot?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  transactionsTrie?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  receiptTrie?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  logsBloom?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  difficulty?: string | number | bigint | Uint8Array
  number?: string | number | bigint | Uint8Array
  gasLimit?: string | number | bigint | Uint8Array
  gasUsed?: string | number | bigint | Uint8Array
  timestamp?: string | number | bigint | Uint8Array
  extraData?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  mixHash?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  nonce?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  baseFeePerGas?: string | number | bigint | Uint8Array
  withdrawalsRoot?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  blobGasUsed?: string | number | bigint | Uint8Array
  excessBlobGas?: string | number | bigint | Uint8Array
  parentBeaconBlockRoot?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
  requestsRoot?: string | number | bigint | Uint8Array | number[] | TransformabletoBytes
}
```

### See Also

* [What is Tevm Node?](../introduction/what-is-tevm-node)
* [Creating a Node](../core/create-tevm-node)
* [Common](./common)


## Blockchain Package

The `@tevm/blockchain` package provides a custom implementation of the Ethereum blockchain, offering functionality for managing blocks, handling chain state, and interacting with the blockchain.

### Main Exports

#### Chain Interface

The main interface for interacting with the blockchain.

```typescript
type Chain = {
  // Core Methods
  putBlock(block: Block): Promise<void>
  getBlock(blockId: Uint8Array | number | bigint): Promise<Block>
  delBlock(blockHash: Uint8Array): Promise<void>
  getBlockByTag(blockTag: Hex | Uint8Array | number | bigint | BlockTag): Promise<Block>

  // Iterator Methods
  getIteratorHead(name?: string): Promise<Block>
  setIteratorHead(tag: string, headHash: Uint8Array): Promise<void>
  iterator(name: string, onBlock: OnBlock, maxBlocks?: number, releaseLockOnCallback?: boolean): Promise<number>

  // Chain State
  getCanonicalHeadBlock(): Promise<Block>
  validateHeader(header: BlockHeader, height?: bigint): Promise<void>
  getTotalDifficulty?(hash: Uint8Array, number?: bigint): Promise<bigint>

  // Utilities
  shallowCopy(): Chain
  deepCopy(): Promise<Chain>

  // Optional Events
  events?: AsyncEventEmitter<BlockchainEvents>
}
```

#### Creating a Chain

The main factory function to create a new blockchain instance:

```typescript
async function createChain(options: ChainOptions): Promise<Chain>
```

##### ChainOptions

```typescript
type ChainOptions = {
  // Logging configuration
  loggingLevel?: LogOptions['level']

  // Chain configuration
  common: Common
  genesisBlock?: Block
  genesisStateRoot?: Uint8Array

  // Forking configuration
  fork?: {
    transport: { request: EIP1193RequestFn }
    blockTag?: BlockTag | bigint | `0x${string}`
  }
}
```

### Core Functionality

#### Block Management

##### Adding Blocks

```typescript
await chain.putBlock(block)
```

Adds a new block to the blockchain. The block must match the chain's chainId.

##### Retrieving Blocks

```typescript
// By hash or number
const block = await chain.getBlock(blockId)

// By tag (latest, earliest, pending, etc.)
const block = await chain.getBlockByTag(blockTag)

// Get latest block
const head = await chain.getCanonicalHeadBlock()
```

##### Deleting Blocks

```typescript
await chain.delBlock(blockHash)
```

Deletes a block and all its child blocks from the chain.

#### Chain State

##### Header Validation

```typescript
await chain.validateHeader(header, height?)
```

Validates a block header against the chain's rules.

##### Iterator Management

```typescript
// Set iterator head
await chain.setIteratorHead(tag, headHash)

// Get iterator head
const head = await chain.getIteratorHead(tag)

// Iterate through blocks
await chain.iterator(name, (block, reorg) => {
  // Process block
}, maxBlocks)
```

#### Chain Copying

```typescript
// Shallow copy (shares state)
const shallowCopy = chain.shallowCopy()

// Deep copy (independent state)
const deepCopy = await chain.deepCopy()
```

### Events

The blockchain can optionally emit events for various operations:

```typescript
chain.events?.on('block', (block) => {
  // Handle new block
})
```

### Error Handling

The blockchain package throws specific errors for various conditions:

* `UnknownBlockError`: When a requested block cannot be found
* `InvalidBlockError`: When a block fails validation
* `InternalError`: For internal blockchain errors

### Usage Example

```typescript
import { createChain } from '@tevm/blockchain'
import { Common } from '@tevm/common'

// Create a new chain
const chain = await createChain({
  common: new Common({ chain: 'mainnet' }),
  loggingLevel: 'info'
})

// Add a block
await chain.putBlock(block)

// Get latest block
const latestBlock = await chain.getCanonicalHeadBlock()

// Fork from existing chain
const forkedChain = await createChain({
  common: new Common({ chain: 'mainnet' }),
  fork: {
    transport: { request: myJsonRpcProvider },
    blockTag: 'latest'
  }
})
```


## Common Package

The `@tevm/common` package provides chain-specific configuration and utilities for Tevm clients. It wraps both Viem chain configurations and EthereumJS Common functionality to provide a unified interface for chain parameters, hardforks, and EIPs.

### Main Exports

#### Common Type

The main type representing chain-specific configuration:

```typescript
type Common = {
  // Chain Identification
  id: number
  name: string
  nativeCurrency: ChainNativeCurrency

  // Chain Configuration
  rpcUrls: {
    default: ChainRpcUrls
    [key: string]: ChainRpcUrls
  }
  blockExplorers?: {
    default: ChainBlockExplorer
    [key: string]: ChainBlockExplorer
  }

  // Contract Information
  contracts?: {
    ensRegistry?: ChainContract
    ensUniversalResolver?: ChainContract
    multicall3?: ChainContract
  }

  // Chain Properties
  testnet?: boolean
  sourceId?: number

  // EthereumJS Common Instance
  ethjsCommon: EthjsCommon

  // Utilities
  copy(): Common
}
```

#### Creating a Common Instance

The main factory function to create a Common instance:

```typescript
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({ ...mainnet })
```

##### CommonOptions

```typescript
type CommonOptions = ViemChain & {
  // Hardfork configuration (default: 'cancun')
  hardfork?: Hardfork

  // EIPs to enable (default: [1559, 4895])
  eips?: ReadonlyArray<number>

  // Logging configuration (default: 'warn')
  loggingLevel?: LogOptions['level']

  // Custom crypto implementations
  customCrypto?: CustomCrypto
}
```

#### Hardfork Support

The package supports various Ethereum hardforks:

```typescript
type Hardfork =
  | 'chainstart'
  | 'homestead'
  | 'dao'
  | 'tangerineWhistle'
  | 'spuriousDragon'
  | 'byzantium'
  | 'constantinople'
  | 'petersburg'
  | 'istanbul'
  | 'muirGlacier'
  | 'berlin'
  | 'london'
  | 'arrowGlacier'
  | 'grayGlacier'
  | 'mergeForkIdTransition'
  | 'paris'
  | 'shanghai'
  | 'cancun'
  | 'prague'
  | 'osaka'
```

#### Preset Chains

The package uses Viem's chain configurations. Import them directly from viem:

```typescript
import {
  mainnet,    // Ethereum Mainnet
  goerli,     // Goerli Testnet
  sepolia,    // Sepolia Testnet
  optimism,   // Optimism
  arbitrum,   // Arbitrum
  polygon,    // Polygon
  // ... many more
} from 'viem/chains'
```

### Usage Examples

#### Basic Usage

```typescript
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'
import { createMemoryClient } from 'tevm'

// Using a preset chain
const client = createMemoryClient({
  common: createCommon({ ...mainnet })
})

// Creating a custom chain configuration
const customCommon = createCommon({
  ...mainnet,
  hardfork: 'london',
  eips: [1559, 4895],
  loggingLevel: 'debug'
})
```

#### Custom Chain Configuration

```typescript
import { createCommon } from '@tevm/common'

const myChainCommon = createCommon({
  id: 1234,
  name: 'My Custom Chain',
  nativeCurrency: {
    name: 'My Token',
    symbol: 'MTK',
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ['https://my-chain-rpc.example.com']
    }
  },
  hardfork: 'london',
  eips: [1559]
})
```

#### Using with EthereumJS

```typescript
import { VM } from '@ethereumjs/vm'
import { createCommon } from '@tevm/common'
import { mainnet } from 'viem/chains'

const common = createCommon({
  ...mainnet
})

const vm = new VM({
  common: common.ethjsCommon
})
```

#### State Management

The package also includes interfaces for EVM state management:

```typescript
interface EvmStateManagerInterface {
  getAccount(address: Address): Promise<Account | undefined>
  putAccount(address: Address, account?: Account): Promise<void>
  deleteAccount(address: Address): Promise<void>
  getContractCode(address: Address): Promise<Uint8Array>
  putContractCode(address: Address, value: Uint8Array): Promise<void>
  getContractStorage(address: Address, key: Uint8Array): Promise<Uint8Array>
  putContractStorage(address: Address, key: Uint8Array, value: Uint8Array): Promise<void>
  // ... additional state management methods
}
```

### Error Handling

The package uses the `@tevm/errors` package for error handling. Common errors include:

* `InvalidParamsError`: Thrown when invalid parameters are provided to `createCommon`
* Chain-specific validation errors from EthereumJS Common

### Custom Cryptography

The package supports custom cryptographic implementations through the `CustomCrypto` interface:

```typescript
interface CustomCrypto {
  keccak256?(msg: Uint8Array): Uint8Array
  ecrecover?(msgHash: Uint8Array, v: bigint, r: Uint8Array, s: Uint8Array, chainId?: bigint): Uint8Array
  ecsign?(msg: Uint8Array, pk: Uint8Array, chainId?: bigint): ECDSASignature
  ecdsaSign?(msg: Uint8Array, pk: Uint8Array): { signature: Uint8Array; recid: number }
  kzg?: Kzg
  // ... other crypto methods
}
```

### See Also

* [What is Tevm Node?](../introduction/what-is-tevm-node)
* [Creating a Node](../core/create-tevm-node)
* [Block](./block)


***

title: Contract Utilities
description: Helper utilities for creating and managing smart contracts, including createContract and standard contract templates.

## Contract Utilities

The [`tevm/contract`](https://github.com/evmts/tevm-monorepo/tree/main/packages/contract) package provides powerful utilities for working with [Ethereum smart contracts](https://ethereum.org/en/developers/docs/smart-contracts/), offering type-safe contract interactions and simplified deployment workflows.

### createContract

Creates a strongly-typed contract instance with read and write actions:

```ts
import { createContract } from 'tevm/contract'

const contract = createContract({
  // Use as const for type safety
  humanReadableAbi: [
    'function balanceOf(address) view returns (uint256)',
    'function transfer(address to, uint256 amount) returns (bool)',
    'event Transfer(address indexed from, address indexed to, uint256 value)',
  ] as const,
  name: 'MyToken',
})

// Type-safe read actions
const readAction = contract.read.balanceOf('0x...')

// Type-safe write actions
const writeAction = contract.write.transfer('0x...', 1000n)
```

#### Contract with Address

Add an [Ethereum address](https://ethereum.org/en/developers/docs/accounts/#account-creation) to create a fully configured contract instance:

```ts
const token = contract.withAddress('0x1234...')

// Now includes address in all actions
const balanceAction = token.read.balanceOf('0x...')
// balanceAction.to will be set to the token address
```

### Standard Contracts

The package includes pre-built contracts for common standards:

```ts
import { ERC20, ERC721 } from 'tevm/contract'

// ERC20 token with all standard methods
const token = ERC20.withAddress('0x...')

// Read token info
const nameAction = token.read.name()
const symbolAction = token.read.symbol()
const supplyAction = token.read.totalSupply()

// Transfer tokens
const transferAction = token.write.transfer('0x...', 1000n)

// ERC721 NFT contract
const nft = ERC721.withAddress('0x...')
const ownerAction = nft.read.ownerOf(1n)
```

For more information on token standards, see:
\- [ERC-20 Token Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
\- [ERC-721 NFT Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/)

### Deployless Scripts

Create self-deploying contract scripts that work with any client:

```ts
import { ERC20 } from 'tevm/contract'

// Create a script that deploys and initializes a token
const script = ERC20.script({
  bytecode: '0x...',  // Contract bytecode
  args: ['MyToken', 'MTK', 1000000n], // Constructor args
})

// Use with any compatible client
const name = await client.contract(script.read.name())
const symbol = await client.contract(script.read.symbol())
```

### Contract Types

The package exports useful types for contract development:

```ts
import type {
  Contract,
  ContractAbi,
  ContractFunctionName,
  ContractEventName,
} from 'tevm/contract'

// Use with your own contracts
type MyContract = Contract<typeof myAbi>
type MyFunctions = ContractFunctionName<typeof myAbi>
type MyEvents = ContractEventName<typeof myAbi>
```

### Best Practices

#### 1. Type Safety

Always use `as const` with [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html) to get full type inference:

```ts
const abi = [
  'function example(uint256 value) returns (bool)',
] as const

const contract = createContract({
  humanReadableAbi: abi,
  name: 'Example',
})
// contract.write.example will have proper types
```

#### 2. Error Handling

Handle contract errors appropriately:

```ts
try {
  const result = await client.contract(contract.write.transfer('0x...', 1000n))
} catch (e) {
  if (e.message.includes('insufficient balance')) {
    // Handle specific error case
  }
  throw e
}
```

#### 3. Gas Management

Consider [gas costs](https://ethereum.org/en/developers/docs/gas/) in write operations:

```ts
const tx = contract.write.complexOperation('0x...', {
  gas: 500000n,  // Set gas limit
  maxFeePerGas: 30000000000n,  // Set max fee
})
```

#### 4. Event Handling

Listen for contract [events](https://docs.soliditylang.org/en/latest/contracts.html#events):

```ts
// Create event filter
const filter = contract.events.Transfer({
  fromBlock: 'latest',
})

// Process events
client.watchEvent(filter, (event) => {
  console.log('Transfer:', {
    from: event.args.from,
    to: event.args.to,
    value: event.args.value,
  })
})
```

### Related Topics

\- [Utilities & Addresses](./utils)
\- [Custom Precompiles](../advanced/custom-precompiles)
\- [State Management](../core/managing-state)
\- [Solidity Documentation](https://docs.soliditylang.org/)
\- [Ethereum Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/)
\- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)


## @tevm/decorators

The `@tevm/decorators` package provides a set of decorators and APIs for extending Tevm clients with additional functionality. It includes implementations for both standard Ethereum JSON-RPC methods and Tevm-specific actions.

### Installation

```bash
npm install @tevm/decorators
```

### Main APIs

#### EthActionsApi

The `EthActionsApi` provides standard Ethereum JSON-RPC methods for interacting with the VM. These actions correspond 1:1 with the public Ethereum JSON-RPC API.

```typescript
import { type EthActionsApi } from '@tevm/decorators'

interface EthActionsApi {
  eth: {
    // Returns the current block number
    blockNumber: EthBlockNumberHandler
    // Executes a call without modifying the state
    call: EthCallHandler
    // Returns the current chain id
    chainId: EthChainIdHandler
    // Returns the current gas price
    gasPrice: EthGasPriceHandler
    // Returns the balance of a given address
    getBalance: EthGetBalanceHandler
    // Returns code at a given address
    getCode: EthGetCodeHandler
    // Returns storage at a given address and slot
    getStorageAt: EthGetStorageAtHandler
  }
}
```

#### TevmActionsApi

The `TevmActionsApi` provides Tevm-specific actions for enhanced VM interaction and state management.

```typescript
import { type TevmActionsApi } from '@tevm/decorators'

interface TevmActionsApi {
  // Sets the state of a specific ethereum address
  setAccount: SetAccountHandler
  // Gets the state of a specific ethereum address
  getAccount: GetAccountHandler
  // Executes a call against the VM with extended options
  call: CallHandler
  // Executes a contract call with typesafe API
  contract: ContractHandler
  // Dumps the current state of the VM
  dumpState: DumpStateHandler
  // Loads a previously dumped state
  loadState: LoadStateHandler
  // Mines blocks
  mine: MineHandler
  // Deploys a contract
  deploy: DeployHandler
  // Deals ERC20 tokens to an account
  deal: AnvilDealHandler
}
```

#### TevmSendApi

The `TevmSendApi` provides low-level JSON-RPC request handling capabilities.

```typescript
import { type TevmSendApi } from '@tevm/decorators'

interface TevmSendApi {
  send: TevmJsonRpcRequestHandler
  sendBulk: TevmJsonRpcBulkRequestHandler
}
```

### Decorators

#### ethActions

A decorator function that extends a client with standard Ethereum JSON-RPC methods.

```typescript
import { ethActions } from '@tevm/decorators'

const clientWithEth = client.extend(ethActions())
// Now you can use eth methods
await clientWithEth.eth.blockNumber()
```

#### tevmActions

A decorator function that extends a client with Tevm-specific actions.

```typescript
import { tevmActions } from '@tevm/decorators'

const clientWithTevm = client.extend(tevmActions())
// Now you can use Tevm actions
await clientWithTevm.call({
  to: '0x123...',
  data: '0x456...'
})
```

### Examples

#### Using EthActionsApi

```typescript
// Get current block number
const blockNumber = await client.eth.blockNumber()
console.log(blockNumber) // 0n

// Get balance of an address
const balance = await client.eth.getBalance({
  address: '0x123...',
  tag: 'pending'
})
console.log(balance) // 0n

// Execute a call
const result = await client.eth.call({
  to: '0x123...',
  data: '0x456...'
})
```

#### Using TevmActionsApi

```typescript
// Set account state
await client.setAccount({
  address: '0x123...',
  deployedBytecode: '0x6080604...',
  balance: parseEther('1.0')
})

// Execute contract call
const result = await client.contract({
  to: '0x123...',
  abi: [...],
  function: 'run',
  args: ['world'],
  from: '0x456...'
})

// Dump and load state
const { state } = await client.dumpState()
await client.loadState({ state })

// Deal tokens
await client.deal({
  erc20: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
  account: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  amount: 1000000n // 1 USDC (6 decimals)
})
```

### Types

The package includes several additional types for working with Ethereum and EIP-1193:

* `AddEthereumChainParameter`: Parameters for adding a new chain
* `EIP1193Parameters`: Parameters for EIP-1193 requests
* `Hash`: Type for Ethereum hashes
* `LogTopic`: Type for event log topics
* `NetworkSync`: Network synchronization status
* `WalletPermission`: Wallet permission parameters
* `WatchAssetParams`: Parameters for watching assets

### See Also

* [Tevm Actions Documentation](https://tevm.sh/learn/actions/)
* [JSON-RPC API Documentation](https://ethereum.github.io/execution-apis/api-documentation/)


## EVM Events

Tevm Node provides access to low-level EVM events through the VM's event emitter. This allows you to monitor and debug contract execution at a granular level.

### Available Events

```ts
type EVMEvent = {
  // Emitted when a new contract is created
  newContract: (data: {
    address: Address,
    code: Uint8Array
  }) => void

  // Emitted before a message (call) is processed
  beforeMessage: (data: Message) => void

  // Emitted after a message (call) is processed
  afterMessage: (data: EVMResult) => void

  // Emitted on each EVM step
  step: (data: InterpreterStep) => void
}
```

### Basic Usage

```ts
import { createTevmNode } from 'tevm'

const node = createTevmNode()
const vm = await node.getVm()

// Listen for EVM steps
vm.evm.events?.on('step', (step, next) => {
  console.log('EVM Step:', {
    pc: step.pc,           // Program counter
    opcode: step.opcode,   // Current opcode
    gasLeft: step.gasLeft, // Remaining gas
    stack: step.stack,     // Stack contents
    depth: step.depth,     // Call depth
  })
  next?.()
})

// Listen for contract creation
vm.evm.events?.on('newContract', (data, next) => {
  console.log('New contract deployed:', {
    address: data.address.toString(),
    codeSize: data.code.length,
  })
  next?.()
})

// Listen for message execution
vm.evm.events?.on('beforeMessage', (message, next) => {
  console.log('Executing message:', {
    to: message.to?.toString(),
    value: message.value.toString(),
    delegatecall: message.delegatecall,
  })
  next?.()
})

vm.evm.events?.on('afterMessage', (result, next) => {
  console.log('Message result:', {
    gasUsed: result.execResult.executionGasUsed.toString(),
    returnValue: result.execResult.returnValue.toString('hex'),
    error: result.execResult.exceptionError?.error,
  })
  next?.()
})
```

### Debugging Example

```ts
// Create a debug tracer
function createDebugTracer(vm) {
  const trace = {
    steps: [],
    contracts: new Set(),
    errors: [],
  }

  // Track each EVM step
  vm.evm.events?.on('step', (step, next) => {
    trace.steps.push({
      pc: step.pc,
      opcode: step.opcode.name,
      gasCost: step.opcode.fee,
      stack: step.stack.map(item => item.toString(16)),
    })
    next?.()
  })

  // Track contract creation
  vm.evm.events?.on('newContract', (data, next) => {
    trace.contracts.add(data.address.toString())
    next?.()
  })

  // Track errors
  vm.evm.events?.on('afterMessage', (result, next) => {
    if (result.execResult.exceptionError) {
      trace.errors.push({
        error: result.execResult.exceptionError.error,
        returnData: result.execResult.returnValue.toString('hex'),
      })
    }
    next?.()
  })

  return trace
}

// Use the tracer
const node = createTevmNode()
const vm = await node.getVm()
const trace = createDebugTracer(vm)

// Run some transactions...

console.log('Execution trace:', {
  stepCount: trace.steps.length,
  contracts: Array.from(trace.contracts),
  errors: trace.errors,
})
```

### Gas Profiling

```ts
// Create a gas profiler
function createGasProfiler(vm) {
  const profile = {
    opcodes: new Map(),
    totalGas: 0n,
  }

  vm.evm.events?.on('step', (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = profile.opcodes.get(opName) || {
      count: 0,
      totalGas: 0n
    }

    stats.count++
    stats.totalGas += gasCost
    profile.totalGas += gasCost
    profile.opcodes.set(opName, stats)

    next?.()
  })

  return profile
}

// Use the profiler
const node = createTevmNode()
const vm = await node.getVm()
const profile = createGasProfiler(vm)

// Run transactions...

// Get gas usage by opcode
for (const [opcode, stats] of profile.opcodes) {
  console.log(`${opcode}:`, {
    count: stats.count,
    totalGas: stats.totalGas.toString(),
    percentageOfTotal: Number(stats.totalGas * 100n / profile.totalGas),
  })
}
```

### Error Handling

```ts
vm.evm.events?.on('afterMessage', (result, next) => {
  if (result.execResult.exceptionError) {
    const error = result.execResult.exceptionError

    switch (error.error) {
      case 'out of gas':
        console.error('Transaction ran out of gas')
        break
      case 'revert':
        console.error('Transaction reverted:',
          result.execResult.returnValue.toString('hex'))
        break
      case 'invalid opcode':
        console.error('Invalid opcode encountered')
        break
      default:
        console.error('Unknown error:', error)
    }
  }
  next?.()
})
```

### Best Practices

1. **Always Call Next**
   ```ts
   vm.evm.events?.on('step', (step, next) => {
     // Process step...
     next?.() // Important: Call next to continue execution
   })
   ```

2. **Clean Up Listeners**
   ```ts
   const handler = (step, next) => {
     // Handle step...
     next?.()
   }

   vm.evm.events?.on('step', handler)

   // Later...
   vm.evm.events?.off('step', handler)
   ```

3. **Handle Errors Gracefully**
   ```ts
   vm.evm.events?.on('step', (step, next) => {
     try {
       // Process step...
     } catch (error) {
       console.error('Error processing step:', error)
     }
     next?.()
   })
   ```

### Related Topics

* [Performance Profiler](../advanced/performance-profiler)
* [Gas Estimation](../api/methods)


## @tevm/evm

The `@tevm/evm` package provides a custom implementation of the Ethereum Virtual Machine (EVM), extending the functionality of `ethereumjs/evm`. It's responsible for executing Ethereum bytecode and managing the execution environment.

### Installation

```bash
npm install @tevm/evm
```

### Main Components

#### Evm Class

The main class for executing Ethereum bytecode. It extends the EthereumJS EVM with Tevm-specific functionality.

```typescript
import { createEvm } from 'tevm/evm'
import { mainnet } from 'tevm/common'
import { createStateManager } from 'tevm/state'
import { createChain } from 'tevm/chain'

const evm = await createEvm({
  common: mainnet,
  stateManager: createStateManager({}),
  blockchain: await createChain({ common: mainnet }),
})
```

##### Methods

* `runCall(opts: EvmRunCallOpts): Promise<EvmResult>` - Executes an EVM message
* `addCustomPrecompile(precompile: CustomPrecompile): void` - Adds a custom precompile
* `removeCustomPrecompile(precompile: CustomPrecompile): void` - Removes a custom precompile
* `getActiveOpcodes(): OpcodeList` - Returns currently activated opcodes
* `getPrecompile(address: Address): PrecompileFunc | undefined` - Returns precompile at address
* `getPerformanceLogs()` - Returns performance logs for opcodes and precompiles

#### Creating an EVM Instance

The `createEvm` function is the recommended way to create a new EVM instance:

```typescript
import { createEvm } from 'tevm/evm'

const evm = await createEvm({
  common: mainnet,
  stateManager: createStateManager({}),
  blockchain: await createChain({ common: mainnet }),
  customPrecompiles: [], // Optional custom precompiles
  profiler: false, // Enable/disable profiling
  loggingLevel: 'warn', // Logging configuration
})
```

#### Custom Precompiles

The EVM supports custom precompiles that allow executing arbitrary JavaScript code:

```typescript
import { definePrecompile, defineCall, createContract, parseAbi } from 'tevm'
import { createAddress } from 'tevm/address'

const MyContract = createContract({
  address: createAddress(2424).toString(),
  abi: parseAbi([
    'function addTwo(uint256) returns (uint256)',
  ])
})

const customPrecompile = definePrecompile({
  contract: MyContract,
  call: defineCall(MyContract.abi, {
    addTwo: async ({ args }) => {
      return {
        returnValue: args[0] + 5n,
        executionGasUsed: 0n
      }
    }
  })
})

// Add to EVM - note we need to call .precompile()
evm.addCustomPrecompile(customPrecompile.precompile())
```

### Types

#### EvmResult

Result of executing a message via the EVM:

```typescript
interface EvmResult {
  createdAddress?: Address
  execResult: ExecResult
}
```

#### ExecResult

Detailed execution result:

```typescript
interface ExecResult {
  returnValue: Uint8Array
  executionGasUsed: bigint
  gas?: bigint
  gasRefund?: bigint
  exceptionError?: EvmError
  logs?: Log[]
  selfdestruct?: Set<string>
  createdAddresses?: Set<string>
  blobGasUsed?: bigint
}
```

#### EvmRunCallOpts

Options for running a call operation:

```typescript
interface EvmRunCallOpts {
  to?: Address
  caller?: Address
  data?: Uint8Array
  value?: bigint
  gasLimit?: bigint
  gasPrice?: bigint
  skipBalance?: boolean
  depth?: number
  isStatic?: boolean
  selfdestruct?: Set<string>
  delegatecall?: boolean
}
```

### Error Handling

The EVM uses the `EvmError` class for error handling, with various error types defined in `EvmErrorMessage`:

```typescript
enum EvmErrorMessage {
  OUT_OF_GAS = 'out of gas',
  CODESTORE_OUT_OF_GAS = 'code store out of gas',
  INVALID_JUMP = 'invalid JUMP',
  INVALID_OPCODE = 'invalid opcode',
  STACK_OVERFLOW = 'stack overflow',
  STACK_UNDERFLOW = 'stack underflow',
  REVERT = 'revert',
  STATIC_STATE_CHANGE = 'static state change',
  INTERNAL_ERROR = 'internal error',
  // ... and more
}
```

### Events and Debugging

The EVM includes support for debugging and event tracking:

```typescript
// Enable debug logging
const evm = await createEvm({
  // ... other options
  loggingLevel: 'trace'
})

// Get performance logs
const logs = evm.getPerformanceLogs()
console.log(logs.opcodes) // Opcode execution stats
console.log(logs.precompiles) // Precompile execution stats
```

### See Also

* [EthereumJS EVM Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm)
* [Tevm State Documentation](https://tevm.sh/reference/tevm/state/)
* [Tevm Precompiles Documentation](https://tevm.sh/reference/tevm/precompiles/)


## JSON-RPC Support

Tevm Node provides comprehensive [JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/) support through an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible interface. This allows seamless integration with popular Ethereum libraries and tools.

### EIP-1193 Provider

The node can be extended to expose an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) compatible request interface:

```ts
import { createTevmNode } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Use standard JSON-RPC methods
const blockNum = await node.request({
  method: 'eth_blockNumber',
  params: [],
})
```

### Supported Methods

#### Core Ethereum Methods

* **Block & Chain**
  * [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) - Get current block number
  * [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) - Get block by hash
  * [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) - Get block by number
  * [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) - Get current chain ID

* **State & Account**
  * [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) - Get account balance
  * [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) - Get contract code
  * [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) - Get storage value
  * [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) - Get account nonce

* **Transaction**
  * [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) - Execute contract call
  * [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) - Estimate gas usage
  * [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction) - Send transaction
  * [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction) - Send signed transaction
  * [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) - Get transaction details
  * [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) - Get transaction receipt

* **Logs & Events**
  * [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) - Get event logs
  * [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) - Create new filter
  * [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newblockfilter) - Create block filter
  * [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) - Get filter updates
  * [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) - Get all filter logs
  * [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallfilter) - Remove filter

#### Extended Methods

Tevm also supports additional methods commonly found in development environments:

* **Debug Methods**
  * [`debug_traceTransaction`](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug#debug_tracetransaction) - Trace transaction execution
  * [`debug_dumpState`](https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-debug#debug_dumpstate) - Dump current state

* **Anvil Methods** (For [Foundry](https://book.getfoundry.sh/reference/anvil/) compatibility)
  * `anvil_setCode` - Set contract code
  * `anvil_setBalance` - Set account balance
  * `anvil_setNonce` - Set account nonce
  * `anvil_setStorageAt` - Set storage value
  * `anvil_impersonateAccount` - Impersonate account
  * `anvil_stopImpersonatingAccount` - Stop impersonating

### Client Integration

#### Using with Viem

For more information, see the [Viem Documentation](https://viem.sh/docs/clients/custom.html).

```ts
import { createTevmNode } from 'tevm'
import { createPublicClient, custom } from 'viem'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

const client = createPublicClient({
  chain: mainnet,
  transport: custom(node.request),
})
```

#### Using with Ethers

For more information, see the [Ethers Documentation](https://docs.ethers.org/v6/api/providers/#Provider).

```ts
import { createTevmNode } from 'tevm'
import { BrowserProvider } from 'ethers'
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())
const provider = new BrowserProvider(node)
```

### Error Handling

JSON-RPC errors follow the [standard format](https://www.jsonrpc.org/specification#error_object):

```ts
interface JsonRpcError {
  code: number
  message: string
  data?: unknown
}
```

Common error codes (see [Ethereum JSON-RPC Error Codes](https://eips.ethereum.org/EIPS/eip-1474#error-codes)):

* `-32700`: Parse error
* `-32600`: Invalid request
* `-32601`: Method not found
* `-32602`: Invalid params
* `-32603`: Internal error
* `-32000` to `-32099`: Server error

### Best Practices

1. **Error Handling**: Always wrap RPC calls in try-catch blocks to handle potential errors gracefully.

2. **Gas Estimation**: For transactions, use [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) before sending to ensure sufficient gas.

3. **Receipt Confirmation**: Wait for transaction receipts to confirm state changes:

```ts
const txHash = await node.request({
  method: 'eth_sendTransaction',
  params: [tx],
})

const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash],
})
```

4. **Event Filtering**: Use filters efficiently by:
   * Setting appropriate block ranges
   * Using specific [topics](https://docs.soliditylang.org/en/latest/abi-spec.html#events)
   * Cleaning up unused filters

### Related Topics

* [Using with Viem](../examples/viem)
* [Using with Ethers](../examples/ethers)
* [Managing State](../core/managing-state)
* [Receipts & Logs](../advanced/receipts-and-logs)
* [Ethereum JSON-RPC Specification](https://ethereum.org/en/developers/docs/apis/json-rpc/)
* [EIP-1193: Ethereum Provider JavaScript API](https://eips.ethereum.org/EIPS/eip-1193)

### Using Tevm Actions

Tevm provides a set of high-level actions that can be imported from `tevm/actions`:

```ts
import { tevmCall, tevmMine, tevmGetAccount, tevmSetAccount } from 'tevm/actions'
import { createTevmNode } from 'tevm'

const node = createTevmNode()

// Call a contract
const result = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  value: 0n,
  createTransaction: true
})

// Mine pending transactions
await tevmMine(node)

// Get account state
const account = await tevmGetAccount(node, {
  address: '0x...',
  blockTag: 'latest'
})

// Set account state
await tevmSetAccount(node, {
  address: '0x...',
  balance: 100n,
  nonce: 0n,
  deployedBytecode: '0x...'
})
```

Note: By default, tevm actions require manual mining via `tevmMine()`. If you want transactions to be automatically applied, you can either:

1. Use the lower level API `vm.runCall`
2. Configure the client with `miningConfig: { type: 'auto' }`

### Optimistic Updates with Receipt Manager

For more information on transaction receipts and logs, see the [Ethereum Receipts Documentation](https://ethereum.org/en/developers/docs/transactions/transaction-receipts/).

```ts
import { createTevmNode } from 'tevm'
import { tevmCall, tevmMine } from 'tevm/actions'

const node = createTevmNode()
const receiptsManager = await node.getReceiptsManager()

// Submit transaction
const { txHash } = await tevmCall(node, {
  to: '0x...',
  data: '0x...',
  createTransaction: true
})

// Get optimistic receipt
const pendingReceipt = await receiptsManager.getReceiptByTxHash(txHash)

// Update UI optimistically
updateUI(pendingReceipt)

// Wait for real receipt
const realReceipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: [txHash]
})

// Eject optimistic tx if real receipt differs
if (receiptsAreDifferent(pendingReceipt, realReceipt)) {
  await receiptsManager.removeReceipt(txHash)
  updateUI(realReceipt)
}

// Advanced: Rebase on new blocks
node.on('block', async (blockNumber) => {
  // Get new block
  const block = await node.request({
    method: 'eth_getBlockByNumber',
    params: [blockNumber, true]
  })

  // Get our pending transactions
  const pendingTxs = await receiptsManager.getPendingTransactions()

  // Rebase our transactions on top of new block
  for (const tx of pendingTxs) {
    const result = await tevmCall(node, {
      ...tx,
      blockTag: 'pending'
    })

    // Update receipt
    await receiptsManager.putReceipt(tx.hash, result)
  }

  // Mine rebased transactions
  await tevmMine(node)
})
```


## MemoryClient

**MemoryClient** combines a fully in-memory Ethereum node powered by [Tevm Node](/introduction/what-is-tevm-node) with [viem](https://viem.sh/). It includes:

1. **Public actions** – All standard viem [public actions](https://viem.sh/docs/actions/public/introduction).
2. **Wallet actions** – Sign transactions, send ETH, deploy contracts, etc.
3. **Test actions** – Ganache/Hardhat-like commands (`mine`, `setBalance`, `impersonateAccount`, etc.).
4. **Tevm Node's own** advanced actions – e.g. `tevmCall`, `tevmContract`, `tevmDeploy`.

:::callout
**Power vs. Modularity**
While **MemoryClient** is the most convenient way to use Tevm, it's less tree-shakeable than the lower-level approach (`createTevmNode` + separate "actions"). For many dev/test use cases, MemoryClient's all-in-one experience is ideal.
:::

### Installation

```bash
npm install tevm
```

### Basic Usage

```typescript
import { createMemoryClient } from 'tevm'

// Create a simple memory client
const client = createMemoryClient()

// Get current block number
const blockNumber = await client.getBlockNumber()
```

### Forking

Fork from any EVM-compatible network:

```typescript
import { createMemoryClient, http } from 'tevm'
import { optimism } from 'tevm/common'

const forkedClient = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io')({}),
    blockTag: 'latest',
  },
  common: optimism,
})
```

### Contract Interactions

#### Deploying Contracts

```typescript
import { SimpleContract } from 'tevm/contract'
import { privateKeyToAccount } from 'viem/accounts'

const signerAccount = privateKeyToAccount('0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
const memoryClient = createMemoryClient({
  account: signerAccount,
})

// Deploy SimpleContract with initial value = 2
const txHash = await memoryClient.deployContract(SimpleContract.deploy(2n))
await memoryClient.mine({ blocks: 1 })

// Get the deployment receipt
const receipt = await memoryClient.getTransactionReceipt({ hash: txHash })
const contractAddress = receipt.contractAddress

// Create contract instance
const contract = SimpleContract.withAddress(contractAddress)

// Read from the contract
const currentValue = await memoryClient.readContract(contract.read.get())

// Write to the contract
const setHash = await memoryClient.writeContract(contract.write.set(420n))
await memoryClient.mine({ blocks: 1 })
```

#### Interacting with Existing Contracts

```typescript
import { ERC20 } from 'tevm/contract'

// DAI on Optimism
const Dai = ERC20.withAddress('0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1')

// Read balance of an address
const balance = await memoryClient.readContract(
  Dai.read.balanceOf('0xf0d4c12a5768d806021f80a262b4d39d26c58b8d')
)
```

### Test Actions

#### Time Manipulation

```typescript
// Increase block timestamp
await client.increaseTime({ seconds: 3600 }) // 1 hour

// Set next block timestamp
await client.setNextBlockTimestamp({ timestamp: 1234567890n })
```

#### State Snapshots

```typescript
// Take snapshot
const snap = await client.snapshot()

// Make changes...

// Revert to snapshot
await client.revert({ id: snap })
```

#### Account Management

```typescript
// Set account balance
await client.setBalance({
  address: '0x...',
  value: parseEther('100')
})

// Impersonate account
await client.impersonateAccount({ address: '0x...' })

// Stop impersonating
await client.stopImpersonatingAccount({ address: '0x...' })
```

### Mining Configuration

Configure how transactions are processed:

```typescript
// Auto-mine every transaction
const autoMiningClient = createMemoryClient({
  miningConfig: { type: 'auto' }
})

// Mine on interval
const intervalMiningClient = createMemoryClient({
  miningConfig: {
    type: 'interval',
    interval: 1000 // 1 second
  }
})

// Manual mining
const manualMiningClient = createMemoryClient({
  miningConfig: { type: 'manual' }
})

// Mine blocks manually
await manualMiningClient.mine({ blocks: 1 })
```

### Error Handling

The client includes comprehensive error handling:

```typescript
try {
  await client.writeContract(contract.write.transfer(to, amount))
} catch (e) {
  if (e.message.includes('insufficient funds')) {
    // Handle insufficient funds error
  }
  throw e
}
```

### See Also

* [What is Tevm Node?](../introduction/what-is-tevm-node)
* [Creating a Node](../core/create-tevm-node)
* [Viem Documentation](https://viem.sh)


import { Callout } from 'vocs/components'

## Tevm Node Methods

Tevm Node provides a comprehensive API for interacting with the Ethereum Virtual Machine. This reference covers all core methods and capabilities.

### Core Methods

#### Initialization

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')
  }
})

await node.ready() // Wait for initialization
```

#### Virtual Machine Access

```ts
import { createImpersonatedTx } from '@tevm/tx'
import { Block } from '@tevm/block'
import { EthjsAddress } from '@tevm/utils'

const vm = await node.getVm()

// Create a block for the transaction
const block = new Block()

// Create an impersonated transaction
const tx = createImpersonatedTx({
  impersonatedAddress: EthjsAddress.fromString('0x1234...'),
  nonce: 0n,
  gasLimit: 21064n,
  maxFeePerGas: 8n,
  maxPriorityFeePerGas: 1n,
  to: EthjsAddress.fromString('0x5678...'),
  value: 1000000000000000000n, // 1 ETH
})

// Execute the transaction
const result = await vm.runTx({
  tx,
  block,
  skipNonce: true,  // Skip nonce check
  skipBalance: true, // Skip balance check
})

// Check execution result
if (!result.execResult.exceptionError) {
  console.log('Transaction successful')
  console.log('Gas used:', result.totalGasSpent)
}
```

#### Transaction Pool

```ts
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### Receipts & Logs

```ts
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

### State Management

#### Account Impersonation

```ts
// Impersonate an account (fork mode only)
node.setImpersonatedAccount('0x1234...')

// Get current impersonated account
const impersonated = node.getImpersonatedAccount()

// Stop impersonating
node.setImpersonatedAccount(undefined)
```

Note: account impersonating doesn't actually do anything on tevmnode other than set the account property and is only used to implement it at the json-rpc level in actions like eth\_sendRawTransaction to let those actions know they should impersonate.

#### Event Filtering

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

### Node Properties

#### Status

The `status` property indicates the current state of the node:

```ts
console.log(node.status) // One of: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
```

#### Mode

The `mode` property indicates whether the node is running in fork or normal mode:

```ts
console.log(node.mode) // 'fork' or 'normal'
```

#### Logger

Built-in logging capabilities:

```ts
node.logger.debug('Detailed debugging information')
node.logger.info('General information')
node.logger.warn('Warning messages')
node.logger.error('Error information')
```

### Extensibility

#### Adding Custom Functionality

```ts
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### State Copying

```ts
// Create a deep copy with independent state
const nodeCopy = await node.deepCopy()

// Fork from another node
const forkedNode = createTevmNode({
  fork: { transport: node }
})
```

### JSON-RPC Support

Tevm Node implements standard Ethereum JSON-RPC methods through its EIP-1193 interface:

#### Using EIP-1193

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard JSON-RPC calls
const blockNumber = await node.request({
  method: 'eth_blockNumber',
  params: []
})
```

#### Using Actions

```ts
import { ethActions } from 'tevm/decorators'

const node = createTevmNode().extend(ethActions())

// Using action methods
const blockNumber = await node.eth.getBlockNumber()
const balance = await node.eth.getBalance('0x1234...')
```

#### Supported Methods

* **State Access**
  * \`


## @tevm/receipt-manager

The `@tevm/receipt-manager` package provides functionality for managing Ethereum transaction receipts, including storage, retrieval, and querying of transaction receipts and logs.

### Installation

```bash
npm install @tevm/receipt-manager
```

### Main Components

#### ReceiptsManager

The main class for managing transaction receipts and logs.

```typescript
import { ReceiptsManager } from '@tevm/receipt-manager'

const receiptsManager = new ReceiptsManager(mapDb, chain)
```

##### Methods

* `saveReceipts(block: Block, receipts: TxReceipt[]): Promise<void>` - Saves receipts to the database
* `deleteReceipts(block: Block): Promise<void>` - Deletes receipts for a block
* `getReceipts(blockHash: Uint8Array, calcBloom?: boolean, includeTxType?: boolean): Promise<TxReceipt[] | TxReceiptWithType[]>` - Retrieves receipts for a block
* `getReceiptByTxHash(txHash: Uint8Array): Promise<GetReceiptByTxHashReturn | null>` - Gets receipt by transaction hash
* `getLogs(from: Block, to: Block, addresses?: Uint8Array[], topics?: (Uint8Array | Uint8Array[] | null)[]): Promise<GetLogsReturn>` - Retrieves logs based on filter criteria

#### Receipt Types

##### BaseTxReceipt

Common fields for all transaction receipts:

```typescript
interface BaseTxReceipt {
  // Cumulative gas used in the block including this tx
  cumulativeBlockGasUsed: bigint
  // Bloom bitvector
  bitvector: Uint8Array
  // Logs emitted
  logs: EthjsLog[]
}
```

##### PreByzantiumTxReceipt

Receipt type for pre-Byzantium transactions:

```typescript
interface PreByzantiumTxReceipt extends BaseTxReceipt {
  // Intermediary state root
  stateRoot: Uint8Array
}
```

##### PostByzantiumTxReceipt

Receipt type for post-Byzantium transactions:

```typescript
interface PostByzantiumTxReceipt extends BaseTxReceipt {
  // Status of transaction, 1 if successful, 0 if failed
  status: 0 | 1
}
```

##### EIP4844BlobTxReceipt

Receipt type for EIP-4844 blob transactions:

```typescript
interface EIP4844BlobTxReceipt extends PostByzantiumTxReceipt {
  // Blob gas consumed by a transaction
  blobGasUsed: bigint
  // Blob gas price for block transaction was included in
  blobGasPrice: bigint
}
```

### Usage Examples

#### Saving and Retrieving Receipts

```typescript
// Save receipts for a block
await receiptsManager.saveReceipts(block, receipts)

// Get receipts for a block
const receipts = await receiptsManager.getReceipts(blockHash)

// Get receipts with bloom filter calculation
const receiptsWithBloom = await receiptsManager.getReceipts(blockHash, true)

// Get receipts with transaction type
const receiptsWithType = await receiptsManager.getReceipts(blockHash, false, true)
```

#### Working with Transaction Receipts

```typescript
// Get receipt by transaction hash
const receipt = await receiptsManager.getReceiptByTxHash(txHash)
if (receipt) {
  const [txReceipt, blockHash, txIndex, logIndex] = receipt
  console.log('Transaction status:', txReceipt.status)
  console.log('Block hash:', blockHash)
  console.log('Transaction index:', txIndex)
  console.log('Log index:', logIndex)
}
```

#### Querying Logs

```typescript
// Get logs between blocks with optional address and topic filters
const logs = await receiptsManager.getLogs(
  fromBlock,
  toBlock,
  [address], // Optional address filter
  [[topic1, topic2]] // Optional topic filters
)

// Process logs
logs.forEach(({ log, block, tx, txIndex, logIndex }) => {
  console.log('Log address:', log[0])
  console.log('Log topics:', log[1])
  console.log('Log data:', log[2])
  console.log('Block number:', block.header.number)
  console.log('Transaction:', tx)
  console.log('Indices:', txIndex, logIndex)
})
```

### Constants

The ReceiptsManager includes several constants for limiting log queries:

```typescript
// Maximum number of logs to return
GET_LOGS_LIMIT = 10000

// Maximum size of getLogs response in megabytes
GET_LOGS_LIMIT_MEGABYTES = 150

// Maximum block range for getLogs
GET_LOGS_BLOCK_RANGE_LIMIT = 2500
```

### See Also

* [Ethereum Transaction Receipts](https://ethereum.org/en/developers/docs/transactions/#transaction-receipts)
* [EIP-658: Embedding transaction status code in receipts](https://eips.ethereum.org/EIPS/eip-658)
* [EIP-4844: Shard Blob Transactions](https://eips.ethereum.org/EIPS/eip-4844)


## @tevm/state

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/state/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/state/docs) folder.

The `@tevm/state` package provides functionality for managing Ethereum state, including account storage, contract code, and state transitions. It implements the EVM state manager interface and adds Tevm-specific features.

### Installation

```bash
npm install @tevm/state
```

Or use `tevm/state` if you have the main `tevm` package installed

### Main Components

#### StateManager

The main interface for managing Ethereum state:

```typescript
interface StateManager {
  ready: () => Promise<true>
  getAccountAddresses: () => Set<Address>
  deepCopy: () => Promise<StateManager>
  dumpCanonicalGenesis: () => Promise<TevmState>
  clearCaches: () => void
  getAccount: (address: Address) => Promise<Account>
  putAccount: (address: Address, account: Account) => Promise<void>
  deleteAccount: (address: Address) => Promise<void>
  modifyAccountFields: (address: Address, fields: { nonce?: bigint; balance?: bigint }) => Promise<void>
  getContractCode: (address: Address) => Promise<Uint8Array>
  putContractCode: (address: Address, code: Uint8Array) => Promise<void>
  getContractStorage: (address: Address, key: Uint8Array) => Promise<Uint8Array>
  putContractStorage: (address: Address, key: Uint8Array, value: Uint8Array) => Promise<void>
  clearContractStorage: (address: Address) => Promise<void>
  checkpoint: () => Promise<void>
  commit: () => Promise<void>
  revert: () => Promise<void>
  getStateRoot: () => Promise<Uint8Array>
  setStateRoot: (root: Uint8Array) => Promise<void>
  hasStateRoot: (root: Uint8Array) => Promise<boolean>
  dumpStorage: (address: Address) => Promise<StorageDump>
  dumpStorageRange: (address: Address, startKey: bigint, limit: number) => Promise<StorageRange>
  getProof: (address: Address, storageKeys: Uint8Array[]) => Promise<Proof>
}
```

#### Creating a State Manager

```typescript
import { createStateManager } from 'tevm/state'

const stateManager = createStateManager({
  loggingLevel: 'info'
})
```

### Core Functionality

#### Account Management

```typescript
import { createStateManager } from 'tevm/state'
import { createAddress } from 'tevm/address'

const stateManager = createStateManager({})
const address = createAddress('0x1234567890123456789012345678901234567890')

// Get account state
const account = await stateManager.getAccount(address)

// Update account
await stateManager.putAccount(address, account)

// Delete account
await stateManager.deleteAccount(address)

// Modify specific account fields
await stateManager.modifyAccountFields(address, {
  nonce: 1n,
  balance: 100n
})
```

#### Contract Management

```typescript
import { createStateManager } from 'tevm/state'
import { createAddress } from 'tevm/address'
import { hexToBytes } from 'tevm/utils'

const stateManager = createStateManager({})
const address = createAddress('0x1234567890123456789012345678901234567890')
const key = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001')
const value = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000002')
const code = new Uint8Array([1, 2, 3])

// Get and set contract code
await stateManager.putContractCode(address, code)
const retrievedCode = await stateManager.getContractCode(address)

// Get and set contract storage
await stateManager.putContractStorage(address, key, value)
const retrievedValue = await stateManager.getContractStorage(address, key)

// Clear contract storage
await stateManager.clearContractStorage(address)
```

#### State Management

```typescript
// Create checkpoint
await stateManager.checkpoint()

// Commit changes
await stateManager.commit()

// Revert to last checkpoint
await stateManager.revert()

// Get state root
const root = await stateManager.getStateRoot()

// Set state root
await stateManager.setStateRoot(root)

// Check if state root exists
const exists = await stateManager.hasStateRoot(root)
```

#### State Dumping and Proofs

```typescript
// Dump canonical genesis state
const state = await stateManager.dumpCanonicalGenesis()

// Dump storage for address
const storage = await stateManager.dumpStorage(address)

// Dump storage range
const range = await stateManager.dumpStorageRange(address, 4n, 10)

// Get merkle proof
const proof = await stateManager.getProof(address, storageKeys)
```

#### Cache Management

```typescript
// Clear all caches
stateManager.clearCaches()

// Deep copy (independent state)
const deepCopy = await stateManager.deepCopy()
```

### Best Practices

1. **Always await ready()**

```typescript
const stateManager = createStateManager({})
await stateManager.ready()
```

2. **Use checkpoints for atomic operations**

```typescript
await stateManager.checkpoint()
try {
  // Perform state changes
  await stateManager.commit()
} catch (error) {
  await stateManager.revert()
}
```

3. **Clear caches when memory usage is high**

```typescript
// Periodically clear caches
stateManager.clearCaches()
```

4. **Use proper error handling**

```typescript
try {
  await stateManager.getAccount(address)
} catch (error) {
  if (error instanceof AccountNotFoundError) {
    // Handle missing account
  }
  // Handle other errors
}
```

### Related Topics

* [EVM State Documentation](https://ethereum.org/en/developers/docs/evm/state)
* [Merkle Patricia Tree](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
* [Account Management](https://ethereum.org/en/developers/docs/accounts)


import { Callout } from 'vocs/components'

## Call API

The `callHandler` action is one of the most important APIs in Tevm, covering 90% of use cases along with `mineHandler`. It provides a powerful interface for executing EVM calls with extensive configuration options.

### Basic Usage

```ts
import { callHandler } from 'tevm/actions'
import { createTevmNode, PREFUNDED_ACCOUNTS } from 'tevm'

const node = createTevmNode()

const result = await callHandler(node)({
  from: PREFUNDED_ACCOUNTS[0].address,
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH on mainnet
  data: '0x' // Empty call
})
```

### Parameters

The `CallParams` type includes:

```ts
type CallParams = {
  // Required for most calls (except contract deployment)
  to?: Address
  // Input data for the call
  data?: Hex
  // Value in wei to send
  value?: bigint
  // Gas limit for the call
  gas?: bigint
  // Block tag to execute against
  blockTag?: 'latest' | 'pending' | 'earliest' | number
  // Whether to create a transaction
  createTransaction?: 'on-success' | 'always' | 'never' | boolean
  // Whether to skip balance checks
  skipBalance?: boolean
  // Whether to create an access list
  createAccessList?: boolean
  // Whether to create a debug trace
  createTrace?: boolean
  // From address (defaults to first account)
  from?: Address
  // Gas price settings
  maxFeePerGas?: bigint
  maxPriorityFeePerGas?: bigint
  // State overrides
  stateOverrideSet?: StateOverrideSet
  // Block overrides
  blockOverrideSet?: BlockOverrideSet
}
```

### Return Type

The `CallResult` includes:

```ts
type CallResult = {
  // Return data from the call
  rawData: Hex
  // Gas used by the EVM
  executionGasUsed: bigint
  // Total gas including intrinsic costs
  totalGasSpent?: bigint
  // Transaction hash if created
  txHash?: Hex
  // Logs emitted
  logs?: Log[]
  // Created contract address
  createdAddress?: Address
  // Access list if requested
  accessList?: Record<Address, Set<Hex>>
  // Debug trace if requested
  trace?: DebugTraceCallResult
  // Any errors that occurred
  errors?: TevmCallError[]
}
```

### Examples

#### 1. Simple Contract Call

```ts
// Example ERC20 ABI for 'balanceOf'
const abi = [{
  name: 'balanceOf',
  type: 'function',
  inputs: [{ name: 'account', type: 'address' }],
  outputs: [{ name: 'balance', type: 'uint256' }],
  stateMutability: 'view'
}] as const

const result = await callHandler(node)({
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  from: PREFUNDED_ACCOUNTS[0].address,
  data: encodeFunctionData({
    abi,
    functionName: 'balanceOf',
    args: [PREFUNDED_ACCOUNTS[0].address]
  })
})

const balance = decodeFunctionResult({
  abi,
  functionName: 'balanceOf',
  data: result.rawData
})
```

#### 2. Contract Deployment

```ts
// Simple contract bytecode (returns 42)
const bytecode = '0x6080604052348015600f57600080fd5b50602a60808190526040516100929190810190830190829052565b604051601f19601f830116810160405280815292829060208401853c80601f830112156100c057600080fd5b505b50505050610047806100d36000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80632096525514602d575b600080fd5b60336047565b604051603e91906059565b60405180910390f35b602a81565b6000819050919050565b6053816040565b82525050565b6000602082019050606c6000830184604c565b9291505056fea2646970667358221220f1c69e125f1a9f0c5e22a6fb4f9cb134c5b43496922c563e13731844a6e4d12d64736f6c63430008130033'

const result = await callHandler(node)({
  from: PREFUNDED_ACCOUNTS[0].address,
  data: bytecode,
  createTransaction: true
})

console.log('Contract deployed at:', result.createdAddress)
```

#### 3. State Override

```ts
const result = await callHandler(node)({
  from: PREFUNDED_ACCOUNTS[0].address,
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  data: '0x',
  stateOverrideSet: {
    [PREFUNDED_ACCOUNTS[0].address]: {
      balance: 4096n, // 0x1000 as bigint
      nonce: 2n,
      code: '0x',
      state: {}
    }
  }
})
```

#### 4. Debug Trace

```ts
const result = await callHandler(node)({
  from: PREFUNDED_ACCOUNTS[0].address,
  to: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
  data: '0x',
  createTrace: true
})

// Analyze the execution trace
if (result.trace) {
  result.trace.structLogs.forEach(log => {
    console.log(log.op, log.stack, log.memory)
  })
}
```

### Higher Level APIs

While `callHandler`


## @tevm/tx

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/tx/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/tx/docs) folder.

The `@tevm/tx` package provides a custom implementation of Ethereum transactions, extending the functionality of `@ethereumjs/tx`. It includes support for various transaction types and introduces impersonated transactions unique to Tevm.

### Installation

```bash
npm install @tevm/tx
```

### Main Components

#### Transaction Types

The package supports multiple transaction types:

* **LegacyTransaction**: Pre-EIP-2718 transactions
* **AccessListEIP2930Transaction**: Type 1 transactions with access lists (EIP-2930)
* **FeeMarketEIP1559Transaction**: Type 2 transactions with fee market (EIP-1559)
* **BlobEIP4844Transaction**: Type 3 transactions with blob data (EIP-4844)
* **ImpersonatedTx**: Tevm-specific transaction type for impersonating accounts

#### TransactionFactory

A utility class for creating transactions from various data formats:

```typescript
import { TransactionFactory } from '@tevm/tx'

// Create from serialized data
const tx = TransactionFactory.fromSerializedTx(serializedData)

// Create from RPC data
const tx = await TransactionFactory.fromRPC(rpcTxData)

// Create from block body data
const tx = TransactionFactory.fromBlockBodyData(blockData)
```

#### Impersonated Transactions

A unique feature of Tevm that allows simulating transactions as if they were sent from any address:

```typescript
import { createImpersonatedTx } from '@tevm/tx'

const tx = createImpersonatedTx({
  impersonatedAddress: address,
  to: recipient,
  value: value,
  data: data,
  // ... other EIP-1559 transaction fields
})
```

### Transaction Types

#### Legacy Transactions

Pre-EIP-2718 transactions with basic fields:

```typescript
interface LegacyTxData {
  nonce: bigint
  gasPrice: bigint
  gasLimit: bigint
  to?: Address
  value: bigint
  data: Uint8Array
  v?: bigint
  r?: bigint
  s?: bigint
}
```

#### EIP-2930 Transactions

Type 1 transactions with access lists:

```typescript
interface AccessListEIP2930TxData extends LegacyTxData {
  chainId: bigint
  accessList: AccessList
}
```

#### EIP-1559 Transactions

Type 2 transactions with fee market:

```typescript
interface FeeMarketEIP1559TxData extends AccessListEIP2930TxData {
  maxFeePerGas: bigint
  maxPriorityFeePerGas: bigint
}
```

#### EIP-4844 Transactions

Type 3 transactions with blob data:

```typescript
interface BlobEIP4844TxData extends FeeMarketEIP1559TxData {
  maxFeePerBlobGas: bigint
  blobVersionedHashes: Uint8Array[]
  blobs?: Uint8Array[]
  kzgCommitments?: Uint8Array[]
  kzgProofs?: Uint8Array[]
}
```

### Common Operations

#### Creating Transactions

```typescript
import { TransactionFactory, LegacyTransaction } from '@tevm/tx'

// Using factory
const tx = TransactionFactory.fromTxData({
  nonce: 0n,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: '0x...',
  value: 1000000000000000000n,
  data: new Uint8Array()
})

// Direct instantiation
const legacyTx = new LegacyTransaction({
  nonce: 0n,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: '0x...',
  value: 1000000000000000000n,
  data: new Uint8Array()
})
```

#### Signing Transactions

```typescript
const signedTx = tx.sign(privateKey)
```

#### Transaction Methods

All transaction types provide common methods:

* `hash()`: Get transaction hash
* `getBaseFee()`: Get minimum required gas
* `getDataFee()`: Get gas cost for data
* `getUpfrontCost()`: Get total required balance
* `isSigned()`: Check if transaction is signed
* `serialize()`: Get RLP encoded transaction
* `toJSON()`: Get JSON representation

### Error Handling

The package includes custom error types:

```typescript
import { InvalidGasLimitError } from '@tevm/tx'

try {
  const tx = createImpersonatedTx(txData)
} catch (e) {
  if (e instanceof InvalidGasLimitError) {
    // Handle invalid gas limit
  }
}
```

### See Also

* [EIP-2718: Typed Transaction Envelope](https://eips.ethereum.org/EIPS/eip-2718)
* [EIP-2930: Optional access lists](https://eips.ethereum.org/EIPS/eip-2930)
* [EIP-1559: Fee market change](https://eips.ethereum.org/EIPS/eip-1559)
* [EIP-4844: Shard Blob Transactions](https://eips.ethereum.org/EIPS/eip-4844)


## @tevm/txpool

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/txpool/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/txpool/docs) folder.

The `@tevm/txpool` package provides a transaction pool (mempool) implementation for managing pending Ethereum transactions. It handles transaction validation, ordering, and lifecycle management.

### Installation

```bash
npm install @tevm/txpool
```

### Main Components

#### TxPool Class

The main class for managing the transaction pool. It provides functionality for adding, removing, and retrieving transactions.

```typescript
import { TxPool } from '@tevm/txpool'

const txPool = new TxPool({
  vm: ethereumVm
})
```

##### Constructor Options

```typescript
interface TxPoolOptions {
  vm: Vm // Ethereum Virtual Machine instance
}
```

#### Core Methods

##### Adding Transactions

```typescript
// Add a transaction with validation
await txPool.add(transaction, requireSignature, skipBalance)

// Add without validation
await txPool.addUnverified(transaction)
```

##### Retrieving Transactions

```typescript
// Get transactions by hash
const txs = txPool.getByHash(txHashes)

// Get transactions by sender address
const txs = await txPool.getBySenderAddress(address)

// Get transactions sorted by price and nonce
const sortedTxs = await txPool.txsByPriceAndNonce({
  baseFee: 1000000000n,
  allowedBlobs: 6
})
```

##### Removing Transactions

```typescript
// Remove a single transaction
txPool.removeByHash(txHash)

// Remove transactions included in new blocks
txPool.removeNewBlockTxs(newBlocks)
```

##### Pool Management

```typescript
// Start the pool
txPool.start()

// Stop the pool
txPool.stop()

// Close the pool
txPool.close()

// Regular cleanup of old transactions
txPool.cleanup()
```

#### Configuration Constants

```typescript
// Minimum gas price bump percentage for replacement transactions
MIN_GAS_PRICE_BUMP_PERCENT = 10

// Minimum gas price (.1 GWei)
MIN_GAS_PRICE = 100000000n

// Maximum transaction data size (128KB)
TX_MAX_DATA_SIZE = 128 * 1024

// Maximum pool size
MAX_POOL_SIZE = 5000

// Maximum transactions per account
MAX_TXS_PER_ACCOUNT = 100
```

### Transaction Types

The pool supports various transaction types:

* Legacy Transactions
* EIP-2930 Access List Transactions
* EIP-1559 Fee Market Transactions
* EIP-4844 Blob Transactions
* Impersonated Transactions (Tevm-specific)

### Pool State Management

#### Pool Data Structure

The pool maintains several data structures:

```typescript
interface TxPool {
  // Main pool mapping addresses to their transactions
  pool: Map<string, TxPoolObject[]>

  // Number of transactions in the pool
  txsInPool: number

  // Map of handled transaction hashes
  handled: Map<string, HandledObject>
}
```

#### Time Limits

```typescript
// Time to keep transactions in pool (minutes)
POOLED_STORAGE_TIME_LIMIT = 20

// Time to remember handled transactions (minutes)
HANDLED_CLEANUP_TIME_LIMIT = 60
```

### Transaction Validation

The pool performs several validations when adding transactions:

1. Signature verification (optional)
2. Size limits
3. Gas price requirements
4. Account transaction limits
5. Nonce ordering
6. Gas price bumps for replacement transactions

### Error Handling

Common error scenarios:

* Pool full
* Transaction too large
* Gas price too low
* Maximum transactions per account reached
* Invalid nonce
* Insufficient gas price bump for replacement

### Usage Example

```typescript
import { TxPool } from '@tevm/txpool'
import { createEvm } from '@tevm/evm'

// Create a new pool
const txPool = new TxPool({
  vm: await createEvm(/* options */)
})

// Start the pool
txPool.start()

// Add transactions
await txPool.add(transaction)

// Get pending transactions for mining
const pendingTxs = await txPool.txsByPriceAndNonce({
  baseFee: currentBaseFee
})

// Clean up old transactions
txPool.cleanup()

// Stop the pool when done
txPool.stop()
```

### See Also

* [EIP-2718: Typed Transaction Envelope](https://eips.ethereum.org/EIPS/eip-2718)
* [EIP-1559: Fee Market Change](https://eips.ethereum.org/EIPS/eip-1559)
* [EIP-4844: Shard Blob Transactions](https://eips.ethereum.org/EIPS/eip-4844)
* [Tevm EVM Documentation](https://tevm.sh/reference/tevm/evm/)


***

title: Utilities & Addresses
description: Core utility functions such as createAddress, createContractAddress, and related classes & errors.

## Utilities & Addresses

Tevm exports a set of lightweight utility functions and classes. Many of these build upon lower-level packages like [`tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) and [`viem`](https://viem.sh) while standardizing usage for Tevm Node. Below are the most commonly used.

### createAddress

Creates an [Ethereum address](https://ethereum.org/en/developers/docs/accounts/#account-creation) from various input formats:

```ts
import { createAddress } from 'tevm/address'

// Creates a TEVM-style Address object from various input forms
let addr = createAddress(`0x${"00".repeat(20)}`)
// from a hex string
addr = createAddress(420n)
// from a bigint
addr = createAddress(new Uint8Array(20))
// from a 20-byte array
```

#### Signature

```ts
declare function createAddress(
  address: number | bigint | string | Uint8Array | EthjsAddress
): Address
```

#### Behavior & Notes

\- Accepts various input types: [`0x`-prefixed hex strings](https://ethereum.org/en/developers/docs/data-structures-and-encoding/hex/), unprefixed hex, numbers, bigints, `Uint8Array`s, or `EthjsAddress`.
\- Throws `InvalidAddressError` if it can't parse a valid 20-byte address from the input.

### Address Class

A thin wrapper around [`EthjsAddress`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/util) offering a simple, consistent shape for Tevm Node. Created by `createAddress` or by forging your own:

```ts
import { Address } from 'tevm/address'

const a = new Address(Uint8Array.from([ /* 20 bytes */ ]))
console.log(a.bytes)  // a raw 20-byte address
console.log(a.toString()) // 0x....
```

### createContractAddress

Creates a contract address following [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014):

```ts
import { createContractAddress } from 'tevm/address'

// from an existing address + nonce, produce the CREATE address
const from = createAddress("0x1111...1111")
const nonce = 1n
const contractAddr = createContractAddress(from, nonce)
```

#### Usage

1\. Follows standard Ethereum's [`keccak256(rlp([senderAddress, nonce]))[-20..]`](https://ethereum.org/en/developers/docs/smart-contracts/deploying/#how-to-deploy-a-smart-contract).
2\. Ideal for simulating `CREATE` addresses in test or dev flows.

#### Error Handling

\- Throws `InvalidAddressError` if the `from` address is invalid.

### Common Errors

\- **InvalidAddressError**
Thrown when a string/bytes input fails to parse as a valid 20-byte address.

\- **UnreachableCodeError**
Thrown internally if a code path was unexpectedly reached. Generally wrapped into a more descriptive error.

### Other Handy Utilities

Some additional lower-level utility re-exports from [`tevm/utils`](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils) or [`viem`](https://viem.sh):

\- `hexToBytes(hex: string): Uint8Array`
Convert a hex string to raw bytes (with optional size checks).
\- `keccak256(data: Uint8Array | HexString, 'bytes' | 'hex')`
A standard [keccak256](https://ethereum.org/en/developers/docs/smart-contracts/security/#keccak256-and-sha-3) hasher.
\- `encodeFunctionData(...)`, `toRlp(...)`, etc.
Various encoding helpers used by Tevm Node internally.

\> **Tip:** If you are building higher-level code in the browser or Node, you may prefer [`viem`](https://viem.sh)'s standardized utilities for bytes conversions, hashing, and ABIs. Tevm re-exports many of these for convenience.

## @tevm/utils

\> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/utils/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/utils/docs) folder.

The `@tevm/utils` package provides a comprehensive collection of utility functions and types for working with Ethereum data structures, encoding/decoding, and common operations. It combines functionality from various Ethereum libraries and adds Tevm-specific utilities.

### Installation

```bash
npm install @tevm/utils
```

### Main Components

#### Data Types and Encoding

##### Hex and Bytes Conversion

```typescript
import {
  bytesToHex,
  hexToBytes,
  bytesToBigInt,
  bytesToNumber,
  hexToBigInt,
  hexToNumber,
  numberToHex,
  stringToHex,
  hexToString
} from '@tevm/utils'

// Convert bytes to hex
const hex = bytesToHex(new Uint8Array([1, 164])) // '0x01a4'

// Convert hex to bytes
const bytes = hexToBytes('0x01a4') // Uint8Array([1, 164])

// Convert to/from numbers
const num = hexToNumber('0x01a4') // 420
const hex2 = numberToHex(420) // '0x01a4'

// String conversion
const str = hexToString('0x48656c6c6f') // 'Hello'
const hex3 = stringToHex('Hello') // '0x48656c6c6f'
```

##### Type Checking

```typescript
import { isHex, isBytes, isAddress } from '@tevm/utils'

isHex('0x123') // true
isBytes(new Uint8Array()) // true
isAddress('0x123...') // true
```

#### Ethereum Specific

##### Unit Conversion

```typescript
import {
  formatEther,
  parseEther,
  formatGwei,
  parseGwei
} from '@tevm/utils'

// Convert wei to ether
formatEther(1000000000000000000n) // '1.0'

// Convert ether to wei
parseEther('1.0') // 1000000000000000000n

// Work with gwei
formatGwei(1000000000n) // '1.0'
parseGwei('1.0') // 1000000000n
```

##### Cryptographic Functions

```typescript
import {
  keccak256,
  ecrecover,
  ecsign,
  randomBytes
} from '@tevm/utils'

// Generate keccak256 hash
const hash = keccak256('0x1234')

// Sign data
const signature = ecsign(messageHash, privateKey)

// Recover address from signature
const address = ecrecover(messageHash, v, r, s)

// Generate random bytes
const random = randomBytes(32)
```

#### ABI Encoding/Decoding

```typescript
import {
  encodeAbiParameters,
  decodeAbiParameters,
  encodeFunctionData,
  decodeFunctionData,
  encodeEventTopics,
  decodeEventLog
} from '@tevm/utils'

// Encode function data
const data = encodeFunctionData({
  abi: [...],
  functionName: 'transfer',
  args: [address, amount]
})

// Decode function data
const result = decodeFunctionData({
  abi: [...],
  data: '0x...'
})

// Work with events
const topics = encodeEventTopics({
  abi: [...],
  eventName: 'Transfer',
  args: [from, to, null]
})
```

#### RLP Encoding/Decoding

```typescript
import { toRlp, fromRlp } from '@tevm/utils'

// Encode to RLP
const rlp = toRlp(['0x123', '0x456'])

// Decode from RLP
const decoded = fromRlp(rlp)
```

#### Memory Database

```typescript
import { createMemoryDb } from '@tevm/utils'

// Create an in-memory database
const db = createMemoryDb()

// Initialize with existing data
const initialData = new Map()
const db2 = createMemoryDb(initialData)
```

#### Event Emitter

```typescript
import { AsyncEventEmitter } from '@tevm/utils'

const emitter = new AsyncEventEmitter()

// Add listener
emitter.on('event', async (data) => {
  // Handle event
})

// Emit event
await emitter.emit('event', data)
```

### Types

#### Basic Types

```typescript
import type {
  Address,
  Hex,
  BlockTag,
  BlockNumber,
  BytesLike,
  BigIntLike
} from '@tevm/utils'

// Example type usage
const address: Address = '0x...'
const hex: Hex = '0x...'
const blockTag: BlockTag = 'latest'
```

#### ABI Types

```typescript
import type {
  Abi,
  AbiFunction,
  AbiEvent,
  AbiConstructor,
  ParseAbi,
  FormatAbi
} from '@tevm/utils'

// Parse ABI
type ParsedAbi = ParseAbi<typeof abiString>

// Format ABI
type FormattedAbi = FormatAbi<typeof parsedAbi>
```

#### Contract Types

```typescript
import type {
  ContractFunctionName,
  ContractConstructorArgs,
  ExtractAbiFunction,
  ExtractAbiEvent
} from '@tevm/utils'

// Extract function from ABI
type TransferFunction = ExtractAbiFunction<typeof abi, 'transfer'>

// Extract event from ABI
type TransferEvent = ExtractAbiEvent<typeof abi, 'Transfer'>
```

### Constants

```typescript
import {
  GWEI_TO_WEI,
  KECCAK256_RLP,
  KECCAK256_RLP_ARRAY
} from '@tevm/utils'

// Common conversion factors and constants
console.log(GWEI_TO_WEI) // 1000000000n
```

### Error Handling

The package uses the `@tevm/errors` package for standardized error handling:

```typescript
import { invariant } from '@tevm/utils'

// Assert conditions
invariant(condition, 'Error message')
```

### See Also

\- [Viem Documentation](https://viem.sh/docs/utilities/fromBytes)
\- [EthereumJS Util Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/util)
\- [ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html)


***

title: VM & Submodules
description: Overview of the internal EVM, blockchain, state, receipts, and more

## VM & Submodules

[Tevm Node](https://github.com/evmts/tevm-monorepo) is built on a modular architecture that separates concerns into distinct submodules. This guide covers the internal components and their APIs.

### Overview

The main submodules are:

1\. **EVM (Ethereum Virtual Machine)** - Core [execution engine](https://ethereum.org/en/developers/docs/evm/)
2\. **Blockchain** - [Block and chain state](https://ethereum.org/en/developers/docs/blocks/) management
3\. **StateManager** - [Account and storage state](https://ethereum.org/en/developers/docs/accounts/) management
4\. **TxPool** - [Transaction mempool](https://ethereum.org/en/developers/docs/transactions/)
5\. **ReceiptsManager** - [Transaction receipts and logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)

### EVM Module

The EVM module handles bytecode execution and state transitions. It is based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm).

```ts
const vm = await node.getVm()
const evm = await vm.evm

// Direct EVM execution
const result = await evm.runCall({
  to: '0x...',
  data: '0x...',
  value: 0n,
  caller: '0x...',
})

// Full transaction execution (recommended)
const txResult = await vm.runTx({
  tx: transaction,
  block: block,
})
```

#### Key Features

\- **State Management**: Handles [account state](https://ethereum.org/en/developers/docs/accounts/), storage, and code execution
\- **Gas Metering**: Tracks [gas consumption](https://ethereum.org/en/developers/docs/gas/) during execution
\- **Precompiles**: [Built-in contract implementations](https://www.evm.codes/precompiled)
\- **EIP Support**: Implements various [Ethereum Improvement Proposals](https://eips.ethereum.org/)

#### Common Operations

```ts
// Check execution result
if (result.execResult.exceptionError) {
  console.error('Execution failed:', result.execResult.exceptionError)
} else {
  console.log('Return value:', result.execResult.returnValue)
  console.log('Gas used:', result.execResult.executionGasUsed)
}

// Access logs from execution
for (const log of result.execResult.logs) {
  console.log('Event:', {
    address: log.address,
    topics: log.topics,
    data: log.data
  })
}
```

### Blockchain Module

The blockchain module manages blocks and chain state. It is based on [`@ethereumjs/blockchain`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/blockchain).

```ts
const chain = (await node.getVm()).blockchain

// Get block by number or hash
const block = await chain.getBlock('latest')
const blockByHash = await chain.getBlock(blockHash)

// Add new block
await chain.putBlock(block)

// Delete block
await chain.delBlock(blockHash)

// Get block details
console.log({
  number: block.header.number,
  hash: block.hash(),
  parentHash: block.header.parentHash,
  stateRoot: block.header.stateRoot
})
```

#### Fork Support

```ts
// When forking, blocks are fetched from the parent chain
const forkedBlock = await chain.getBlock(blockNumber)

// Local blocks override forked blocks
await chain.putBlock(localBlock)
```

### StateManager

The StateManager handles account state and storage. It is based on [`@ethereumjs/statemanager`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/statemanager).

```ts
const state = (await node.getVm()).stateManager

// Account operations
const account = await state.getAccount(address)
await state.putAccount(address, account)

// Contract operations
await state.putContractCode(address, bytecode)
const code = await state.getContractCode(address)

// Storage operations
await state.putContractStorage(address, key, value)
const value = await state.getContractStorage(address, key)

// State snapshots
const snapshot = await state.dumpCanonicalGenesis()
await state.commit()
await state.revert()
```

#### Working with Accounts

```ts
// Create or update account
const account = {
  nonce: 1n,
  balance: 100n,
  storageRoot: EMPTY_ROOT,
  codeHash: EMPTY_HASH
}
await state.putAccount(address, account)

// Delete account
await state.deleteAccount(address)
```

### Transaction Pool

The TxPool manages pending transactions. It is based on [`@ethereumjs/tx-pool`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx-pool).

```ts
const pool = await node.getTxPool()

// Add transaction
await pool.add(transaction)

// Get pending transactions
const pending = await pool.getPendingTransactions()

// Remove transaction
await pool.removeByHash(txHash)

// Get transactions ordered by price
const ordered = await pool.txsByPriceAndNonce({
  baseFee: 10n
})
```

#### Transaction Validation

```ts
// Validate transaction before adding
try {
  await pool.validateTx(transaction)
  await pool.add(transaction)
} catch (error) {
  console.error('Invalid transaction:', error)
}
```

### ReceiptsManager

The ReceiptsManager handles [transaction receipts](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) and event logs.

```ts
const receipts = await node.getReceiptsManager()

// Get receipts for block
const blockReceipts = await receipts.getReceipts(blockHash)

// Get receipt by transaction hash
const txReceipt = await receipts.getReceiptByTxHash(txHash)

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: contractAddress,
  topics: [eventSignature]
})
```

#### Working with Logs

```ts
// Process event logs
for (const log of logs) {
  console.log({
    address: log.address,
    topics: log.topics,
    data: log.data,
    blockNumber: log.blockNumber,
    transactionHash: log.transactionHash,
    logIndex: log.logIndex
  })
}
```

### Best Practices

1\. **Use High-Level APIs**: Prefer `vm.runTx()` over direct EVM execution for full transaction support.

2\. **State Management**:
\- Use checkpoints for atomic operations
\- Clean up state after tests
\- Handle reverts properly

3\. **Gas Optimization**:
\- [Estimate gas](https://ethereum.org/en/developers/docs/gas/#why-are-gas-fees-necessary) before execution
\- Monitor gas usage in hot paths
\- Use appropriate gas limits

4\. **Error Handling**:
\- Check execution results
\- Handle exceptions gracefully
\- Validate inputs

### Related Topics

\- [JSON-RPC Support](./json-rpc)
\- [Managing State](../core/managing-state)
\- [Transaction Pool](../advanced/txpool)
\- [Receipts & Logs](../advanced/receipts-and-logs)
\- [EVM Opcodes Reference](https://www.evm.codes/)
\- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
\- [ethereumjs/ethereumjs-monorepo](https://github.com/ethereumjs/ethereumjs-monorepo)

**Up Next**\
\- [JSON-RPC Guide](./json-rpc)
\- [Advanced Usage](../advanced/txpool)


## @tevm/vm

> **Generated API Documentation**: View the full API documentation in the [evmts/tevm-monorepo/packages/vm/docs](https://github.com/evmts/tevm-monorepo/tree/main/packages/vm/docs) folder.

The `@tevm/vm` package provides a custom implementation of the Ethereum Virtual Machine (VM), extending the functionality of `@ethereumjs/vm`. It's responsible for executing Ethereum transactions and managing the blockchain state.

### Installation

```bash
npm install @tevm/vm
```

### Main Components

#### Creating a VM Instance

```typescript
import { createVm } from '@tevm/vm'
import { createCommon } from '@tevm/common'
import { createStateManager } from '@tevm/state'
import { createChain } from '@tevm/blockchain'
import { createEvm } from '@tevm/evm'

const common = createCommon({ chain: 'mainnet', hardfork: 'cancun' })
const stateManager = createStateManager({})
const blockchain = await createChain({ common })
const evm = await createEvm({
  stateManager,
  blockchain,
  common,
})

const vm = createVm({
  evm,
  common,
  blockchain,
  stateManager,
})
```

#### VM Options

```typescript
interface VmOpts {
  // Chain configuration
  common: Common
  // State management
  stateManager: StateManager
  // Blockchain instance
  blockchain: Chain
  // EVM instance
  evm: Evm
  // Enable precompiled contracts
  activatePrecompiles?: boolean
  // Initial genesis state
  genesisState?: GenesisState
  // Set hardfork by block number or timestamp
  setHardfork?: boolean | BigIntLike
  // Profiling options
  profilerOpts?: VMProfilerOpts
}
```

### Core Functionality

#### Block Operations

##### Building Blocks

```typescript
// Create a new block
const blockBuilder = await vm.buildBlock({
  parentBlock: await blockchain.getCanonicalHeadBlock(),
})

// Add transactions to the block
await blockBuilder.addTransaction(transaction)

// Build and seal the block
const block = await blockBuilder.build()
```

##### Running Blocks

```typescript
// Run an existing block
const result = await vm.runBlock({
  block,
  generate: true, // Generate state root
  skipBlockValidation: false,
})
```

#### Transaction Operations

```typescript
// Run a single transaction
const result = await vm.runTx({
  tx: transaction,
  block: block,
  skipBalance: false,
  skipNonce: false,
})
```

#### State Management

```typescript
// Access state manager
const account = await vm.stateManager.getAccount(address)

// Modify state
await vm.stateManager.putAccount(address, account)

// Commit changes
await vm.stateManager.commit()
```

### Events

The VM emits events during block and transaction processing:

```typescript
// Block events
vm.events.on('beforeBlock', (block, resolve) => {
  // Handle before block execution
  resolve()
})

vm.events.on('afterBlock', (data, resolve) => {
  // Handle after block execution
  resolve()
})

// Transaction events
vm.events.on('beforeTx', (tx, resolve) => {
  // Handle before transaction execution
  resolve()
})

vm.events.on('afterTx', (data, resolve) => {
  // Handle after transaction execution
  resolve()
})
```

### Block Building

The `BlockBuilder` class provides a fluent interface for creating blocks:

```typescript
class BlockBuilder {
  // Current gas used in the block
  gasUsed: bigint

  // Current blob gas used (EIP-4844)
  blobGasUsed: bigint

  // Get transaction receipts
  get transactionReceipts(): TxReceipt[]

  // Get miner rewards
  get minerValue(): bigint

  // Add a transaction to the block
  async addTransaction(
    tx: TypedTransaction | ImpersonatedTx,
    opts?: { skipHardForkValidation?: boolean }
  ): Promise<RunTxResult>

  // Build the final block
  async build(sealOpts?: SealBlockOpts): Promise<Block>
}
```

### Types

#### RunBlockOpts

Options for running a block:

```typescript
interface RunBlockOpts {
  block: Block
  root?: Uint8Array
  generate?: boolean
  skipBlockValidation?: boolean
  skipHeaderValidation?: boolean
  skipNonce?: boolean
  skipBalance?: boolean
  setHardfork?: boolean | BigIntLike
  reportPreimages?: boolean
}
```

#### RunTxOpts

Options for running a transaction:

```typescript
interface RunTxOpts {
  tx: TypedTransaction | ImpersonatedTx
  block?: Block
  skipBalance?: boolean
  skipNonce?: boolean
  skipHardForkValidation?: boolean
  reportPreimages?: boolean
}
```

### Error Handling

The VM throws various error types for different scenarios:

* `InvalidBlockError`: When block validation fails
* `InvalidTransactionError`: When transaction validation fails
* `InsufficientFundsError`: When account balance is insufficient
* `NonceTooLowError`/`NonceTooHighError`: For nonce-related issues
* `InvalidGasLimitError`: When gas limit is invalid
* `EipNotEnabledError`: When using features from non-enabled EIPs

### Usage Example

```typescript
import { createVm } from '@tevm/vm'
import { createCommon } from '@tevm/common'
import { Block } from '@tevm/block'

// Create VM instance
const vm = createVm({
  common: createCommon({ chain: 'mainnet' }),
  // ... other options
})

// Build and process a block
const blockBuilder = await vm.buildBlock({
  parentBlock: await vm.blockchain.getCanonicalHeadBlock(),
})

// Add transactions
for (const tx of transactions) {
  await blockBuilder.addTransaction(tx)
}

// Build and seal the block
const block = await blockBuilder.build()

// Run the block
const result = await vm.runBlock({
  block,
  generate: true,
  skipBlockValidation: false,
})

// Process results
console.log('Gas used:', result.gasUsed)
console.log('Receipts:', result.receipts)
```

### See Also

* [EthereumJS VM Documentation](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/vm)
* [Tevm EVM Documentation](https://tevm.sh/reference/tevm/evm/)
* [Tevm State Documentation](https://tevm.sh/reference/tevm/state/)


import { Callout, Steps, Step } from 'vocs/components'

## Creating a Tevm Node

`createTevmNode` is the main entry point for spinning up a local Tevm Node instance. It provides a flexible configuration API to customize your node's behavior for different use cases.

<Steps>
  <Step title="Install Dependencies">
    First, install the required packages:

    ```bash
    npm install tevm
    ```
  </Step>

  <Step title="Create Node Instance">
    Create a basic node instance:

    #### TypeScript

    ```ts
    import { createTevmNode } from 'tevm'

    const node = createTevmNode()
    await node.ready()
    ```

    #### JavaScript

    ```js
    const { createTevmNode } = require('tevm')

    const node = createTevmNode()
    await node.ready()
    ```
  </Step>

  <Step title="Configure Options">
    Customize the node based on your needs:

    ```ts
    const node = createTevmNode({
      fork: {
        transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      },
      miningConfig: { type: 'auto' },
      loggingLevel: 'debug'
    })
    ```
  </Step>
</Steps>

### Configuration Options

#### Fork Configuration

The `fork` option allows you to create a node that forks from an existing network:

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    // Use any EIP-1193 compatible provider
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    // Optional: Fork from a specific block
    blockTag: 17_000_000n,
  },
})
```

<Callout type="info">
  When forking, state is fetched lazily from the remote provider and cached locally. This means your first access to any account or storage slot will be slower, but subsequent accesses will be fast.
</Callout>

#### Mining Configuration

Control how and when blocks are produced:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto', // Mine a block for every transaction
  },
})

// Or use interval-based mining
const node2 = createTevmNode({
  miningConfig: {
    type: 'interval',
    interval: 12_000, // Mine every 12 seconds
  },
})
```

#### Chain Configuration

Customize the chain parameters:

```ts
import { Common } from 'tevm/common'

const node = createTevmNode({
  common: Common.custom({
    chainId: 1337,
    networkId: 1337,
    // ... other chain parameters
  }),
})
```

Or if your network is a known network import it by name

```ts
import { mainnet, base, arbitrum, optimism } from 'tevm/common'
```

If you want your network added you should first add it to `viem/chains` and open an issue to regenerate the commons in Tevm

#### Logging Configuration

Configure the internal logger:

```ts
const node = createTevmNode({
  loggingLevel: 'debug', // 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace'
})

// Later use the logger
node.logger.debug('Detailed debugging information')
```

#### Custom Precompiles

Add your own precompiled contracts:

```ts
import { definePrecompile, createContract, parseAbi } from 'tevm'

const myPrecompile = definePrecompile({
  contract: createContract({
    abi: parseAbi([
      'function add(uint256 a, uint256 b) returns (uint256)',
      'function subtract(uint256 a, uint256 b) returns (uint256)'
    ]),
    address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'
  }),
  call: async ({ data, gasLimit }) => {
    // Your precompile logic here
    return {
      returnValue: new Uint8Array([0x01]),
      executionGasUsed: 200n,
    }
  },
})

const node = createTevmNode({
  customPrecompiles: [myPrecompile.precompile()],
})
```

#### Performance Profiling

Enable the built-in profiler for performance analysis:

```ts
const node = createTevmNode({
  profiler: true,
})

// Later access profiling data
const vm = await node.getVm()
const logs = vm.evm.getPerformanceLogs()
```

### Complete Configuration Reference

| Property                     | Type                                                           | Default            | Description                                                  |
| ---------------------------- | -------------------------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| `fork`                       | `{ transport: EIP1193RequestFn; blockTag?: BlockTag; }`        | -                  | Enables forking from a live network or another Tevm instance |
| `common`                     | `Common`                                                       | `tevmDevnet`       | Chain configuration object                                   |
| `loggingLevel`               | `"fatal" \| "error" \| "warn" \| "info" \| "debug" \| "trace"` | `"info"`           | Logging verbosity level                                      |
| `miningConfig`               | `{ type: 'auto' } \| { type: 'interval', interval: number }`   | `{ type: 'auto' }` | Block mining behavior                                        |
| `profiler`                   | `boolean`                                                      | `false`            | Enables performance logging                                  |
| `customPrecompiles`          | `Precompile[]`                                                 | `[]`               | Additional precompiled contracts                             |
| `allowUnlimitedContractSize` | `boolean`                                                      | `false`            | Disables EIP-170 contract size checks                        |

### Best Practices

1. **Always await node.ready()**
   ```ts
   const node = createTevmNode()
   await node.ready() // Ensure node is fully initialized
   ```

2. **Use Appropriate Mining Config**
   ```ts
   // For testing - mine after each transaction
   const testNode = createTevmNode({
     miningConfig: { type: 'auto' }
   })

   // For simulation - mine at intervals
   const simNode = createTevmNode({
     miningConfig: { type: 'interval', interval: 12_000 }
   })
   ```

3. **Handle Errors**
   ```ts
   try {
     const node = createTevmNode()
     await node.ready()
   } catch (error) {
     console.error('Node initialization failed:', error)
   }
   ```

### Example Configurations

#### Local Development Node

```ts
const devNode = createTevmNode({
  miningConfig: { type: 'auto' },
  loggingLevel: 'debug',
  allowUnlimitedContractSize: true, // Helpful during development
})
await devNode.ready()
```

#### Production Forked Node

```ts
const prodNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest',
  },
  miningConfig: { type: 'interval', interval: 12000 },
  loggingLevel: 'error', // Less verbose in production
})
await prodNode.ready()
```

#### Testing Node

```ts
const testNode = createTevmNode({
  miningConfig: { type: 'auto' },
  profiler: true, // Enable profiling for performance testing
})
await testNode.ready()
```

### Next Steps

* Learn about the [Node Interface](./tevm-node-interface)
* Explore [Forking](./forking)
* Understand [State Management](./managing-state)
* Learn about [Custom Precompiles](../advanced/custom-precompiles)


import { Callout } from 'vocs/components'

## Forking Networks

Tevm's forking capability allows you to create a local instance that mirrors the state of any live Ethereum network or another Tevm instance. This is incredibly useful for:

* Testing against production state
* Debugging transactions
* Development with real-world data
* Simulating complex DeFi interactions

### Basic Forking

#### TypeScript

```ts
import { createTevmNode, http } from 'tevm'

const node = createTevmNode({
  fork: {
    transport: http('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY')({}),
    blockTag: 'latest',
  },
})

await node.ready()
```

<Callout type="info">
  The `transport` can be any EIP-1193 compatible provider, including those from viem, ethers, or even another Tevm instance. Note that the transport function must be called with an empty object `({})`.
</Callout>

### Reforking Strategies

There are two main strategies for reforking a Tevm node: using the node as a transport or using deep copy.

#### 1. Using Node as Transport

This is the recommended approach as it's more memory efficient. You can use an existing Tevm node as the transport for a new fork:

```ts
import { createTevmNode, http, hexToBigInt } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'

// Create initial node with request handler
const sourceNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
    blockTag: 17_000_000n,
  },
}).extend(requestEip1193())

// Get current block number
const currentBlock = await sourceNode.request({
  method: 'eth_blockNumber',
})

// Create new fork from the current state
const newNode = createTevmNode({
  fork: {
    transport: sourceNode,
    blockTag: hexToBigInt(currentBlock),
  },
})

await newNode.ready()
```

This approach:

* Is memory efficient as it reuses the state from the source node
* Allows forking from a specific point in time
* Maintains the original node's state while allowing new modifications

#### 2. Using Deep Copy

For cases where you need a completely independent copy of the node:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
  },
})

// Read state from the forked node
const USDC_ADDRESS = createAddress('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48')
const vm = await node.getVm()
const usdcContract = await vm.stateManager.getAccount(USDC_ADDRESS)

console.log('USDC contract:', {
  balance: usdcContract?.balance,
  nonce: usdcContract?.nonce,
  codeHash: usdcContract?.codeHash,
})
```

<Callout type="warning">
  Deep copying creates a new instance with its own state, which can be memory intensive for large state trees. Use this approach sparingly and prefer using the node as a transport when possible.
</Callout>

### Working with Forked State

#### Reading State

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
  },
})

// Get USDC contract state
const USDC_ADDRESS = createAddress('0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48')
const vm = await node.getVm()
const usdcContract = await vm.stateManager.getAccount(USDC_ADDRESS)

if (usdcContract) {
  console.log('USDC contract:', {
    balance: usdcContract.balance,
    nonce: usdcContract.nonce,
    codeHash: usdcContract.codeHash,
  })
}
```

#### Modifying State

```ts
import { createAddress } from 'tevm/address'

// Modify balance of an account
const vm = await node.getVm()
const address = createAddress('0x1234567890123456789012345678901234567890')
const account = await vm.stateManager.getAccount(address)
if (account) {
  account.balance += 1000000000000000000n // Add 1 ETH
  await vm.stateManager.putAccount(address, account)

  // Verify the change
  const updatedAccount = await vm.stateManager.getAccount(address)
  console.log('New balance:', updatedAccount?.balance)
}
```

### Performance Optimization

#### State Caching

Tevm implements lazy loading with caching:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'
import { performance } from 'node:perf_hooks'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
  },
})

const vm = await node.getVm()
const testAddress = createAddress('0x1234567890123456789012345678901234567890')

// First access - fetches from remote
const t0 = performance.now()
await vm.stateManager.getAccount(testAddress)
console.log('First access:', performance.now() - t0)

// Second access - uses cache
const t1 = performance.now()
await vm.stateManager.getAccount(testAddress)
console.log('Cached access:', performance.now() - t1)
```

#### Best Practices

1. **RPC Provider Setup**
   ```ts
   // ✅ Always call transport with empty object
   const node = createTevmNode({
     fork: {
       transport: http('https://ethereum.quicknode.com/YOUR-API-KEY')({}),
       blockTag: 15_000_000n,
     },
   })
   ```

2. **Type Safety**
   ```ts
   // ✅ Use proper type checks
   const account = await vm.stateManager.getAccount(address)
   if (account) {
     account.balance += 1000000000000000000n
     await vm.stateManager.putAccount(address, account)
   }
   ```

3. **Address Handling**
   ```ts
   // ✅ Use createAddress for type safety
   import { createAddress } from 'tevm/address'
   const address = createAddress('0x1234567890123456789012345678901234567890')
   ```

4. **Testing Setup**
   ```ts
   // ✅ Wait for node to be ready
   const node = createTevmNode({
     fork: {
       transport: http('https://...')({}),
     },
   })
   await node.ready()
   ```

### Related Topics

* [State Management](./managing-state)
* [Transaction Processing](../advanced/txpool)
* [JSON-RPC Support](../api/json-rpc)


import { Callout } from 'vocs/components'

## Managing State

Tevm Node provides powerful state management capabilities through its `stateManager` interface. This allows you to interact with and modify Ethereum state, including accounts, contract code, and storage.

### Getting Started

Access the state manager through the VM:

```ts
import { createTevmNode } from 'tevm'

const node = createTevmNode()
const vm = await node.getVm()
const stateManager = vm.stateManager
```

### Account Management

#### Reading Accounts

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
const account = await stateManager.getAccount(address)

if (account) {
  console.log({
    balance: account.balance,      // BigInt
    nonce: account.nonce,         // BigInt
    codeHash: account.codeHash,   // Hex string
    storageRoot: account.storageRoot // Hex string
  })
}
```

#### Modifying Accounts

```ts
import { createAddress } from 'tevm/address'
import { EthjsAccount } from 'tevm/utils'

// Create or update an account
const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.putAccount(
  address,
  EthjsAccount.fromAccountData({
    nonce: 0n,
    balance: 10_000_000n,
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })
)
```

<Callout type="info">
  When modifying accounts, make sure to handle the case where the account doesn't exist by creating a new account using `EthjsAccount.fromAccountData()`.
</Callout>

#### Deleting Accounts

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.deleteAccount(address)
```

### Contract Management

#### Deploying Contract Code

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Deploy contract bytecode
await stateManager.putContractCode(
  address,
  new Uint8Array([/* bytecode */])
)

// Verify deployment
const code = await stateManager.getContractCode(address)
console.log('Deployed code length:', code.length)
```

#### Reading Contract Code

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
const deployedCode = await stateManager.getContractCode(address)
if (deployedCode.length > 0) {
  console.log('Contract exists with code')
} else {
  console.log('No contract code at address')
}
```

### Storage Management

#### Reading Storage

```ts
import { createAddress, hexToBytes } from 'tevm/utils'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Get a specific storage slot
const slot = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000000')
const value = await stateManager.getContractStorage(address, slot)

// Dump all storage
const storage = await stateManager.dumpStorage(address)
console.log('Contract storage:', storage)
```

#### Writing Storage

```ts
import { createAddress, hexToBytes } from 'tevm/utils'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Set a storage value
const key = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000000')
const value = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001')
await stateManager.putContractStorage(address, key, value)
```

#### Clearing Storage

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.clearContractStorage(address)
```

### State Checkpoints

Tevm uses a checkpoint system to manage state changes atomically:

```ts
import { createAddress, hexToBytes } from 'tevm/utils'
import { EthjsAccount } from 'tevm/utils'

// Create a checkpoint
await stateManager.checkpoint()

try {
  const address = createAddress('0x1234567890123456789012345678901234567890')
  const account = EthjsAccount.fromAccountData({
    nonce: 0n,
    balance: 10_000_000n,
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })

  // Make state changes
  await stateManager.putAccount(address, account)
  await stateManager.putContractStorage(
    address,
    hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001'),
    hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000002')
  )

  // Commit changes if successful
  await stateManager.commit()
} catch (error) {
  // Revert changes on failure
  await stateManager.revert()
  console.error('State changes reverted:', error)
}
```

### State Persistence

#### Dumping State

Export the entire state:

```ts
// Get complete state
const state = await stateManager.dumpCanonicalGenesis()
expect(state).toBeDefined()
```

#### Loading State

Restore state from a previous dump:

```ts
// Restore state
await stateManager.generateCanonicalGenesis(state)
```

### Fork Mode State

When running in fork mode, state is fetched lazily from the remote provider:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'
import { performance } from 'node:perf_hooks'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
  }
})

const vm = await node.getVm()
const stateManager = vm.stateManager
const testAddress = createAddress('0x1234567890123456789012345678901234567890')

// First access fetches from remote
const t0 = performance.now()
await stateManager.getAccount(testAddress)
console.log('Initial fetch:', performance.now() - t0)

// Subsequent access uses cache
const t1 = performance.now()
await stateManager.getAccount(testAddress)
console.log('Cached access:', performance.now() - t1)
```

### Best Practices

1. **Error Handling**
   ```ts
   import { createAddress } from 'tevm/address'

   const testAddress = createAddress('0x1234567890123456789012345678901234567890')
   try {
     const account = await stateManager.getAccount(testAddress)
     if (!account) {
       throw new Error('Account not found')
     }
     // Work with account
   } catch (error) {
     console.error('State operation failed:', error)
   }
   ```

2. **State Isolation**
   ```ts
   // Create isolated copy for testing
   const isolatedState = await stateManager.deepCopy()
   ```

3. **Atomic Operations**
   ```ts
   import { createAddress, hexToBytes } from 'tevm/utils'
   import { EthjsAccount } from 'tevm/utils'

   const testAddress = createAddress('0x1234567890123456789012345678901234567890')
   await stateManager.checkpoint()
   try {
     const account = EthjsAccount.fromAccountData({
       nonce: 0n,
       balance: 10_000_000n,
       storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
       codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
     })

     // Batch multiple state changes
     await Promise.all([
       stateManager.putAccount(testAddress, account),
       stateManager.putContractStorage(
         testAddress,
         hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001'),
         hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000002')
       )
     ])
     await stateManager.commit()
   } catch (error) {
     await stateManager.revert()
   }
   ```

### Related Topics

* [Transaction Processing](../advanced/txpool)
* [Receipts and Logs](../advanced/receipts-and-logs)
* [Forking](./forking)


import { Callout } from 'vocs/components'

## TevmNode Interface

The `TevmNode` interface is the core API surface of Tevm. It provides access to all the fundamental Ethereum node capabilities, from transaction processing to state management.

### Interface Overview

```ts
export type TevmNode<TMode extends 'fork' | 'normal' = 'fork' | 'normal', TExtended = {}> = {
  readonly logger: Logger
  readonly getReceiptsManager: () => Promise<ReceiptsManager>
  readonly miningConfig: MiningConfig
  readonly forkTransport?: { request: EIP1193RequestFn }
  readonly mode: TMode
  readonly ready: () => Promise<true>
  readonly getVm: () => Promise<Vm>
  readonly getTxPool: () => Promise<TxPool>
  readonly getImpersonatedAccount: () => Address | undefined
  readonly setImpersonatedAccount: (address: Address | undefined) => void
  readonly extend: <TExtension>(decorator: (client: TevmNode<TMode, TExtended>) => TExtension) => TevmNode<TMode, TExtended & TExtension>
  readonly setFilter: (filter: Filter) => void
  readonly getFilters: () => Map<Hex, Filter>
  readonly removeFilter: (id: Hex) => void
  status: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
  readonly deepCopy: () => Promise<TevmNode<TMode, TExtended>>
} & EIP1193EventEmitter & TExtended
```

### Core Components

#### 1. Initialization & Status

```ts
const node = createTevmNode()

// Wait for initialization
await node.ready()

// Check status
console.log(node.status) // 'READY'
```

<Callout type="info">
  The `ready()` method ensures all internal components are initialized. While not strictly required (methods will wait implicitly), calling it explicitly can help manage initialization flow.
</Callout>

#### 2. Virtual Machine Access

The VM is the heart of Tevm, providing EVM execution capabilities:

```ts
const node = createTevmNode()
const vm = await node.getVm()

// Execute a transaction
const result = await vm.runTx({
  tx: {
    to: '0x1234...',
    value: 1000000000000000000n, // 1 ETH
    data: '0x...',
  }
})
```

#### 3. Transaction Pool Management

The TxPool handles pending transactions:

```ts
const node = createTevmNode()
const txPool = await node.getTxPool()

// Add a transaction
await txPool.add({
  from: '0x1234...',
  to: '0x5678...',
  value: 1000000000000000000n,
})

// Get pending transactions
const pending = await txPool.txsByPriceAndNonce()
```

#### 4. Receipt & Log Management

Track transaction outcomes and event logs:

```ts
const node = createTevmNode()
const receipts = await node.getReceiptsManager()

// Get receipt for a transaction
const receipt = await receipts.getReceiptByTxHash('0x1234...')

// Query logs
const logs = await receipts.getLogs({
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
})
```

#### 5. Account Impersonation

In fork mode, you can impersonate existing accounts:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

// Now you can send transactions as this account
const vm = await node.getVm()
await vm.runTx({
  tx: {
    from: '0x28C6c06298d514Db089934071355E5743bf21d60',
    to: '0x1234...',
    value: 1000000000000000000n,
  },
})
```

#### 6. Event Filtering

Manage subscriptions to blockchain events:

```ts
// Create a filter for Transfer events
node.setFilter({
  id: '0x1',
  fromBlock: 0n,
  toBlock: 'latest',
  address: '0x1234...',
  topics: [
    '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer
  ],
})

// Get all filters
const filters = node.getFilters()

// Remove a filter
node.removeFilter('0x1')
```

#### 7. Extensibility

The `extend` method allows adding custom functionality:

```ts
// Add custom methods
const enhancedNode = node.extend((baseNode) => ({
  async getBalance(address: string) {
    const vm = await baseNode.getVm()
    const account = await vm.stateManager.getAccount(address)
    return account.balance
  },
}))

// Use the new method
const balance = await enhancedNode.getBalance('0x1234...')
```

#### 8. Deep Copying

Create independent copies of a node:

```ts
const node = createTevmNode()
// ... perform some operations ...

// Create a copy with the same state
const nodeCopy = await node.deepCopy()
```

<Callout type="warning">
  Deep copying creates a completely new instance with its own state. This is useful for testing different scenarios, but can be memory-intensive.
</Callout>

### Best Practices

1. **Initialization**
   ```ts
   const node = createTevmNode()
   await node.ready() // Always wait for ready
   ```

2. **Error Handling**
   ```ts
   try {
     const vm = await node.getVm()
     await vm.runTx(/* ... */)
   } catch (error) {
     if (error.message.includes('insufficient funds')) {
       // Handle specific error cases
     }
     throw error
   }
   ```

3. **Resource Management**
   ```ts
   // Clean up filters when done
   node.getFilters().forEach((_, id) => node.removeFilter(id))
   ```

4. **State Isolation**
   ```ts
   // Use deepCopy for isolated test cases
   const baseNode = createTevmNode()

   test('scenario 1', async () => {
     const node = await baseNode.deepCopy()
     // Test with isolated state
   })
   ```

### Type Safety

The interface is fully typed with TypeScript:

```ts
import type { TevmNode } from 'tevm/node'

function useNode<TMode extends 'fork' | 'normal'>(
  node: TevmNode<TMode>
) {
  if (node.mode === 'fork') {
    // Fork-specific operations
    node.setImpersonatedAccount('0x...')
  }
}
```

### Next Steps

* Learn about [Forking](./forking)
* Explore [State Management](./managing-state)
* See [JSON-RPC Support](../api/json-rpc)


## Building a Debugger UI

This example demonstrates how to create a minimal EVM debugger interface using [Svelte](https://svelte.dev) and Tevm Node. The debugger will show:

* Live opcode execution
* Stack contents
* Memory state
* Error messages
* Gas usage

### Project Setup

First, create a new Svelte project and install dependencies:

```bash
npm create vite@latest tevm-debugger -- --template svelte-ts
cd tevm-debugger
npm install tevm tevm/contract
```

### Components

#### 1. EVMDebugger.svelte

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte'
  import { createTevmNode } from 'tevm/node'
  import type { InterpreterStep } from 'tevm/evm'

  // Store execution state
  let steps: InterpreterStep[] = []
  let currentStep: InterpreterStep | null = null
  let errors: string[] = []
  let gasUsed = 0n
  let isRunning = false

  // Create Tevm Node
  const node = createTevmNode()
  let vm: Awaited<ReturnType<typeof node.getVm>>

  onMount(async () => {
    vm = await node.getVm()
    setupEventListeners()
  })

  function setupEventListeners() {
    // Track execution steps
    vm.evm.events?.on('step', (step, next) => {
      currentStep = step
      steps = [...steps, step]
      next?.()
    })

    // Track errors
    vm.evm.events?.on('afterMessage', (result, next) => {
      if (result.execResult.exceptionError) {
        errors = [...errors, result.execResult.exceptionError.error]
      }
      gasUsed = result.execResult.executionGasUsed
      next?.()
    })
  }

  // Clean up
  onDestroy(() => {
    vm?.evm.events?.removeAllListeners()
  })

  // Execute sample transaction
  async function runSampleTx() {
    isRunning = true
    steps = []
    errors = []

    try {
      await vm.runTx({
        tx: {
          to: '0x1234...',
          data: '0x...',  // Your transaction data
        }
      })
    } catch (error) {
      errors = [...errors, error.message]
    }

    isRunning = false
  }
</script>

<div class="debugger">
  <div class="controls">
    <button on:click={runSampleTx} disabled={isRunning}>
      {isRunning ? 'Running...' : 'Run Transaction'}
    </button>
    <div class="gas">Gas Used: {gasUsed.toString()}</div>
  </div>

  <div class="execution">
    <h3>Current Step</h3>
    {#if currentStep}
      <div class="step">
        <div>PC: {currentStep.pc}</div>
        <div>Opcode: {currentStep.opcode.name}</div>
        <div>Gas Left: {currentStep.gasLeft.toString()}</div>
        <div>Depth: {currentStep.depth}</div>
      </div>
    {/if}
  </div>

  <div class="stack">
    <h3>Stack</h3>
    {#if currentStep?.stack}
      <div class="stack-items">
        {#each currentStep.stack as item}
          <div class="stack-item">{item.toString(16)}</div>
        {/each}
      </div>
    {/if}
  </div>

  <div class="errors">
    <h3>Errors</h3>
    {#each errors as error}
      <div class="error">{error}</div>
    {/each}
  </div>

  <div class="history">
    <h3>Execution History ({steps.length} steps)</h3>
    <div class="steps">
      {#each steps as step}
        <div class="history-step">
          {step.opcode.name} (Gas: {step.gasLeft.toString()})
        </div>
      {/each}
    </div>
  </div>
</div>

<style>
  .debugger {
    padding: 1rem;
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(2, 1fr);
  }

  .controls {
    grid-column: 1 / -1;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  button {
    padding: 0.5rem 1rem;
    background: #4a5568;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .execution, .stack, .errors, .history {
    background: #2d3748;
    padding: 1rem;
    border-radius: 0.5rem;
    color: #e2e8f0;
  }

  .stack-items {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .stack-item {
    font-family: monospace;
    padding: 0.25rem;
    background: #4a5568;
    border-radius: 0.25rem;
  }

  .error {
    color: #fc8181;
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: #742a2a;
    border-radius: 0.25rem;
  }

  .steps {
    height: 200px;
    overflow-y: auto;
  }

  .history-step {
    padding: 0.25rem;
    border-bottom: 1px solid #4a5568;
    font-family: monospace;
  }
</style>
```

#### 2. App.svelte

```svelte
<script lang="ts">
  import EVMDebugger from './lib/EVMDebugger.svelte'
</script>

<main>
  <h1>Tevm Debugger</h1>
  <EVMDebugger />
</main>

<style>
  main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  h1 {
    color: #2d3748;
    margin-bottom: 2rem;
  }
</style>
```

### Advanced Features

#### Memory Viewer Component

```svelte
<script lang="ts">
  export let memory: Uint8Array
  export let startOffset = 0
  export let bytesPerRow = 16

  $: rows = chunk(memory, bytesPerRow)

  function chunk(array: Uint8Array, size: number) {
    const chunks = []
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size))
    }
    return chunks
  }

  function formatByte(byte: number) {
    return byte.toString(16).padStart(2, '0')
  }

  function formatAscii(byte: number) {
    return byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'
  }
</script>

<div class="memory-viewer">
  {#each rows as row, i}
    <div class="memory-row">
      <span class="offset">
        {(startOffset + i * bytesPerRow).toString(16).padStart(8, '0')}:
      </span>
      <span class="hex">
        {#each row as byte}
          {formatByte(byte)}
        {/each}
      </span>
      <span class="ascii">
        {#each row as byte}
          {formatAscii(byte)}
        {/each}
      </span>
    </div>
  {/each}
</div>

<style>
  .memory-viewer {
    font-family: monospace;
    white-space: pre;
  }

  .memory-row {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
  }

  .offset {
    color: #718096;
  }

  .hex {
    letter-spacing: 0.1em;
  }

  .ascii {
    color: #718096;
  }
</style>
```

#### Storage Viewer Component

```svelte
<script lang="ts">
  import type { Address } from 'tevm/utils'
  import { createTevmNode } from 'tevm/node'

  export let address: Address

  let storage = new Map<string, string>()
  let loading = false

  const node = createTevmNode()

  async function loadStorage() {
    loading = true
    try {
      const vm = await node.getVm()
      const dump = await vm.stateManager.dumpStorage(address)
      storage = new Map(Object.entries(dump))
    } catch (error) {
      console.error('Failed to load storage:', error)
    }
    loading = false
  }
</script>

<div class="storage">
  <button on:click={loadStorage} disabled={loading}>
    {loading ? 'Loading...' : 'Load Storage'}
  </button>

  {#if storage.size > 0}
    <div class="storage-items">
      {#each [...storage] as [slot, value]}
        <div class="storage-item">
          <span class="slot">{slot}:</span>
          <span class="value">{value}</span>
        </div>
      {/each}
    </div>
  {/if}
</div>

<style>
  .storage {
    padding: 1rem;
  }

  .storage-items {
    margin-top: 1rem;
  }

  .storage-item {
    display: flex;
    gap: 1rem;
    padding: 0.25rem 0;
    font-family: monospace;
  }

  .slot {
    color: #718096;
  }
</style>
```

### Usage

1. Create the project structure:

```
tevm-debugger/
├── src/
│   ├── lib/
│   │   ├── EVMDebugger.svelte
│   │   ├── MemoryViewer.svelte
│   │   └── StorageViewer.svelte
│   ├── App.svelte
│   └── main.ts
└── package.json
```

2. Run the development server:

```bash
npm run dev
```

3. Use the debugger:

```ts
// Example contract deployment
const bytecode = '0x...' // Your contract bytecode
await vm.runTx({
  tx: {
    data: bytecode
  }
})

// Example contract interaction
await vm.runTx({
  tx: {
    to: '0x...',    // Contract address
    data: '0x...',  // Encoded function call
  }
})
```

### Customization

#### Adding Transaction History

```svelte
<script lang="ts">
  import { writable } from 'svelte/store'

  const transactions = writable<{
    hash: string
    to: string
    data: string
    status: 'success' | 'error'
  }[]>([])

  vm.evm.events?.on('afterMessage', (result, next) => {
    transactions.update(txs => [...txs, {
      hash: result.execResult.hash?.toString() ?? '',
      to: result.execResult.to?.toString() ?? '',
      data: result.execResult.data?.toString('hex') ?? '',
      status: result.execResult.exceptionError ? 'error' : 'success'
    }])
    next?.()
  })
</script>

<div class="transactions">
  <h3>Transaction History</h3>
  {#each $transactions as tx}
    <div class="transaction" class:error={tx.status === 'error'}>
      <div>Hash: {tx.hash}</div>
      <div>To: {tx.to}</div>
      <div>Data: {tx.data}</div>
    </div>
  {/each}
</div>
```

#### Adding Gas Profiling

```svelte
<script lang="ts">
  const gasProfile = new Map<string, { count: number, totalGas: bigint }>()

  vm.evm.events?.on('step', (step, next) => {
    const opName = step.opcode.name
    const gasCost = BigInt(step.opcode.fee)

    const stats = gasProfile.get(opName) ?? { count: 0, totalGas: 0n }
    stats.count++
    stats.totalGas += gasCost
    gasProfile.set(opName, stats)

    next?.()
  })
</script>

<div class="gas-profile">
  <h3>Gas Profile</h3>
  <table>
    <thead>
      <tr>
        <th>Opcode</th>
        <th>Count</th>
        <th>Total Gas</th>
      </tr>
    </thead>
    <tbody>
      {#each [...gasProfile] as [opcode, stats]}
        <tr>
          <td>{opcode}</td>
          <td>{stats.count}</td>
          <td>{stats.totalGas.toString()}</td>
        </tr>
      {/each}
    </tbody>
  </table>
</div>
```

### Related Topics

* [EVM Events](../api/evm-events)
* [Performance Profiler](../advanced/performance-profiler)


## Using with Ethers.js

This guide demonstrates how to use Tevm Node with Ethers.js, enabling seamless integration with the popular Ethereum development library.

### Basic Setup

```ts
import { createTevmNode } from 'tevm'
import { requestEip1193 } from 'tevm/decorators'
import { BrowserProvider } from 'ethers'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Ethers provider
const provider = new BrowserProvider(node)

// Basic provider usage
const block = await provider.getBlockNumber()
const balance = await provider.getBalance('0x1234...')
```

### Contract Interaction

#### 1. Reading Contract State

```ts
import { Contract } from '@tevm/ethers'
import { parseAbi } from 'tevm'

// Contract setup
const abi = parseAbi([
  'function balanceOf(address) view returns (uint256)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
])

const tokenAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' // USDC
const contract = new Contract(tokenAddress, abi, provider)

// Read multiple values
const [balance, symbol, decimals] = await Promise.all([
  contract.balanceOf('0x1234...'),
  contract.symbol(),
  contract.decimals(),
])

console.log(`${symbol} Balance: ${formatUnits(balance, decimals)}`)
```

#### 2. Writing to Contracts

```ts
import { ContractTransactionResponse } from 'ethers'

// Get signer
const signer = await provider.getSigner()

const abi = parseAbi([
  'function transfer(address to, uint256 amount) returns (bool)',
])

const contract = new Contract(tokenAddress, abi, signer)

// Send transaction
const tx = await contract.transfer(
  '0x5678...',
  parseUnits('100', 6)
) as ContractTransactionResponse

// Wait for confirmation
const receipt = await tx.wait()
console.log('Transaction confirmed:', receipt.hash)
```

### Event Handling

#### 1. Listening for Events

```ts
const abi = parseAbi([
  'event Transfer(address indexed from, address indexed to, uint256 value)',
  'function transfer(address to, uint256 amount) returns (bool)',
])

const contract = new Contract(tokenAddress, abi, provider)

// Type-safe event handling
type TransferEvent = {
  from: string
  to: string
  amount: bigint
  event: any
}

const events: TransferEvent[] = []
contract.on('Transfer', (from, to, amount, event) => {
  events.push({ from, to, amount, event })
})

// Remove listener when done
contract.off('Transfer')
```

#### 2. Querying Past Events

```ts
const abi = parseAbi([
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])

const contract = new Contract(tokenAddress, abi, provider)

// Create filter
const filter = contract.filters.Transfer()

// Get past events
const events = await contract.queryFilter(filter, -1000, 'latest')

for (const event of events) {
  const { from, to, value } = event.args
  console.log('Historical transfer:', {
    from,
    to,
    value: formatUnits(value, 6),
  })
}
```

### Advanced Usage

#### 1. Contract Deployment

```ts
import { ContractFactory } from 'ethers'

const abi = parseAbi([
  'function getValue() view returns (uint256)',
])

// Get signer
const signer = await provider.getSigner()

// Create factory
const factory = new ContractFactory(abi, bytecode, signer)

// Deploy contract
const contract = await factory.deploy()
await contract.waitForDeployment()

console.log('Contract deployed to:', await contract.getAddress())
```

#### 2. Low-level Transaction Handling

```ts
// Create transaction
const tx = {
  to: '0x1234...',
  value: parseEther('1'),
  data: '0x',
}

// Sign transaction
const signer = await provider.getSigner()
const signedTx = await signer.signTransaction(tx)

// Send raw transaction
const hash = await provider.send('eth_sendRawTransaction', [signedTx])

// Wait for confirmation
const receipt = await provider.waitForTransaction(hash)
```

#### 3. Interface Encoding/Decoding

```ts
import { Interface } from 'ethers'
import { parseAbi } from 'tevm'

// Create interface
const abi = parseAbi([
  'function transfer(address to, uint256 amount) returns (bool)',
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])
const iface = new Interface(abi)

// Encode function data
const data = iface.encodeFunctionData('transfer', [
  '0x1234...',
  parseUnits('100', 6),
])

// Decode event logs
const log = receipt.logs[0]
const decodedLog = iface.parseLog({
  topics: log.topics,
  data: log.data,
})
```

### Testing with Ethers

```ts
import { expect } from 'chai'
import { loadFixture } from '@nomicfoundation/hardhat-network-helpers'
import { parseAbi } from 'tevm'

describe('Token Contract', () => {
  async function deployTokenFixture() {
    // Setup Tevm Node
    const node = createTevmNode()
    const provider = new BrowserProvider(node)
    const signer = await provider.getSigner()

    const abi = parseAbi([
      'function balanceOf(address) view returns (uint256)',
      'function transfer(address to, uint256 amount) returns (bool)',
    ])

    // Deploy contract
    const factory = new ContractFactory(abi, bytecode, signer)
    const token = await factory.deploy()
    await token.waitForDeployment()

    return { token, signer, provider }
  }

  it('Should handle basic operations', async () => {
    const { token, signer } = await loadFixture(deployTokenFixture)

    // Test initial state
    expect(await token.balanceOf(signer.address)).to.equal(initialSupply)

    // Test transfer
    await token.transfer('0x1234...', 100)
    expect(await token.balanceOf('0x1234...')).to.equal(100)
  })
})
```

### Best Practices

1. **Contract Initialization**:
   ```ts
   import { parseAbi } from 'tevm'
   import { Contract } from '@tevm/ethers'

   // Reuse contract instances
   const contracts = new Map<string, Contract>()

   function getContract(address: string): Contract {
     let contract = contracts.get(address)
     if (!contract) {
       const abi = parseAbi([
         'function balanceOf(address) view returns (uint256)',
         'function transfer(address to, uint256 amount) returns (bool)',
       ])
       contract = new Contract(address, abi, provider)
       contracts.set(address, contract)
     }
     return contract
   }
   ```

2. **Error Handling**:
   ```ts
   const abi = parseAbi([
     'function riskyFunction() returns (uint256)',
   ])
   const contract = new Contract(address, abi, provider)

   try {
     const tx = await contract.riskyFunction()
     await tx.wait()
   } catch (error) {
     if (error.code === 'CALL_EXCEPTION') {
       console.error('Contract call failed:', error.reason)
     } else if (error.code === 'NETWORK_ERROR') {
       console.error('Network error:', error.message)
     }
     throw error
   }
   ```

3. **Gas Management**:
   ```ts
   const abi = parseAbi([
     'function transfer(address to, uint256 amount) returns (bool)',
   ])
   const contract = new Contract(address, abi, provider)

   // Estimate gas with buffer
   const gasEstimate = await contract.transfer.estimateGas(
     recipient,
     amount
   )

   const tx = await contract.transfer(
     recipient,
     amount,
     {
       gasLimit: gasEstimate * 120n / 100n, // 20% buffer
     }
   )
   ```

4. **Event Management**:
   ```ts
   const abi = parseAbi([
     'event Transfer(address indexed from, address indexed to, uint256 value)',
   ])
   const contract = new Contract(address, abi, provider)

   // Clean up listeners
   function setupEventListeners(contract: Contract) {
     const handler = (...args) => {
       // Handle event
     }

     contract.on('Transfer', handler)

     return () => {
       contract.off('Transfer', handler)
     }
   }

   const cleanup = setupEventListeners(contract)
   // Later...
   cleanup()
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [Local Testing](./local-testing)
* [Forking Mainnet](./forking-mainnet)


## Forking Mainnet Example

### Basic Fork Setup

```ts
import { createTevmNode } from 'tevm'
import { http } from 'viem'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 17_000_000n,
  },
  loggingLevel: 'debug',
})

await node.ready()

// Now any calls to an unknown account or contract
// will fetch the data from mainnet, but store the result locally for caching.
```

### Account Impersonation

```ts
// Impersonate a whale account
node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60') // Binance 14

// Now you can run transactions "as" that address, no signature needed
const tx = createImpersonatedTx({
  to: '0x1234...',
  value: 1000000000000000000n, // 1 ETH
})

const vm = await node.getVm()
await vm.runTx({ tx })
```

### Working with Forked Contracts

```ts
// Example: Interacting with USDC on mainnet
const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

// Get the contract state from mainnet
const usdcContract = new Contract(USDC_ADDRESS, USDC_ABI)
const balance = await usdcContract.read.balanceOf(['0x1234...'])

// Modify state locally
await usdcContract.write.transfer(['0x5678...', 1000000]) // 1 USDC

// Changes only affect your local fork
const newBalance = await usdcContract.read.balanceOf(['0x1234...'])
```

### Fork at Specific Block

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/<yourkey>'),
    blockTag: 15_000_000n, // Fork from a specific block
  },
})

// Test historical state
const historicalBalance = await getBalance(address)
```

### Multiple Network Support

```ts
// Fork from different networks
const optimismNode = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io'),
  },
})

const arbitrumNode = createTevmNode({
  fork: {
    transport: http('https://arb1.arbitrum.io/rpc'),
  },
})
```

**Related**

* [Forking Guide](../core/forking)
* [State Management](../core/managing-state)
* [JSON-RPC Support](../api/json-rpc)


## Local Testing

This guide demonstrates how to use Tevm Node for local testing of [smart contracts](https://ethereum.org/en/developers/docs/smart-contracts/) and [transactions](https://ethereum.org/en/developers/docs/transactions/). For more background on testing Ethereum applications, see the [Smart Contract Testing Guide](https://ethereum.org/en/developers/docs/smart-contracts/testing/).

### Basic Test Setup

```ts
import { createTevmNode } from 'tevm'
import { createImpersonatedTx } from 'tevm/tx'
import { expect, test } from 'vitest' // or jest, mocha, etc.

test('Basic ETH transfer', async () => {
  // Create a new node instance
  const node = createTevmNode({
    miningConfig: { type: 'auto' }, // Mine blocks automatically
  })
  await node.ready()

  const vm = await node.getVm()

  // Create and run a transaction
  const tx = createImpersonatedTx({
    from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    value: 1000000000000000000n, // 1 ETH
  })

  const result = await vm.runTx({ tx })

  // Assert transaction succeeded
  expect(result.execResult.exceptionError).toBeUndefined()

  // Check recipient balance
  const account = await vm.stateManager.getAccount(tx.to)
  expect(account.balance).toBe(1000000000000000000n)
})
```

For more information on transaction execution, see the [EVM Execution Model](https://ethereum.org/en/developers/docs/evm/execution/).

### Contract Testing

#### 1. Deployment & Interaction

For background on contract deployment and interaction, see the [Contract Deployment Guide](https://ethereum.org/en/developers/docs/smart-contracts/deploying/).

```ts
import { Contract } from 'tevm/contract'
import { bytecode, abi } from './MyContract.json'

test('Deploy and interact with contract', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Deploy contract
  const deployTx = createImpersonatedTx({
    data: bytecode,
  })

  const result = await vm.runTx({ tx: deployTx })
  expect(result.execResult.exceptionError).toBeUndefined()

  const contractAddress = result.createdAddress
  expect(contractAddress).toBeDefined()

  // Create contract instance
  const contract = new Contract(contractAddress, abi)

  // Call contract method
  const callResult = await contract.read.getValue()
  expect(callResult).toBe(expectedValue)

  // Send transaction to contract
  const tx = await contract.write.setValue([newValue])
  const txResult = await vm.runTx({ tx })
  expect(txResult.execResult.exceptionError).toBeUndefined()

  // Verify state change
  const updatedValue = await contract.read.getValue()
  expect(updatedValue).toBe(newValue)
})
```

#### 2. Event Testing

For more information on events and logs, see the [Events and Logs Guide](https://ethereum.org/en/developers/docs/smart-contracts/anatomy/#events-and-logs).

```ts
test('Contract events', async () => {
  const node = createTevmNode()
  await node.ready()

  // Deploy contract
  const contract = await deployContract(node)

  // Create event filter
  node.setFilter({
    id: '0x1',
    address: contract.address,
    topics: [
      contract.interface.getEventTopic('ValueChanged'),
    ],
  })

  // Trigger event
  const tx = await contract.write.setValue([123])
  await vm.runTx({ tx })

  // Get event logs
  const receipts = await node.getReceiptsManager()
  const logs = await receipts.getLogs({
    fromBlock: 0n,
    toBlock: 'latest',
    address: contract.address,
  })

  expect(logs.length).toBe(1)
  expect(logs[0].topics[0]).toBe(contract.interface.getEventTopic('ValueChanged'))
})
```

### Complex Testing Scenarios

#### 1. State Management

For more information on state management, see the [Ethereum State Guide](https://ethereum.org/en/developers/docs/evm/state-machine/).

```ts
test('Complex state changes', async () => {
  const node = createTevmNode()
  await node.ready()
  const vm = await node.getVm()

  // Create checkpoint
  await vm.stateManager.checkpoint()

  try {
    // Perform multiple state changes
    await performStateChanges(vm)

    // Verify intermediate state
    const intermediateState = await getState(vm)
    expect(intermediateState).toMatchSnapshot()

    // More changes
    await performMoreChanges(vm)

    // Commit changes
    await vm.stateManager.commit()
  } catch (error) {
    // Revert on failure
    await vm.stateManager.revert()
    throw error
  }
})
```

#### 2. Fork Testing

For more information on network forking, see the [Forking Guide](../core/forking).

```ts
test('Mainnet fork testing', async () => {
  const node = createTevmNode({
    fork: {
      transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
      blockTag: 17_000_000n,
    },
  })
  await node.ready()

  // Impersonate a whale account
  node.setImpersonatedAccount('0x28C6c06298d514Db089934071355E5743bf21d60')

  // Test DeFi interactions
  const uniswap = new Contract(UNISWAP_ADDRESS, UNISWAP_ABI)
  const tx = await uniswap.write.swapExactTokensForTokens([/* ... */])

  const result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

#### 3. Time-based Testing

For more information on block timestamps and time-based operations, see the [Block Time Guide](https://ethereum.org/en/developers/docs/blocks/blocks-and-time/).

```ts
test('Time-dependent behavior', async () => {
  const node = createTevmNode({
    miningConfig: { type: 'interval', interval: 1000 },
  })
  await node.ready()
  const vm = await node.getVm()

  // Deploy time-locked contract
  const contract = await deployTimeLock(vm)

  // Try to withdraw (should fail)
  let tx = await contract.write.withdraw()
  let result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeDefined()

  // Advance time by mining blocks
  for (let i = 0; i < 100; i++) {
    await vm.blockchain.putBlock(createBlock({ timestamp: Date.now() + i * 1000 }))
  }

  // Try withdraw again (should succeed)
  tx = await contract.write.withdraw()
  result = await vm.runTx({ tx })
  expect(result.execResult.exceptionError).toBeUndefined()
})
```

### Testing Utilities

#### 1. Account Management

For more information on Ethereum accounts, see the [Accounts Guide](https://ethereum.org/en/developers/docs/accounts/).

```ts
// Helper to setup test accounts
async function setupAccounts(vm) {
  const accounts = [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  ]

  for (const address of accounts) {
    await vm.stateManager.putAccount(address, {
      nonce: 0n,
      balance: 10000000000000000000n, // 10 ETH
    })
  }

  return accounts
}
```

#### 2. Transaction Helpers

For more information on transaction types and formats, see the [Transaction Types Guide](https://ethereum.org/en/developers/docs/transactions/transaction-types/).

```ts
// Helper to send ETH
async function sendEth(vm, from, to, value) {
  const tx = createImpersonatedTx({
    from,
    to,
    value,
  })

  return vm.runTx({ tx })
}

// Helper to deploy contract
async function deployContract(vm, bytecode, args = []) {
  const tx = createImpersonatedTx({
    data: bytecode + encodeConstructor(args),
  })

  const result = await vm.runTx({ tx })
  return result.createdAddress
}
```

### Related Topics

* [Viem Testing Guide](https://viem.sh/docs/testing/overview.html)
* [EthereumJS VM](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/vm)
* [JSON-RPC Methods](../api/json-rpc)
* [Contract API](../api/contracts)
* [State Management](../core/managing-state)

### Replaying Contracts with Shadow Events

```ts
import { createTevmNode } from 'tevm'
import { http } from 'viem'

// Create a node that forks from mainnet
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
  },
})

// Get the transaction receipt to find its index
const receipt = await node.request({
  method: 'eth_getTransactionReceipt',
  params: ['0x...'] // Original tx hash
})

// Get the block and its transactions
const block = await node.request({
  method: 'eth_getBlockByNumber',
  params: [(receipt.blockNumber - 1n).toString(16), true]
})

// Replay all transactions before our target tx
for (let i = 0; i < receipt.transactionIndex; i++) {
  const tx = block.transactions[i]
  await node.getVm().runTx({ tx })
}

// Deploy modified contract with new event
const modifiedBytecode = '0x...' // Contract bytecode with new event
await node.setAccount({
  address: receipt.contractAddress,
  deployedBytecode: modifiedBytecode
})

// Now run the target transaction
const result = await node.getVm().runTx({
  tx: block.transactions[receipt.transactionIndex]
})

// The result will include the new shadow event
console.log(result.execResult.logs)
```

### Estimating Gas for Token Approval

```ts
import { createTevmNode } from 'tevm/node'
import { encodeFunctionData } from 'viem'

const node = createTevmNode()
const vm = await node.getVm()

// First approve the token
const approveTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'approve',
    args: [spenderAddress, amount]
  })
}

// Estimate gas by running the tx
const result = await vm.runTx({ tx: approveTx })
console.log('Gas used:', result.execResult.executionGasUsed)

// Now we can estimate transferFrom
const transferFromTx = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20ABI,
    functionName: 'transferFrom',
    args: [ownerAddress, recipientAddress, amount]
  })
}

const transferResult = await vm.runTx({ tx: transferFromTx })
console.log('TransferFrom gas:', transferResult.execResult.executionGasUsed)
```


## Using with Viem

This guide demonstrates how to use Tevm Node with Viem, enabling seamless integration with Viem's powerful Ethereum development tools.

### Basic Setup

```ts
import { createTevmNode } from 'tevm/node'
import { requestEip1193 } from 'tevm/decorators'
import { createPublicClient, custom, parseAbi } from 'viem'
import { mainnet } from 'viem/chains'

// Create Tevm Node with EIP-1193 support
const node = createTevmNode().extend(requestEip1193())

// Create Viem client
const client = createPublicClient({
  chain: mainnet,
  transport: custom(node),
})

// Now viemClient can do e.g. getBalance, readContract, etc,
// all fully in memory or forking from node if you configured it
```

### Reading Blockchain State

#### 1. Basic State Queries

```ts
// Get latest block
const block = await client.getBlock()

// Get balance
const balance = await client.getBalance({
  address: '0x1234...',
})

// Get transaction count
const nonce = await client.getTransactionCount({
  address: '0x1234...',
})
```

#### 2. Contract Reading

```ts
const abi = parseAbi([
  'function balanceOf(address) view returns (uint256)',
  'function symbol() view returns (string)',
  'event Transfer(address indexed from, address indexed to, uint256 value)',
])

const tokenContract = {
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
  abi,
} as const

const [balance, symbol] = await Promise.all([
  client.readContract({
    ...tokenContract,
    functionName: 'balanceOf',
    args: ['0x1234567890123456789012345678901234567890'],
  }),
  client.readContract({
    ...tokenContract,
    functionName: 'symbol',
  }),
])

console.log(`${symbol} Balance:`, balance)
```

### Writing to the Blockchain

#### 1. Transaction Simulation

```ts
// Simulate contract interaction
const { request } = await client.simulateContract({
  address: contractAddress,
  abi,
  functionName: 'transfer',
  args: ['0x1234...', 1000000n],
})

// Execute the transaction
const hash = await client.writeContract(request)

// Wait for confirmation
const receipt = await client.waitForTransactionReceipt({ hash })
```

#### 2. Raw Transactions

```ts
// Send ETH
const hash = await client.sendTransaction({
  to: '0x1234...',
  value: parseEther('1'),
})

// Send raw transaction
const hash2 = await client.sendRawTransaction({
  serializedTransaction: '0x...',
})
```

### Event Handling

#### 1. Reading Past Events

```ts
const tokenAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
const transferEvent = parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)'])[0]

const logs = await client.getLogs({
  address: tokenAddress,
  event: transferEvent,
  fromBlock: 0n,
  toBlock: 'latest',
})

for (const log of logs) {
  console.log('Transfer:', {
    from: log.args?.from,
    to: log.args?.to,
    value: log.args?.value,
  })
}
```

#### 2. Event Filtering

```ts
const tokenAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
const transferEvent = parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)'])[0]

const filter = await client.createEventFilter({
  address: tokenAddress,
  event: transferEvent,
})

const newEvents = await client.getFilterChanges({ filter })
```

#### 3. Gas Estimation

```ts
const abi = parseAbi([
  'function transfer(address to, uint256 amount) returns (bool)',
])

const gas = await client.estimateContractGas({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  abi,
  functionName: 'transfer',
  args: ['0x1234567890123456789012345678901234567890', 1000000n],
})
```

### Advanced Usage

#### 1. Multiple Contract Interactions

```ts
// Batch contract reads
const results = await Promise.all([
  client.readContract({
    address: token1Address,
    abi: TOKEN_ABI,
    functionName: 'balanceOf',
    args: [address],
  }),
  client.readContract({
    address: token2Address,
    abi: TOKEN_ABI,
    functionName: 'balanceOf',
    args: [address],
  }),
])

// Multicall
const multicallResult = await client.multicall({
  contracts: [
    {
      address: token1Address,
      abi: TOKEN_ABI,
      functionName: 'balanceOf',
      args: [address],
    },
    {
      address: token2Address,
      abi: TOKEN_ABI,
      functionName: 'balanceOf',
      args: [address],
    },
  ],
})
```

#### 2. Contract Deployment

```ts
// Deploy contract
const hash = await client.deployContract({
  abi,
  bytecode,
  args: [constructorArg1, constructorArg2],
})

// Get contract address
const receipt = await client.waitForTransactionReceipt({ hash })
const contractAddress = receipt.contractAddress
```

#### 3. Gas Estimation

```ts
// Estimate gas for contract deployment
const gas = await client.estimateContractGas({
  abi,
  bytecode,
  args: [constructorArg1, constructorArg2],
})

// Estimate gas for contract call
const gas2 = await client.estimateContractGas({
  address: contractAddress,
  abi,
  functionName: 'transfer',
  args: ['0x1234...', 1000000n],
})
```

### Testing with Viem

```ts
import { expect, test } from 'vitest'

test('Contract interaction', async () => {
  // Setup Tevm Node
  const node = createTevmNode()
  const client = createPublicClient({
    chain: mainnet,
    transport: custom(node),
  })

  // Deploy contract
  const hash = await client.deployContract({
    abi,
    bytecode,
  })
  const receipt = await client.waitForTransactionReceipt({ hash })
  const contractAddress = receipt.contractAddress

  // Test contract
  const result = await client.readContract({
    address: contractAddress,
    abi,
    functionName: 'getValue',
  })

  expect(result).toBe(expectedValue)
})
```

### Best Practices

1. **Error Handling**:
   ```ts
   try {
     const result = await client.readContract({
       address,
       abi,
       functionName: 'riskyFunction',
     })
   } catch (error) {
     if (error.message.includes('revert')) {
       // Handle contract revert
     }
     throw error
   }
   ```

2. **Gas Management**:
   ```ts
   // Always estimate gas before sending transactions
   const gas = await client.estimateContractGas({
     address,
     abi,
     functionName: 'transfer',
     args: [to, amount],
   })

   const hash = await client.writeContract({
     address,
     abi,
     functionName: 'transfer',
     args: [to, amount],
     gas: gas * 120n / 100n, // Add 20% buffer
   })
   ```

3. **Transaction Confirmation**:
   ```ts
   // Wait for sufficient confirmations
   const receipt = await client.waitForTransactionReceipt({
     hash,
     confirmations: 2,
     timeout: 60_000,
   })
   ```

4. **Resource Cleanup**:
   ```ts
   // Clean up filters when done
   const filter = await client.createEventFilter({
     address,
     event: parseAbi(['event Transfer(...)']),
   })

   try {
     // Use filter
   } finally {
     await client.uninstallFilter({ filter })
   }
   ```

### Related Topics

* [JSON-RPC Support](../api/json-rpc)
* [Local Testing](./local-testing)
* [Forking Mainnet](./forking-mainnet)


## Architecture Overview

### What is Tevm Node?

[Tevm Node](https://github.com/evmts/tevm-monorepo) is a JavaScript implementation of an Ethereum node that can run in any JavaScript environment - browsers, Node.js, or other runtimes. It provides a complete [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/) with state management, transaction processing, and JSON-RPC support.

### What can you do with Tevm Node?

Tevm has a lot of use cases many which are covered in the examples section

1. Anything viem can do as tevm is an extension of viem's capabilities
2. Simulate blocks and transactions locally. Hook directly into evm execution
3. Estimate gas with no network requests and no loading setupEventListeners
4. Build an EVM simulator like [svvy.sh](https://svvy.sh)
5. Test your JavaScript against an anvil compatible fork in JavaScript
6. Debug evm tx step by step
7. Optimistic ui updates when tx are sent
8. And more!

### Core Architecture

Tevm Node is built on several key components that work together:

#### 1. Virtual Machine (EVM)

* Core execution engine that runs [EVM bytecode](https://ethereum.org/en/developers/docs/evm/opcodes/)
* Handles state transitions and gas metering
* Based on [`@ethereumjs/evm`](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm)

See [evm docs](../api/evm.mdx) for api info

#### 2. State Manager

* Manages account balances, contract code, and storage
* Supports forking from live networks
* Implements caching and lazy loading

See [state docs](../api/state.mdx) for api info

#### 3. Transaction Pool (Mempool)

* Manages pending transactions
* Orders transactions by gas price
* Validates transaction requirements

See [TxPool docs](../api/txpool.mdx) for api info

#### 4. Blockchain

* Maintains block history and chain state
* Handles block production (mining)
* Manages chain reorganizations

See [Blockchain docs](../api/blockchain.mdx) for api info

#### 5. Receipts Manager

* Caches transaction outcomes
* Manages event logs and filters
* Useful for implementing optimistic updates

See [Receipts Manager docs](../api/receipt-manager.mdx) for api info

### Available APIs

Tevm Node provides several layers of APIs for different use cases:

#### 1. High-Level Actions

Most functionality in Tevm is done via tree shakable actions including JSON-RPC compatabile actions.

The most commonly used actions are provided as handlers:

```ts
import { createTevmNode } from 'tevm'
import { callHandler, mineHandler, getAccountHandler } from 'tevm/actions'

// Create a Tevm node
const node = createTevmNode()

// Execute contract calls
const result = await callHandler(node)({
  to: contractAddress,
  data: calldata
})

// Mine pending transactions
await mineHandler(node)()

// Read account state
const account = await getAccountHandler(node)({
  address: accountAddress
})
```

#### 2. JSON-RPC Interface

```ts
import { requestEip1193 } from 'tevm/decorators'

const node = createTevmNode().extend(requestEip1193())

// Standard Ethereum JSON-RPC calls
const balance = await node.request({
  method: 'eth_getBalance',
  params: [address, 'latest']
})
```

#### 3. Direct VM Access

```ts
const vm = await node.getVm()

// Low-level EVM execution
const result = await vm.runTx({
  tx: transaction,
  block: block
})

// State management
await vm.stateManager.putAccount(address, account)
```

#### 4. Contract Utilities

```ts
import { createContract } from 'tevm/contract'

// Type-safe contract interactions
const contract = createContract({
  humanReadableAbi: abi,
  address: contractAddress
})

const action = contract.write.transfer(to, amount)
```

Note, you can optionally compile these contracts automatically in a typesafe way using the tevm bundler (docs coming soon)

```typescript
// import solidity direction to create a contract
import {MyContract} from './MyContract.sol'

console.log(MyContract.abi)
```

### Key Features

#### 1. Forking

Fork from any live network or another Tevm instance:

```ts
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY'),
    blockTag: 'latest'
  }
})
```

#### 2. Mining Modes

Configure how transactions are processed:

```ts
const node = createTevmNode({
  miningConfig: {
    type: 'auto' // Mine every transaction
    // Or 'interval', 'manual', 'gas'
  }
})
```

#### 3. Custom Precompiles

Extend the EVM with JavaScript functions:

```ts
const precompile = definePrecompile({
  address: '0x123...',
  call: async (input) => {
    // Custom logic
    return {
      returnValue: result,
      executionGasUsed: 100n
    }
  }
})
```

#### 4. State Management

Direct control over blockchain state:

```ts
// Modify account state
await node.setAccount({
  address: '0x123...',
  balance: 100n,
  code: '0x...',
  storage: { /* ... */ }
})

// Create checkpoints
await vm.stateManager.checkpoint()
await vm.stateManager.commit() // or .revert()
```

### Common Use Cases

1. **Local Development**
   * Run a complete Ethereum environment locally
   * Test contracts without external networks
   * Simulate complex scenarios

2. **Testing**
   * Unit test smart contracts
   * Integration test DApp interactions
   * Fork mainnet for realistic tests

3. **Transaction Simulation**
   * Preview transaction outcomes
   * Estimate gas costs accurately
   * Debug failed transactions

4. **State Manipulation**
   * Modify account balances
   * Override contract state
   * Test edge cases

### Integration Examples

#### With Viem

```ts
import { createPublicClient, custom } from 'viem'

const client = createPublicClient({
  transport: custom(node.request)
})
```

#### With Ethers.js

```ts
import { BrowserProvider } from 'ethers'

const provider = new BrowserProvider(node)
```

### Next Steps

* [Installation & Quickstart](../introduction/installation)
* [Core Concepts](../core/create-tevm-node)
* [API Reference](../api/methods)
* [Examples](../examples/local-testing)


## Installation & Quickstart

### 1. Install

```sh
npm install tevm

# or
yarn add tevm

# or
pnpm add tevm

# or
bun add tevm
```

### 2. Quick Start

```ts
import { createTevmNode } from 'tevm'

// Create an instance
const node = createTevmNode()

// Access the internal VM once it is ready
const vm = await node.getVm()

// Perform an method on the vm or one of it's subcomponents like blockchain
console.log(await vm.blockchain.getBlockByTag('latest'))
```

### 3. Next Steps

* Explore the [Core Concepts](../core/create-tevm-node)
* Check out [Examples](../examples/local-testing)


## What is Tevm Node?

Tevm Node is an in-browser & Node.js-compatible Ethereum Node. It provides a complete Ethereum Virtual Machine (EVM) execution environment, powered by JavaScript, that you can run:

* **In Node.js** for local or CI testing.
* **In the Browser** for advanced user experiences (offline, real-time simulation, etc.).
* **In Deno, Bun**, or any modern JS environment.

### Key Features

* **Forking:** Simulate mainnet or testnet state from a live RPC, similar to Hardhat or Anvil but running in browser and more functionality.
* **TxPool (Mempool):** Keep track of unmined transactions locally.
* **Mining Config:** Choose between auto mining, interval-based mining, manual, or gas-limit-based mining.
* **Zero dependencies on native modules** – works seamlessly in the browser.
* **Extendable:** Hook into the VM, custom precompiles, receipts, and more.

### Hello World Example

This example forks optimism then reads block data using `vm.blockchain`

```ts
import { createTevmNode, http } from 'tevm'

// Create a node that forks from Optimism
const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.optimism.io')
  }
})

const vm = await node.getVm()

console.log(await vm.blockchain.getBlockByTag('latest'))
```

### Motivations / Why Tevm Node

* **Browser/Local Execution** for improved latency & advanced debugging.
* **Optimistic updates**: Inspect tx side effects before on-chain mining.
* **Lightweight**: Slashes overhead vs. running a full geth or anvil node.
* **Network independence**: Freed from real chain constraints in your applications.

### Next Steps

* [Why run Ethereum in JavaScript?](./why-run-ethereum-in-js)
* [Installation & Quickstart](./installation)


## Why run Ethereum in JavaScript?

### 1. Advanced Gas Estimation & Local Execution

Running the EVM locally removes round-trip latency to a remote node. You can do:

* Bulk simulation or multi-tx simulation
* Real-time "dry run" of transactions
* Faster dev/test cycles

### 2. User Experience Enhancements

* **Offline** or *local-first* capabilities
* **Optimistic UI** updates with local simulation
* No reliance on ephemeral test networks

### 3. Testing & Debugging

* Fine-grained EVM introspection
* Deterministic environment
* Light footprint – no external server needed

### 4. Ecosystem & Portability

* Portable across Node.js, browsers, and serverless
* Works with standard EVM interfaces
* Integrates well with modern JS/TS tooling

