---
title: Contract Loader
description: Access contract ABIs and bytecode from on-chain contracts through Tevm's Contract Loader functionality
---

import { Callout, Steps } from 'vocs/components'
import { TabGroup } from '../../../components'

# Contract Loader

<Callout type="warning" emoji="üöß">
  **Coming Soon**: The Contract Loader is currently under development and not yet available in the latest released version. This documentation outlines the planned API design for the upcoming feature.
</Callout>

<Callout type="info" emoji="üîç">
  The Contract Loader will provide a convenient way to analyze contract bytecode, discover function selectors, and resolve proxy contracts - all through the familiar Tevm API.
</Callout>

## Overview

Contract Loaders are powerful [actions](/reference/actions) that can extract ABI information from contract bytecode, even for unverified contracts. Powered by [WhatsABI](https://github.com/shazow/whatsabi), Tevm's Contract Loader can be used both as [runtime actions](#usage) and as [buildtime macros](#network-imports-via-macros), allowing you to:

- Discover function selectors from bytecode
- Look up function signatures from selectors
- Automatically resolve proxy contracts
- Access verified contract ABIs from Sourcify, Etherscan, and other sources

<div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1rem', margin: '1rem 0'}}>
  <div style={{border: '1px solid var(--vocs-border-color)', borderRadius: '8px', padding: '1rem'}}>
    <h3>üß© Works with Unverified Contracts</h3>
    <p>Extract function selectors directly from bytecode</p>
  </div>
  <div style={{border: '1px solid var(--vocs-border-color)', borderRadius: '8px', padding: '1rem'}}>
    <h3>üîÑ Resolves Proxy Implementations</h3>
    <p>Automatically detects and follows proxy patterns</p>
  </div>
  <div style={{border: '1px solid var(--vocs-border-color)', borderRadius: '8px', padding: '1rem'}}>
    <h3>üìö Uses Multiple Sources</h3>
    <p>Combines Sourcify, Etherscan and bytecode analysis</p>
  </div>
  <div style={{border: '1px solid var(--vocs-border-color)', borderRadius: '8px', padding: '1rem'}}>
    <h3>üõ†Ô∏è Fully Typed API</h3>
    <p>Complete TypeScript support for parameters and results</p>
  </div>
</div>

## Usage

<TabGroup items={['Tree-shakable API', 'Client Extension API']}>
  <div data-title="Tree-shakable API">
    ```ts showLineNumbers {1,3-4,7-10,12-13} filename="contract-loader-example.ts"
    import { loadContract, createMemoryClient, http } from 'tevm'
    import { MultiABILoader, EtherscanABILoader, SourcifyABILoader } from 'tevm/contract-loaders'
    
    const client = createMemoryClient({ // [!code focus]
      fork: { transport: http('https://mainnet.optimism.io') } // [!code focus]
    })
    
    // loadContract returns a fully typed Contract instance // [!code focus]
    const contract = await loadContract(client, { // [!code focus]
      address: '0x00000000006c3852cbEf3e08E8dF289169EdE581', // Seaport contract // [!code focus]
      followProxies: true, // [!code focus]
      // Use multiple loaders to find ABIs from different sources
      loaders: [
        new SourcifyABILoader(),
        new EtherscanABILoader({ apiKey: 'YOUR_ETHERSCAN_KEY' })
      ]
    })
    
    // Contract is a fully typed Tevm contract instance // [!code focus]
    console.log(`Contract address: ${contract.address}`) // [!code focus]
    console.log(`Contract has ${contract.abi.length} ABI entries`) // [!code focus]
    
    // Use the contract for type-safe interactions
    const owner = await client.readContract({
      ...contract.read.owner(),
      address: contract.address
    })
    ```
  </div>
  
  <div data-title="Client Extension API">
    ```ts showLineNumbers {1-2,4-6,9-14,16-21} filename="contract-loader-extension.ts"
    import { createClient, contractLoaderExtension } from 'tevm' // [!code focus]
    import { http } from 'viem' // [!code focus]
    import { BlockscoutABILoader } from 'tevm/contract-loaders' // [!code focus]
    
    const client = createClient({ // [!code focus]
      transport: http('https://mainnet.optimism.io') // [!code focus]
    }).extend(contractLoaderExtension()) // [!code focus]
    
    // Now available as a method on the client // [!code focus]
    const contract = await client.loadContract({ // [!code focus]
      address: '0x00000000006c3852cbEf3e08E8dF289169EdE581', // [!code focus]
      followProxies: true, // [!code focus]
      loaders: [new BlockscoutABILoader({ // [!code focus]
        apiKey: 'YOUR_BLOCKSCOUT_KEY', // [!code focus]
      })] // [!code focus]
    }) // [!code focus]
    
    // Contract is a Tevm Contract instance // [!code focus]
    // Use it with client methods for type-safe interactions // [!code focus]
    const balance = await client.readContract({ // [!code focus]
      ...contract.read.balanceOf('0x123...'), // [!code focus]
      address: contract.address // [!code focus]
    }) // [!code focus]
    ```
  </div>
</TabGroup>

## Network Imports via Macros

One of the most powerful features of Contract Loader in Tevm is the ability to import contracts from any network at build time using macros.

<Callout type="info" emoji="üîß">
  Build-time macros provide better performance and stronger type safety compared to runtime imports, as they avoid network requests during application execution.
</Callout>

### Creating Contract Macros

First, create a file that exports functions using loadContract to resolve contract data:

```ts showLineNumbers filename="contract-macros.js"
import { createClient } from 'tevm'
import { http } from 'viem'
import { mainnet } from 'viem/chains'
import { loadContract } from 'tevm'
import { EtherscanABILoader, SourcifyABILoader } from 'tevm/contract-loaders'

// Create client for the network
const client = createClient({
  chain: mainnet,
  transport: http('https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY')
})

// Configure loaders
const loaders = [
  new SourcifyABILoader(),
  new EtherscanABILoader({ apiKey: 'YOUR_ETHERSCAN_KEY' })
]

// Export a function that returns a single contract
export async function usdcContract() {
  return loadContract(client, {
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on Ethereum
    followProxies: true,
    loaders
  })
}

// Export a different contract (one macro function per contract)
export async function wethContract() {
  return loadContract(client, {
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH on Ethereum
    followProxies: true,
    loaders
  })
}
```

### Using Contract Macros

Then import the contracts with `with {type: 'macro'}` attribute:

```ts showLineNumbers filename="app.js"
// Import contracts using macros
import { usdcContract } from './contract-macros.js' with { type: 'macro' }
import { wethContract } from './contract-macros.js' with { type: 'macro' }
import { createMemoryClient } from 'tevm'

// Create client for local interaction
const client = createMemoryClient()

// Use the contracts with full type safety
const usdcBalance = await client.readContract({
  ...usdcContract.read.balanceOf('0x123...'),
  address: usdcContract.address
})

// WETH contract methods are fully typed
const wethDeposit = await client.writeContract({
  ...wethContract.write.deposit(),
  value: 1000000000000000000n
})
```

<Callout type="warning">
  For security reasons, macros in third-party packages (node_modules) are blocked. Package authors should pre-build their contracts before publishing.
</Callout>

### How Macros Work

<Steps>
### 1. Build-Time Execution

When your bundler encounters an import with `type: 'macro'`, it executes the imported function during the build process.

### 2. Contract Resolution

The function uses WhatsABI to fetch and analyze the contract from the blockchain, resolving ABIs and following any proxies.

### 3. Static Code Generation

The bundler replaces the import with statically generated code that includes the full contract ABI and metadata.

### 4. Type Generation

TypeScript types are generated for all contract methods, events, and properties, ensuring full type safety.
</Steps>

### Benefits of Macros

- **Build-time resolution** - No network requests during application runtime
- **Full type safety** - Complete TypeScript types for all contract methods
- **Proxy resolution** - Automatically resolves and follows proxy implementations
- **Works with unverified contracts** - Uses bytecode analysis when sources aren't available
- **IDE integration** - Autocompletion and hover documentation for contract methods

## How It Works

<Steps>
### 1. Bytecode Analysis

WhatsABI extracts function selectors from the contract's bytecode by analyzing jump tables and other bytecode patterns. This works for any contract, even if it's not verified on block explorers.

### 2. Signature Lookup

The extracted function selectors are looked up in signature databases to match known function signatures. This helps identify common functions like `transfer`, `approve`, etc.

### 3. Proxy Detection

WhatsABI checks for common proxy patterns (ERC-1967, Transparent, Beacon, etc.) and can automatically resolve and follow these implementations.

### 4. On-chain Source Verification

WhatsABI attempts to find verified contract sources from Sourcify, Etherscan, and other sources based on the client's chain ID.
</Steps>

## Parameters

The `loadContract` action accepts the following parameters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `address` | `Address` | **Required**. The contract address to analyze |
| `followProxies` | `boolean` | Whether to automatically follow proxy contracts. Default: `false` |
| `loaders` | `ABILoader[]` | Array of ABI loaders to use for resolving contract ABIs. See [Available Loaders](#available-loaders) |
| `enableExperimentalMetadata` | `boolean` | Whether to include experimental metadata like event topics. Default: `false` |
| `signatureLookup` | `SignatureLookup \| false` | Custom signature lookup or `false` to disable. Default: uses WhatsABI's default lookup |
| `onProgress` | `(phase: string, ...args: any[]) => void` | Progress callback |
| `onError` | `(phase: string, error: Error) => boolean \| void` | Error callback |

## Return Value

The action returns a full [Tevm Contract](/reference/contract) instance with the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `abi` | `Abi` | The resolved ABI from bytecode or verified sources |
| `address` | `Address` | The contract address (may be different if proxies were followed) |
| `read` | `Object` | Type-safe read methods for view/pure functions |
| `write` | `Object` | Type-safe write methods for state-changing functions |
| `events` | `Object` | Type-safe event filters for subscription |
| `withAddress` | `Function` | Method to create a new instance with a different address |
| `abiLoadedFrom` | `{name: string, url?: string}` | Information about where the ABI was loaded from |
| `proxyDetails` | `Array<{name: string, implementation?: Address, selector?: string}>` | If the contract is a proxy, details about the proxy implementation |

## Available Loaders

You can import various ABI loaders from `tevm/contract-loaders`:

### MultiABILoader

Tries multiple ABI loaders until a result is found.

```ts
import { MultiABILoader } from 'tevm/contract-loaders'

// Create loader that tries multiple sources in order
const loader = new MultiABILoader([
  new SourcifyABILoader(),
  new EtherscanABILoader({ apiKey: 'YOUR_ETHERSCAN_KEY' })
])

// Use with loadContract
const contract = await loadContract(client, {
  address: '0x123...',
  loaders: [loader]
})
```

### EtherscanABILoader

Loads contract ABIs from Etherscan and similar explorers.

```ts
import { EtherscanABILoader } from 'tevm/contract-loaders'

// For Etherscan on Ethereum mainnet
const etherscan = new EtherscanABILoader({
  apiKey: 'YOUR_ETHERSCAN_KEY'
})

// For Polygonscan
const polygonscan = new EtherscanABILoader({
  apiKey: 'YOUR_POLYGONSCAN_KEY',
  baseUrl: 'https://api.polygonscan.com/api'
})
```

### SourcifyABILoader

Loads contract ABIs from Sourcify's decentralized repository.

```ts
import { SourcifyABILoader } from 'tevm/contract-loaders'

// Default configuration uses public Sourcify endpoint
const sourcify = new SourcifyABILoader()

// Custom Sourcify server
const customSourcify = new SourcifyABILoader({
  baseUrl: 'https://your-sourcify-server.com'
})
```

### BlockscoutABILoader

Loads contract ABIs from Blockscout explorers.

```ts
import { BlockscoutABILoader } from 'tevm/contract-loaders'

// For default Blockscout
const blockscout = new BlockscoutABILoader({
  apiKey: 'YOUR_BLOCKSCOUT_KEY' // optional
})

// For custom Blockscout instance
const customBlockscout = new BlockscoutABILoader({
  baseUrl: 'https://your-blockscout-instance.com'
})
```

## Examples

### Resolving a Proxy Contract

```ts showLineNumbers {1-2,4,6-11,13-15} filename="proxy-resolution.ts"
import { loadContract, createMemoryClient } from 'tevm'
import { http } from 'viem'
import { SourcifyABILoader, EtherscanABILoader } from 'tevm/contract-loaders'

const client = createMemoryClient({ fork: { transport: http('https://mainnet.infura.io/v3/YOUR-KEY') } })

// Analyze a proxy contract (e.g., a typical ERC-1967 proxy)
const contract = await loadContract(client, {
  address: '0x4f8AD938eBA0CD19155a835f617317a6E788c868',
  followProxies: true,
  loaders: [new SourcifyABILoader(), new EtherscanABILoader({ apiKey: 'YOUR_KEY' })]
})

console.log(`Original address: 0x4f8AD938eBA0CD19155a835f617317a6E788c868`)
console.log(`Implementation address: ${contract.address}`)
console.log(`Detected proxies: ${contract.proxyDetails.length}`)
```

<Callout type="note">
  In this example, if the contract at 0x4f8AD... is a proxy, the Contract Loader will detect it and automatically follow the implementation. The returned `address` will be the implementation address, not the proxy address.
</Callout>

### Working with Unverified Contracts

```ts showLineNumbers {1-2,4,6-10,12-15} filename="unverified-contract.ts"
import { loadContract, createMemoryClient } from 'tevm'
import { http } from 'viem'

const client = createMemoryClient({ fork: { transport: http('https://mainnet.infura.io/v3/YOUR-KEY') } })

// Analyze an unverified contract to extract its interface
const contract = await loadContract(client, {
  address: '0xUnverifiedContractAddress',
  // No loaders - will use bytecode analysis only
  loaders: []
})

// The resulting ABI will contain entries discovered through bytecode analysis
console.log('Discovered functions:')
contract.abi
  .filter(item => item.type === 'function')
  .forEach(func => console.log(`- ${func.name || 'Unknown'}`))
```

### Creating a Contract Macro

```ts showLineNumbers filename="aave-macro.js"
import { createClient } from 'tevm'
import { http } from 'viem'
import { optimism } from 'viem/chains'
import { loadContract } from 'tevm'
import { SourcifyABILoader, EtherscanABILoader } from 'tevm/contract-loaders'

// Client for the Optimism network
const client = createClient({
  chain: optimism,
  transport: http('https://mainnet.optimism.io')
})

// Configure loaders
const loaders = [
  new SourcifyABILoader(),
  new EtherscanABILoader({ 
    apiKey: 'YOUR_ETHERSCAN_KEY',
    baseUrl: 'https://api-optimistic.etherscan.io/api'
  })
]

// Export a single contract as a macro function
export async function aaveV3Pool() {
  return loadContract(client, {
    address: '0x794a61358D6845594F94dc1DB02A252b5b4814aD', // Aave V3 Pool on Optimism
    followProxies: true,
    loaders
  })
}
```

```ts showLineNumbers filename="app.js"
// Import with macro attribute
import { aaveV3Pool } from './aave-macro.js' with { type: 'macro' }
import { createPublicClient, http } from 'viem'
import { optimism } from 'viem/chains'

const client = createPublicClient({
  chain: optimism,
  transport: http()
})

// All methods are strongly typed
const reserves = await client.readContract({
  ...aaveV3Pool.read.getReservesList(),
  address: aaveV3Pool.address
})

console.log(`Aave has ${reserves.length} reserves on Optimism`)
```

### Using Multiple Loaders

```ts showLineNumbers filename="multi-loader.ts"
import { loadContract, createMemoryClient } from 'tevm'
import { http } from 'viem'
import { 
  MultiABILoader,
  SourcifyABILoader, 
  EtherscanABILoader,
  BlockscoutABILoader 
} from 'tevm/contract-loaders'

const client = createMemoryClient({ fork: { transport: http('https://mainnet.infura.io/v3/YOUR-KEY') } })

// Create a multi-loader that tries different sources in order
const multiLoader = new MultiABILoader([
  new SourcifyABILoader(),
  new EtherscanABILoader({ apiKey: 'YOUR_ETHERSCAN_KEY' }),
  new BlockscoutABILoader({ apiKey: 'YOUR_BLOCKSCOUT_KEY' })
])

// Load a contract with comprehensive ABI resolution
const contract = await loadContract(client, {
  address: '0xVerifiedContractAddress',
  followProxies: true,
  loaders: [multiLoader],
  onProgress: (phase) => console.log(`Phase: ${phase}`)
})

// Use the contract directly with the client
const name = await client.readContract({
  ...contract.read.name(),
  address: contract.address
})

console.log(`Contract name: ${name}`)
```

### Progress Tracking for Large Contracts

```ts showLineNumbers {5-14,17-22} filename="progress-tracking.ts"
import { loadContract, createMemoryClient } from 'tevm'
import { http } from 'viem'
import { SourcifyABILoader } from 'tevm/contract-loaders'

// Custom progress tracker
const progressTracker = (phase, ...args) => {
  switch (phase) {
    case 'bytecode':
      console.log('Analyzing bytecode...')
      break
    case 'proxy':
      console.log('Checking for proxy patterns...')
      break
    case 'abi':
      console.log('Loading ABI information...')
      break
  }
}

const contract = await loadContract(client, {
  address: '0xLargeContractAddress',
  followProxies: true,
  loaders: [new SourcifyABILoader()],
  onProgress: progressTracker
})
```

## When to Use Contract Loader

- When working with unverified contracts
- When you need to automatically resolve proxy implementations
- When building tools that need to interact with arbitrary contracts
- For analyzing contract interfaces without source code
- For identifying proxy patterns in contracts
- For bundling network contracts at build time via macros

<div style={{border: '1px solid var(--vocs-border-color)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--vocs-color_background2)', margin: '1.5rem 0'}}>
  <h3 style={{marginTop: 0}}>Common Use Cases</h3>
  
  <ul style={{paddingLeft: '1.5rem'}}>
    <li><strong>DApp Browsers</strong> - Interact with contracts without prior knowledge of their ABI</li>
    <li><strong>Smart Contract Explorers</strong> - Analyze and display contract information on-the-fly</li>
    <li><strong>Development Tools</strong> - Automatically handle proxies during testing and debugging</li>
    <li><strong>Chain Explorers</strong> - Enhanced contract interaction capabilities</li>
    <li><strong>Wallet Interfaces</strong> - Better UX when interacting with arbitrary contracts</li>
    <li><strong>SDK Development</strong> - Use macros to compile strong types for known protocol contracts</li>
  </ul>
</div>

<Callout type="tip">
  Contract Loader is perfect for building exploratory tools, frontends that can work with any contract, or for debugging contract interactions. It enables "magic" experiences where users can interact with contracts without needing to know their interface details.
</Callout>

<div style={{marginTop: '2rem', padding: '1rem', border: '1px solid var(--vocs-color_primary)', borderRadius: '8px', backgroundColor: 'var(--vocs-color_background2)'}}>
  <h2 style={{marginTop: 0}}>Feedback Welcome</h2>
  <p>This API design is currently in the planning phase. If you have suggestions, feature requests, or other feedback about the proposed Contract Loader integration, please share your thoughts in our <a href="https://github.com/evmts/tevm-monorepo/issues/new?labels=enhancement&template=feature_request.md&title=%5BFeature%5D%3A+Contract+Loader+Feedback" target="_blank" rel="noopener noreferrer">GitHub repository</a> or <a href="https://t.me/+ANThR9bHDLAwMjUx" target="_blank" rel="noopener noreferrer">Telegram community</a>.</p>
</div>