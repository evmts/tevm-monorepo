---
title: Methods
description: Complete reference for Tevm Node's API methods and capabilities
---

import { Callout, Steps, Tabs, Tab, Card, Cards, Button, FileTree } from 'vocs/components'

# Tevm Node Methods

<Callout type="info" title="API Reference">
  Tevm Node provides a comprehensive API for interacting with the Ethereum Virtual Machine. This reference covers all core methods and capabilities.
</Callout>

This reference documents the main API methods available on a Tevm Node instance. These methods allow you to interact with the Ethereum Virtual Machine, manage state, and control execution at various levels of abstraction.

## Core Methods

<Cards>
  <Card title="Initialization" icon="🚀">
    Create and set up a Tevm Node instance
  </Card>
  <Card title="Virtual Machine" icon="⚙️">
    Access the low-level EVM interface
  </Card>
  <Card title="Transaction Pool" icon="📥">
    Manage pending transactions
  </Card>
  <Card title="Receipts & Logs" icon="📃">
    Access transaction receipts and event logs
  </Card>
</Cards>

<Tabs>
  <Tab label="Initialization">
    ```ts showLineNumbers {1,3-7,9} filename="node-initialization.ts"
    import { createTevmNode, http } from 'tevm'
    
    const node = createTevmNode({ // [!code focus]
      fork: { // [!code focus]
        transport: http('https://mainnet.infura.io/v3/YOUR-KEY') // [!code focus]
      } // [!code focus]
    }) // [!code focus]
    
    await node.ready() // Wait for initialization // [!code focus]
    ```
    
    <Callout type="warning" title="Important">
      Always wait for the node to be ready before using it. The <code>ready()</code> method returns a promise that resolves when the node is fully initialized.
    </Callout>
  </Tab>
  
  <Tab label="Virtual Machine">
    ```ts showLineNumbers {1-3,5,8,11-19,22-27,30-33} filename="vm-access.ts"
    import { createImpersonatedTx } from 'tevm/tx'
    import { Block } from 'tevm/block'
    import { createAddress } from 'tevm/address'
    
    const vm = await node.getVm() // [!code focus]
    
    // Create a block for the transaction
    const block = new Block()
    
    // Create an impersonated transaction
    const tx = createImpersonatedTx({ // [!code focus]
      impersonatedAddress: createAddress('0x1234...'), // [!code focus]
      nonce: 0n, // [!code focus]
      gasLimit: 21064n, // [!code focus]
      maxFeePerGas: 8n, // [!code focus]
      maxPriorityFeePerGas: 1n, // [!code focus]
      to: createAddress('0x5678...'), // [!code focus]
      value: 1000000000000000000n, // 1 ETH // [!code focus]
    }) // [!code focus]
    
    // Execute the transaction
    const result = await vm.runTx({ // [!code focus]
      tx, // [!code focus]
      block, // [!code focus]
      skipNonce: true,  // Skip nonce check // [!code focus]
      skipBalance: true, // Skip balance check // [!code focus]
    }) // [!code focus]
    
    // Check execution result
    if (!result.execResult.exceptionError) { // [!code focus]
      console.log('Transaction successful') // [!code focus]
      console.log('Gas used:', result.totalGasSpent) // [!code focus]
    } // [!code focus]
    ```
    
    <Callout type="note" title="VM Direct Access">
      The VM interface provides the lowest level of control, allowing you to execute transactions with precise parameters and inspect every aspect of execution.
    </Callout>
  </Tab>
  
  <Tab label="Transaction Pool">
    ```ts showLineNumbers {1,4-9,12} filename="txpool-management.ts"
    const txPool = await node.getTxPool() // [!code focus]
    
    // Add a transaction
    await txPool.add({ // [!code focus]
      from: '0x1234...', // [!code focus]
      to: '0x5678...', // [!code focus]
      value: 1000000000000000000n, // [!code focus]
    }) // [!code focus]
    
    // Get pending transactions
    // Sorted by gas price and nonce
    const pending = await txPool.txsByPriceAndNonce() // [!code focus]
    
    // Get all pending transactions (raw access)
    const allPending = txPool.getPendingTransactions()
    
    // Get pending nonce for an address
    const nextNonce = txPool.getPendingNonce('0x1234...')
    ```
    
    <Callout type="tip" title="Transaction Lifecycle">
      Transactions added to the pool remain pending until they are mined into a block. The mining behavior depends on your node's mining configuration.
    </Callout>
  </Tab>
  
  <Tab label="Receipts & Logs">
    ```ts showLineNumbers {1,4,7-12} filename="receipts-and-logs.ts"
    const receipts = await node.getReceiptsManager() // [!code focus]
    
    // Get receipt for a transaction
    const receipt = await receipts.getReceiptByTxHash('0x1234...') // [!code focus]
    
    // Query logs with filtering
    const logs = await receipts.getLogs({ // [!code focus]
      fromBlock: 0n, // [!code focus]
      toBlock: 'latest', // [!code focus]
      address: '0x1234...', // Contract address (optional) // [!code focus]
      topics: ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'] // Optional topic filters // [!code focus]
    }) // [!code focus]
    
    // Create a subscription for future logs
    const subscription = receipts.createLogSubscription({
      address: '0x1234...',
      topics: ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef']
    })
    
    // Handle new logs
    subscription.on('log', (log) => {
      console.log('New log:', log)
    })
    ```
    
    <Callout type="info" title="Log Filtering">
      The logs API follows the same pattern as Ethereum's JSON-RPC, allowing you to filter by address, topics, and block range.
    </Callout>
  </Tab>
</Tabs>

## State Management

<Cards>
  <Card title="Account Impersonation" icon="👤">
    Act as another account in fork mode
  </Card>
  <Card title="Event Filtering" icon="🔍">
    Create and manage event filters
  </Card>
</Cards>

<Tabs>
  <Tab label="Account Impersonation">
    ```ts showLineNumbers {2,5,8} filename="account-impersonation.ts"
    // Impersonate an account (fork mode only)
    node.setImpersonatedAccount('0x1234...') // [!code focus]
    
    // Get current impersonated account
    const impersonated = node.getImpersonatedAccount() // [!code focus]
    
    // Stop impersonating
    node.setImpersonatedAccount(undefined) // [!code focus]
    
    // Now you can send transactions as this account
    // without having its private key
    ```
    
    <Callout type="warning" title="Fork Mode Only">
      Account impersonation primarily affects the JSON-RPC layer, enabling methods like <code>eth_sendRawTransaction</code> to execute as the impersonated account. It works best in fork mode.
    </Callout>
  </Tab>
  
  <Tab label="Event Filtering">
    ```ts showLineNumbers {2-10,13,16} filename="event-filtering.ts"
    // Create a filter for Transfer events
    node.setFilter({ // [!code focus]
      id: '0x1', // [!code focus]
      fromBlock: 0n, // [!code focus]
      toBlock: 'latest', // [!code focus]
      address: '0x1234...', // [!code focus]
      topics: [ // [!code focus]
        '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // Transfer event signature // [!code focus]
      ], // [!code focus]
    }) // [!code focus]
    
    // Get all filters
    const filters = node.getFilters() // [!code focus]
    
    // Remove a filter
    node.removeFilter('0x1') // [!code focus]
    
    // Use filters with eth_getLogs and eth_getFilterChanges
    const logs = await node.request({
      method: 'eth_getFilterChanges',
      params: ['0x1']
    })
    ```
    
    <Callout type="info" title="ERC-20 Transfer Event">
      <p>The topic <code>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</code> is the keccak256 hash of the Transfer event signature:</p>
      <p><code>Transfer(address,address,uint256)</code></p>
    </Callout>
  </Tab>
</Tabs>

## Node Properties

<Cards>
  <Card title="Status" icon="🚦">
    Current state of the node
  </Card>
  <Card title="Mode" icon="🔄">
    Fork or normal operation mode
  </Card>
  <Card title="Logger" icon="📝">
    Built-in logging capabilities
  </Card>
</Cards>

<div className="properties-grid">
  <div className="property-item">
    <h3>Status</h3>
    <p>The <code>status</code> property indicates the current state of the node:</p>
    
    ```ts showLineNumbers filename="node-status.ts"
    console.log(node.status) 
    // One of: 'INITIALIZING' | 'READY' | 'SYNCING' | 'MINING' | 'STOPPED'
    
    // Example: Wait until node is ready
    const waitForReady = async () => {
      while (node.status !== 'READY') {
        await new Promise(resolve => setTimeout(resolve, 100))
      }
      console.log('Node is ready!')
    }
    ```
  </div>
  
  <div className="property-item">
    <h3>Mode</h3>
    <p>The <code>mode</code> property indicates whether the node is running in fork or normal mode:</p>
    
    ```ts showLineNumbers filename="node-mode.ts"
    console.log(node.mode) // 'fork' or 'normal'
    
    // Use mode to adapt behavior
    if (node.mode === 'fork') {
      console.log('Node is forking from a remote provider')
      // Use fork-specific features like impersonation
    } else {
      console.log('Node is running in standalone mode')
      // Use local-only features
    }
    ```
  </div>
  
  <div className="property-item">
    <h3>Logger</h3>
    <p>Built-in logging capabilities with multiple levels:</p>
    
    ```ts showLineNumbers filename="node-logger.ts"
    // Different log levels
    node.logger.trace('Extremely detailed information')
    node.logger.debug('Detailed debugging information')
    node.logger.info('General information')
    node.logger.warn('Warning messages')
    node.logger.error('Error information')
    node.logger.fatal('Critical errors that stop execution')
    
    // Log with context
    node.logger.info('Transaction processed', {
      hash: '0x1234...',
      from: '0x5678...',
      to: '0x9abc...',
      value: '1 ETH'
    })
    ```
  </div>
</div>

<style>
{`
  .properties-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
  }
  
  .property-item {
    border: 1px solid var(--vocs-color_border);
    border-radius: var(--vocs-borderRadius_4);
    padding: 1.5rem;
    background-color: var(--vocs-color_background2);
  }
  
  .property-item h3 {
    margin-top: 0;
    font-size: var(--vocs-fontSize_18);
    font-weight: var(--vocs-fontWeight_medium);
  }
`}
</style>

## Advanced Actions

<Callout type="info" title="EVM Debug Interface">
  Tevm provides a family of "tevm" prefixed actions for direct EVM execution with extensive debugging capabilities.
</Callout>

<Steps>
  ### tevmCall
  
  Execute low-level EVM calls with detailed execution tracing:
  
  ```ts showLineNumbers {1-3,5,7-29} filename="tevm-call.ts"
  import { tevmCall } from 'tevm/actions'
  import { encodeFunctionData } from 'viem'
  import { createMemoryClient } from 'tevm'
  
  const client = createMemoryClient()
  
  const result = await tevmCall(client, {
    to: '0x1234...',
    data: encodeFunctionData({
      abi,
      functionName: 'myFunction',
      args: [arg1, arg2]
    }),
    // Monitor EVM execution steps
    onStep: (step, next) => {
      console.log(`Opcode: ${step.opcode.name}, PC: ${step.pc}`)
      next?.()
    },
    // Monitor contract creation
    onNewContract: (data, next) => {
      console.log(`New contract at: ${data.address.toString()}`)
      next?.()
    },
    // Monitor call execution
    onBeforeMessage: (message, next) => {
      console.log(`Call to: ${message.to?.toString()}`)
      next?.()
    },
    onAfterMessage: (result, next) => {
      console.log(`Return: ${result.execResult.returnValue.toString('hex')}`)
      next?.()
    }
  })
  ```
  
  <Callout type="tip" title="EVM Tracing">
    The <code>onStep</code> event fires for every EVM instruction executed, allowing you to trace execution at the opcode level.
  </Callout>
  
  ### tevmContract
  
  High-level contract interaction with EVM event monitoring:
  
  ```ts showLineNumbers {1-2,4,6-16} filename="tevm-contract.ts"
  import { tevmContract } from 'tevm/actions'
  import { createMemoryClient } from 'tevm'
  
  const client = createMemoryClient()
  
  const result = await tevmContract(client, {
    abi,
    address: '0x1234...',
    functionName: 'myFunction',
    args: [arg1, arg2],
    // Monitor EVM execution
    onStep: (step, next) => {
      console.log(`Opcode: ${step.opcode.name}, Stack: ${step.stack.length}`)
      next?.()
    },
    onNewContract: (data, next) => {
      console.log(`New contract created: ${data.address.toString()}`)
      next?.()
    }
  })
  
  console.log('Function result:', result)
  ```
  
  ### tevmDeploy
  
  Contract deployment with execution monitoring:
  
  ```ts showLineNumbers {1-2,4,6-16} filename="tevm-deploy.ts"
  import { tevmDeploy } from 'tevm/actions'
  import { createMemoryClient } from 'tevm'
  
  const client = createMemoryClient()
  
  const deployResult = await tevmDeploy(client, {
    abi,
    bytecode,
    args: [constructorArg1, constructorArg2],
    // Monitor deployment execution
    onStep: (step, next) => {
      console.log(`Executing: ${step.opcode.name}`)
      next?.()
    },
    onNewContract: (data, next) => {
      console.log(`Deployed at: ${data.address.toString()}`)
      next?.()
    }
  })
  
  console.log('Contract deployed at:', deployResult.address)
  console.log('Deployment gas used:', deployResult.gasUsed)
  ```
</Steps>

<div className="debug-examples">
  <h3>Debug Use Cases</h3>
  
  <Cards>
    <Card title="Gas Profiling" icon="⛽">
      Track gas consumption of specific operations
    </Card>
    <Card title="Smart Contract Testing" icon="🧪">
      Trace execution to debug test failures
    </Card>
    <Card title="Security Auditing" icon="🔒">
      Analyze EVM execution paths for vulnerabilities
    </Card>
    <Card title="Educational Tools" icon="🎓">
      Create EVM instruction visualizers
    </Card>
  </Cards>
</div>

<style>
{`
  .debug-examples {
    margin-top: 2rem;
    background-color: var(--vocs-color_background2);
    border-radius: var(--vocs-borderRadius_4);
    padding: 1.5rem;
    border: 1px solid var(--vocs-color_border);
  }
  
  .debug-examples h3 {
    margin-top: 0;
    margin-bottom: 1rem;
  }
`}
</style>

## Extensibility

<Tabs>
  <Tab label="Custom Methods">
    ```ts showLineNumbers {1-7,10} filename="custom-methods.ts"
    const enhancedNode = node.extend((baseNode) => ({
      async getBalance(address: string) {
        const vm = await baseNode.getVm()
        const account = await vm.stateManager.getAccount(address)
        return account.balance
      },
    }))
    
    // Use the new method
    const balance = await enhancedNode.getBalance('0x1234...')
    ```
    
    <Callout type="tip" title="Plugin Architecture">
      Tevm's extension system allows you to add custom methods to the node instance. These methods have full access to the base node's functionality.
    </Callout>
  </Tab>
  
  <Tab label="State Cloning">
    ```ts showLineNumbers {2,5-7} filename="state-copying.ts"
    // Create a deep copy with independent state
    const nodeCopy = await node.deepCopy() // [!code focus]
    
    // Fork from another node
    const forkedNode = createTevmNode({ // [!code focus]
      fork: { transport: node } // [!code focus]
    }) // [!code focus]
    
    // Now you can experiment with different states
    await nodeCopy.sendTransaction({ ... })
    
    // Original node state remains unchanged
    console.log('Original state intact')
    ```
    
    <Callout type="note" title="Use Cases">
      State copying is useful for creating test scenarios, simulating alternative execution paths, or creating snapshots of state for later comparison.
    </Callout>
  </Tab>
</Tabs>

## JSON-RPC Support

<Callout type="info" title="Standard Interface">
  Tevm Node implements standard Ethereum JSON-RPC methods, making it compatible with existing Ethereum tools and libraries.
</Callout>

<Tabs>
  <Tab label="EIP-1193 Interface">
    ```ts showLineNumbers {1,3,6-9} filename="eip1193.ts"
    import { requestEip1193 } from 'tevm/decorators'
    
    const node = createTevmNode().extend(requestEip1193())
    
    // Standard JSON-RPC calls
    const blockNumber = await node.request({ // [!code focus]
      method: 'eth_blockNumber', // [!code focus]
      params: [] // [!code focus]
    }) // [!code focus]
    
    // Get balance
    const balance = await node.request({
      method: 'eth_getBalance',
      params: ['0x1234...', 'latest']
    })
    ```
    
    <Callout type="info" title="Provider Interface">
      The EIP-1193 interface makes Tevm Node compatible with libraries like Ethers.js that expect a standard Ethereum provider.
    </Callout>
  </Tab>
  
  <Tab label="Action Methods">
    ```ts showLineNumbers {1,3,6-7} filename="eth-actions.ts"
    import { ethActions } from 'tevm/decorators'
    
    const node = createTevmNode().extend(ethActions())
    
    // Using action methods
    const blockNumber = await node.eth.getBlockNumber() // [!code focus]
    const balance = await node.eth.getBalance('0x1234...') // [!code focus]
    
    // Send transaction
    const hash = await node.eth.sendTransaction({
      from: '0x1234...',
      to: '0x5678...',
      value: 1000000000000000000n
    })
    ```
    
    <Callout type="tip" title="Developer Experience">
      Action methods provide a more ergonomic API than raw JSON-RPC calls, with proper TypeScript typing and simpler parameter handling.
    </Callout>
  </Tab>
</Tabs>

### Supported Methods

<FileTree>
  <FileTree.Folder name="JSON-RPC Methods" defaultOpen>
    <FileTree.Folder name="State Access" defaultOpen>
      <FileTree.File name="eth_getBalance" />
      <FileTree.File name="eth_getCode" />
      <FileTree.File name="eth_getStorageAt" />
      <FileTree.File name="eth_getTransactionCount" />
    </FileTree.Folder>
    <FileTree.Folder name="Block Methods">
      <FileTree.File name="eth_blockNumber" />
      <FileTree.File name="eth_getBlockByHash" />
      <FileTree.File name="eth_getBlockByNumber" />
    </FileTree.Folder>
    <FileTree.Folder name="Transaction Methods">
      <FileTree.File name="eth_sendTransaction" />
      <FileTree.File name="eth_sendRawTransaction" />
      <FileTree.File name="eth_getTransactionByHash" />
      <FileTree.File name="eth_getTransactionReceipt" />
    </FileTree.Folder>
    <FileTree.Folder name="Anvil Methods">
      <FileTree.File name="anvil_impersonateAccount" />
      <FileTree.File name="anvil_stopImpersonatingAccount" />
      <FileTree.File name="anvil_mine" />
      <FileTree.File name="anvil_setBalance" />
    </FileTree.Folder>
    <FileTree.Folder name="Tevm Methods">
      <FileTree.File name="tevm_snapshot" />
      <FileTree.File name="tevm_revert" />
      <FileTree.File name="tevm_mine" />
      <FileTree.File name="tevm_setAccount" />
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

<div style={{ display: 'flex', justifyContent: 'center', marginTop: '2rem' }}>
  <Button href="../api/json-rpc" variant="accent" size="large">
    View Complete JSON-RPC API →
  </Button>
</div>