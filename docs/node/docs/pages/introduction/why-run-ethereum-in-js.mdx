---
title: Why run Ethereum in JS?
description: Motivations for in-browser & local EVM execution and the advantages over traditional RPC execution
authors:
  - "[William Cory](https://x.com/fucory)"
  - "[Tevm Team](https://github.com/evmts)"
---

import { Callout, Card, Steps, Tabs, Tab, Button, FileTree } from 'vocs/components'

# Why Run Ethereum in JavaScript?

JavaScript has emerged as an ideal environment for running Ethereum, offering unique advantages for both developers and end-users. Here's why running an Ethereum node in JavaScript unlocks powerful new capabilities.

## Performance & Efficiency

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem', margin: '1.5rem 0' }}>
  <Card>
    <h3>⚡ Zero Network Latency</h3>
    <p>Running the EVM locally eliminates round-trip delays to remote nodes, enabling near-instantaneous transaction simulations and gas estimations.</p>
  </Card>
  
  <Card>
    <h3>🔄 Parallel Simulations</h3>
    <p>Simulate multiple transactions or execution paths concurrently, impossible with traditional RPC calls to remote nodes.</p>
  </Card>
</div>

### Real-World Performance Benefits

<Callout type="info" title="Performance Comparison">
  Tevm's local execution provides 10-25x faster operation than remote JSON-RPC calls
</Callout>

```typescript showLineNumbers {1-4,8-11} filename="performance-comparison.ts"
// Traditional approach (with network latency)
const gasEstimate1 = await provider.estimateGas({ ... }) // ~150-500ms
const gasEstimate2 = await provider.estimateGas({ ... }) // ~150-500ms
const gasEstimate3 = await provider.estimateGas({ ... }) // ~150-500ms
// Total: 450-1500ms

// With Tevm (local execution)
const gasEstimate1 = await client.estimateGas({ ... }) // ~5-20ms // [!code focus]
const gasEstimate2 = await client.estimateGas({ ... }) // ~5-20ms // [!code focus]
const gasEstimate3 = await client.estimateGas({ ... }) // ~5-20ms // [!code focus]
// Total: 15-60ms (10-25x faster) // [!code focus]
```

## Enhanced User Experiences

JavaScript-based EVM execution enables entirely new categories of dApp features:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(220px, 1fr))', gap: '1rem', margin: '1.5rem 0' }}>
  <Card>
    <h3>📱 Offline Capabilities</h3>
    <p>Enable local-first applications that work without constant network connectivity.</p>
  </Card>
  
  <Card>
    <h3>⚡ Optimistic UI</h3>
    <p>Show users the likely outcome of transactions before they're mined on-chain.</p>
  </Card>
  
  <Card>
    <h3>🛡️ Improved Reliability</h3>
    <p>Reduce dependency on external infrastructure, making dApps more resilient.</p>
  </Card>
  
  <Card>
    <h3>🧮 Transaction Simulation</h3>
    <p>Simulate complex interactions and preview results before sending transactions.</p>
  </Card>
  
  <Card>
    <h3>🔐 Enhanced Privacy</h3>
    <p>Process sensitive data locally without sending it to external services.</p>
  </Card>
</div>

## Developer Experience Advantages

<Steps>
  ### Advanced Debugging 🔬
  
  Step through EVM execution opcode by opcode, inspect memory and stack, and see exactly what happens in your contracts.
  
  ```typescript filename="debug-example.ts"
  // Listen to every EVM instruction
  vm.evm.events.on('step', (data, next) => {
    console.log(
      `${data.pc.toString().padStart(5)}:`,
      `${data.opcode.name.padEnd(10)}`,
      `gas: ${data.gasLeft.toString().padStart(8)}`,
      `stack: ${data.stack.join(', ')}`
    )
    next()
  })
  ```

  ### Deterministic Testing 🧪
  
  Create fully reproducible environments for testing with complete control over blockchain state, time, and mining.
  
  ```typescript filename="testing-example.ts"
  // Create a snapshot before test
  const snapshotId = await client.tevmSnapshot()
  
  // Run the test
  await client.setBalance({ address: testAccount, value: parseEther("100") })
  await client.sendTransaction({ ... })
  await client.mine({ blocks: 1 })
  const result = await client.call({ ... })
  
  // Restore state after test
  await client.tevmRevert({ snapshotId })
  ```

  ### Portable Environment 💼
  
  The same Ethereum environment works across Node.js, browsers, serverless functions, and other JavaScript runtimes.
  
  <Tabs>
    <Tab label="Browser">
      ```ts
      import { createMemoryClient } from 'tevm'
      
      // Create an in-browser Ethereum node
      const client = createMemoryClient()
      
      document.querySelector('#button').addEventListener('click', async () => {
        const balance = await client.getBalance({
          address: '0x...'
        })
        console.log(`Balance: ${formatEther(balance)} ETH`)
      })
      ```
    </Tab>
    <Tab label="Node.js">
      ```ts
      import { createMemoryClient } from 'tevm'
      
      // Create a Node.js Ethereum node
      const client = createMemoryClient()
      
      async function main() {
        const balance = await client.getBalance({
          address: '0x...'
        })
        console.log(`Balance: ${formatEther(balance)} ETH`)
      }
      
      main().catch(console.error)
      ```
    </Tab>
    <Tab label="Serverless">
      ```ts
      import { createMemoryClient } from 'tevm'
      
      export async function handler(event) {
        // Create a serverless Ethereum node
        const client = createMemoryClient()
        
        const balance = await client.getBalance({
          address: event.address
        })
        
        return {
          statusCode: 200,
          body: JSON.stringify({ balance: balance.toString() })
        }
      }
      ```
    </Tab>
  </Tabs>
</Steps>

## JavaScript Ecosystem Integration

<Callout type="note" title="Seamless Integration">
  Running Ethereum in JavaScript means you can leverage the entire JavaScript ecosystem effortlessly.
</Callout>

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', 
  gap: '1rem', 
  margin: '1.5rem 0' 
}}>
  <Card>
    <h3>🔤 TypeScript</h3>
    <p>Type-safe contract interactions with full IntelliSense support</p>
  </Card>
  
  <Card>
    <h3>⚛️ UI Frameworks</h3>
    <p>React, Vue, Svelte and other frontend libraries</p>
  </Card>
  
  <Card>
    <h3>🏗️ Build Tools</h3>
    <p>Vite, Webpack, ESBuild and other bundlers</p>
  </Card>
  
  <Card>
    <h3>🧪 Testing</h3>
    <p>Jest, Vitest and other testing frameworks</p>
  </Card>
  
  <Card>
    <h3>🔄 Runtimes</h3>
    <p>Node.js, browsers, Electron, serverless functions</p>
  </Card>
  
  <Card>
    <h3>📦 NPM Ecosystem</h3>
    <p>Access to millions of packages and libraries in the npm registry</p>
  </Card>
  
  <Card>
    <h3>🌐 Web APIs</h3>
    <p>Integration with browser storage, WebSockets, service workers, and more</p>
  </Card>
</div>

## Ready to Get Started?

<FileTree>
  <FileTree.Folder name="Getting Started Guide" defaultOpen>
    <FileTree.File name="Install Tevm" url="../getting-started/overview" />
    <FileTree.File name="Configure Your Environment" url="../core/create-tevm-node" />
    <FileTree.File name="Run Your First Code" url="../examples/viem" />
  </FileTree.Folder>
</FileTree>

<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem', marginTop: '2rem' }}>
  <Button href="../getting-started/overview" variant="accent" size="large">Install Tevm →</Button>
  <Button href="../examples/viem">View Examples</Button>
  <Button href="https://github.com/evmts/tevm-monorepo" variant="outline">GitHub Repo</Button>
</div>
