---
title: Managing State
description: Overview of how to manage accounts, code, and storage in Tevm Node
---

import { Callout } from 'vocs/components'

# Managing State

Tevm Node provides powerful state management capabilities through its `stateManager` interface. This allows you to interact with and modify Ethereum state, including accounts, contract code, and storage.

## Getting Started

Access the state manager through the VM:

```ts
import { createTevmNode } from 'tevm'

const node = createTevmNode()
const vm = await node.getVm()
const stateManager = vm.stateManager
```

## Account Management

### Reading Accounts

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
const account = await stateManager.getAccount(address)

if (account) {
  console.log({
    balance: account.balance,      // BigInt
    nonce: account.nonce,         // BigInt
    codeHash: account.codeHash,   // Hex string
    storageRoot: account.storageRoot // Hex string
  })
}
```

### Modifying Accounts

```ts
import { createAddress } from 'tevm/address'
import { EthjsAccount } from 'tevm/utils'

// Create or update an account
const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.putAccount(
  address,
  EthjsAccount.fromAccountData({
    nonce: 0n,
    balance: 10_000_000n,
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })
)
```

<Callout type="info">
  When modifying accounts, make sure to handle the case where the account doesn't exist by creating a new account using `EthjsAccount.fromAccountData()`.
</Callout>

### Deleting Accounts

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.deleteAccount(address)
```

## Contract Management

### Deploying Contract Code

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Deploy contract bytecode
await stateManager.putContractCode(
  address,
  new Uint8Array([/* bytecode */])
)

// Verify deployment
const code = await stateManager.getContractCode(address)
console.log('Deployed code length:', code.length)
```

### Reading Contract Code

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
const deployedCode = await stateManager.getContractCode(address)
if (deployedCode.length > 0) {
  console.log('Contract exists with code')
} else {
  console.log('No contract code at address')
}
```

## Storage Management

### Reading Storage

```ts
import { createAddress, hexToBytes } from 'tevm/utils'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Get a specific storage slot
const slot = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000000')
const value = await stateManager.getContractStorage(address, slot)

// Dump all storage
const storage = await stateManager.dumpStorage(address)
console.log('Contract storage:', storage)
```

### Writing Storage

```ts
import { createAddress, hexToBytes } from 'tevm/utils'

const address = createAddress('0x1234567890123456789012345678901234567890')

// Set a storage value
const key = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000000')
const value = hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001')
await stateManager.putContractStorage(address, key, value)
```

### Clearing Storage

```ts
import { createAddress } from 'tevm/address'

const address = createAddress('0x1234567890123456789012345678901234567890')
await stateManager.clearContractStorage(address)
```

## State Checkpoints

Tevm uses a checkpoint system to manage state changes atomically:

```ts
import { createAddress, hexToBytes } from 'tevm/utils'
import { EthjsAccount } from 'tevm/utils'

// Create a checkpoint
await stateManager.checkpoint()

try {
  const address = createAddress('0x1234567890123456789012345678901234567890')
  const account = EthjsAccount.fromAccountData({
    nonce: 0n,
    balance: 10_000_000n,
    storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
    codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
  })

  // Make state changes
  await stateManager.putAccount(address, account)
  await stateManager.putContractStorage(
    address,
    hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001'),
    hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000002')
  )

  // Commit changes if successful
  await stateManager.commit()
} catch (error) {
  // Revert changes on failure
  await stateManager.revert()
  console.error('State changes reverted:', error)
}
```

## State Persistence

### Dumping State

Export the entire state:

```ts
// Get complete state
const state = await stateManager.dumpCanonicalGenesis()
expect(state).toBeDefined()
```

### Loading State

Restore state from a previous dump:

```ts
// Restore state
await stateManager.generateCanonicalGenesis(state)
```

## Fork Mode State

When running in fork mode, state is fetched lazily from the remote provider:

```ts
import { createTevmNode, http } from 'tevm'
import { createAddress } from 'tevm/address'
import { performance } from 'node:perf_hooks'

const node = createTevmNode({
  fork: {
    transport: http('https://mainnet.infura.io/v3/YOUR-KEY')({}),
  }
})

const vm = await node.getVm()
const stateManager = vm.stateManager
const testAddress = createAddress('0x1234567890123456789012345678901234567890')

// First access fetches from remote
const t0 = performance.now()
await stateManager.getAccount(testAddress)
console.log('Initial fetch:', performance.now() - t0)

// Subsequent access uses cache
const t1 = performance.now()
await stateManager.getAccount(testAddress)
console.log('Cached access:', performance.now() - t1)
```

## Best Practices

1. **Error Handling**
   ```ts
   import { createAddress } from 'tevm/address'

   const testAddress = createAddress('0x1234567890123456789012345678901234567890')
   try {
     const account = await stateManager.getAccount(testAddress)
     if (!account) {
       throw new Error('Account not found')
     }
     // Work with account
   } catch (error) {
     console.error('State operation failed:', error)
   }
   ```

2. **State Isolation**
   ```ts
   // Create isolated copy for testing
   const isolatedState = await stateManager.deepCopy()
   ```

3. **Atomic Operations**
   ```ts
   import { createAddress, hexToBytes } from 'tevm/utils'
   import { EthjsAccount } from 'tevm/utils'

   const testAddress = createAddress('0x1234567890123456789012345678901234567890')
   await stateManager.checkpoint()
   try {
     const account = EthjsAccount.fromAccountData({
       nonce: 0n,
       balance: 10_000_000n,
       storageRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
       codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
     })

     // Batch multiple state changes
     await Promise.all([
       stateManager.putAccount(testAddress, account),
       stateManager.putContractStorage(
         testAddress,
         hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000001'),
         hexToBytes('0x0000000000000000000000000000000000000000000000000000000000000002')
       )
     ])
     await stateManager.commit()
   } catch (error) {
     await stateManager.revert()
   }
   ```

## Related Topics

- [Transaction Processing](../advanced/txpool)
- [Receipts and Logs](../advanced/receipts-and-logs)
- [Forking](./forking)