---
title: Getting Started with Viem
description: Get started with Tevm node using viem
---

# Getting Started with Viem

## Installation

:::code-group

```bash [npm]
npm install tevm
```

```bash [pnpm]
pnpm install tevm
```

```bash [yarn]
yarn add tevm
```

:::

## Sample code

Fork an existing blockchain and use [`viem` actions](https://viem.sh).

```ts [viem-quickstart.mts]
import {createMemoryClient, http} from 'tevm'
import {optimism} from 'tevm/common'
import {encodeFunctionData, parseAbi, decodeFunctionResult, parseEther} from 'viem'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

console.log("Client created")

await client.tevmReady()

console.log("Client ready")

const blockNumber = await client.getBlockNumber()
console.log(blockNumber)

const account = "0x" + "baD60A7".padStart(40, "0")
const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"

const greetAbi = parseAbi(['function greet() view returns (string)'])
const setGreetingAbi = parseAbi(['function setGreeting(string memory _greeting) public'])

const getGreeting = async () => {
  const callResult = await client.call({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: greetAbi
    }),
  })

  const greeting = decodeFunctionResult({
    abi: greetAbi,
    data: callResult.data,
  })

  return greeting
}

const setGreeting = async newGreeting => {
  const callResult = await client.sendTransaction({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: setGreetingAbi,
      args: [newGreeting]
    }),
    chain: optimism,
  })

  return callResult
}

await client.setBalance({
  address: account,
  value: parseEther("1")
})

console.log(`Original greeting: ${await getGreeting()}`)
console.log(`Txn hash: ${await setGreeting("Hi")}`)
await client.mine({blocks: 1})
console.log(`Changed greeting: ${await getGreeting()}`)
```

:::details[Explanation]

```ts
import {createMemoryClient, http} from 'tevm'
import {optimism} from 'tevm/common'
import {encodeFunctionData, parseAbi, decodeFunctionResult, parseEther} from 'viem'
```

Import functions we need, which will be explained when we call them.
Notice that most functions we call are from `viem`, not `tevm`.

```ts
const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism
  },
})

await client.tevmReady()
```

Create a client as a fork of the Optimism mainnet, and wait until it is ready.

```ts
const blockNumber = await client.getBlockNumber()
console.log(blockNumber)
```

Report the fork block number. Any changes on the Optimism mainnet after this point will not be reflected in the `tevm` client.

```ts
const account = "0x" + "baD60A7".padStart(40, "0")
const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"
```

A couple of addresses. `0x0...0baD60A7` is just a random unused address which we'll use as our address.
[`0x10ed0b176048c34d69ffc0712de06CbE95730748`](https://optimism.blockscout.com/address/0x10ed0b176048c34d69ffc0712de06CbE95730748?tab=read_write_contract) is a `Greeter` contract we can use to experiment.

```ts
const greetAbi = parseAbi(['function greet() view returns (string)'])
const setGreetingAbi = parseAbi(['function setGreeting(string memory _greeting) public'])
```

Use [`viem`'s `parseAbi`](https://viem.sh/docs/abi/parseAbi#parseabi) to get the ABI for the two functions we need.

```ts
const getGreeting = async () => {
  const callResult = await client.call({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: greetAbi
    })
  })

  const greeting = decodeFunctionResult({
    abi: greetAbi,
    data: callResult.data
  })

  return greeting
}
```

This function is identical to what you would use to call an actual node using `viem` to get the greeting.

```ts
const setGreeting = async newGreeting => {
  const callResult = await client.sendTransaction({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: setGreetingAbi,
      args: [newGreeting]
    }),
    chain: optimism
  })

  return callResult
}
```

This function is similar to what you'd use with `viem`.
Normally `viem` does not support specifying the account as an address, because it needs the private key to sign the transaction.
However, this is supported when using `viem` with a [test client](https://viem.sh/docs/clients/test).

```ts
await client.setBalance({
  address: account,
  value: parseEther("1")
})
```

Mint 1 ETH for our address so we'll be able to send transactions.
The function we use is identical to [`viem`s `setBalance`](https://viem.sh/docs/actions/test/setBalance#setbalance).

```ts
console.log(`Original greeting: ${await getGreeting()}`)
```

The way you get a greeting is identical to the way you'd do it with `viem`.

```ts
console.log(`Txn hash: ${await setGreeting("Hi")}`)
await client.mine({blocks: 1})
console.log(`Changed greeting: ${await getGreeting()}`)
```

Because we control the "node", we control when it mines a new block and processes transactions.
So after we use [`<client>.sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction) we need to use [`<client>.mine`](https://viem.sh/docs/actions/test/mine) for the transaction to take effect.

:::

You can also use the tree-shakeable API. See [`viem` tevm docs](../examples/viem.mdx)

## Tevm actions

Some `tevm` actions are available directly in the client.
They are [tree-shakable](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking), which makes them more efficient when writing code to run in a web browser.

[See here for more information](/reference/memory-client#tevm-actions).

## TevmNode

In most cases, you can use a standard API, such as `viem`, to control `tevm`.
These APIs let you communicate as you would with a real Ethereum node.

But if you need to access the node's internals, for example the EVM (Ethereum virtual machine), that is also available. The lower level API is available in the [`TevmNode`](https://github.com/evmts/tevm-monorepo/blob/main/packages/node/src/TevmNode.ts) object.

For example, this code shows the trace of a `setGreeting` call.

```ts [trace-execution.mts]
import {createMemoryClient, http} from 'tevm'
import {optimism} from 'tevm/common'
import {createAddress} from 'tevm/address'

import {
  encodeFunctionData,
  parseAbi,
  decodeFunctionResult,
  parseEther,
  hexToBytes
} from 'viem'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

console.log("Client created")

await client.tevmReady()

console.log("Client ready")

const blockNumber = await client.getBlockNumber()
console.log(blockNumber)

const account = `0x${"baD60A7".padStart(40, "0")}` as const
const greeterContractAddress = "0x10ed0b176048c34d69ffc0712de06CbE95730748"

const greetAbi = parseAbi(['function greet() view returns (string)'])
const setGreetingAbi = parseAbi(['function setGreeting(string memory _greeting) public'])

const getGreeting = async () => {
  const callResult = await client.call({
    account,
    to: greeterContractAddress,
    data: encodeFunctionData({
      abi: greetAbi
    }),
  })

  const greeting = decodeFunctionResult({
    abi: greetAbi,
    data: callResult.data,
  })

  return greeting
}

await client.setBalance({
  address: account,
  value: parseEther("1")
})

const tevmNode = client.transport.tevm   // [!code hl]
const vm = await tevmNode.getVm() // [!code hl]

vm.evm.events.on("step", (data, next) => { // [!code hl]
  try { // [!code hl]
    console.log( // [!code hl]
      data.pc.toString().padStart(5, " "), // [!code hl]
      data.opcode.name.padEnd(9, " "), // [!code hl]
      data.stack.length.toString().padStart(3, " "), // [!code hl]
      data.stack.length<5 ? data.stack : data.stack.slice(-5)) // [!code hl]
// [!code hl]
  } catch (err) {  // [!code hl]
    console.error(err)  // [!code hl]
  }   // [!code hl]
  next?.() // [!code hl]
}) // [!code hl]

console.log(`Original greeting: ${await getGreeting()}`)

const requestData = encodeFunctionData({ // [!code hl]
  abi: setGreetingAbi, // [!code hl]
  args: ["Hi"] // [!code hl]
}) // [!code hl]

await vm.evm.runCall({ // [!code hl]
  to: createAddress(greeterContractAddress), // [!code hl]
  caller: createAddress(account), // [!code hl]
  data: hexToBytes(requestData) // [!code hl]
}) // [!code hl]

console.log(`Changed greeting: ${await getGreeting()}`)
```

:::details[Explanation]

```ts
const tevmNode = client.transport.tevm
const vm = await tevmNode.getVm()
```

Get a [`Vm`](/reference/vm#vm) object for the `tevmNode`.
Note that this is *not* the `Vm` that runs when you mine a block to execute transactions.
Mining is performed by new, pristine `Vm`s to ensure transactions are separated properly.

```ts
vm.evm.events.on("step", (data, next) => {
```

The actual [`EVM`](https://github.com/evmts/tevm-monorepo/blob/main/packages/evm/docs/classes/Evm.md) is in `vm.evm`.
It supports [three events](/api/evm-events#available-events).
Here we listen to `step`, which is called for every opcode processed by the EVM.

```ts
  try {
```

By default, when errors happen in event handlers they are discarded silently.
By wrapping our code in a `try ... catch` statement, we make sure that we see the errors that are thrown.

```ts
    console.log(
      data.pc.toString().padStart(5, " "),
      data.opcode.name.padEnd(9, " "),
      data.stack.length.toString().padStart(3, " "),
      data.stack.length<5 ? data.stack : data.stack.slice(-5))
```

The `data` parameter is an [`InterpreterStep`](https://github.com/evmts/tevm-monorepo/blob/main/packages/evm/docs/interfaces/InterpreterStep.md).
Here we output the interesting fields.

```ts
  } catch (err) {
    console.error(err)
  }

  next?.()
})
```

The `next` parameter is the function to call after the event handler is done.

```ts
const requestData = encodeFunctionData({
  abi: setGreetingAbi,
  args: ["Hi"]
})
```

Create the ABI encoded data you would normally send with the transaction, using `viem`'s [`encodeFunctionData`](https://viem.sh/docs/contract/encodeFunctionData.html).

```ts
await vm.evm.runCall({
  to: createAddress(greeterContractAddress),
  caller: createAddress(account),
  data: hexToBytes(requestData)
})
```

This is the way we [call the EVM](/reference/evm#running-evm-calls), which activates the event handler registered earlier.
This call modifies the state, so you can see the updated greeting.

:::
