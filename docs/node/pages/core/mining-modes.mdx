---
title: Mining Modes
description: Configure block production in Tevm Node
---

import { Tabs, Tab, Steps, Step } from "vocs/components";

import { Callout, Steps, Button } from 'vocs/components'
import { Card, CardGrid, FileTree } from '../../../components'

# Mining Modes

<Callout type="info" title="Block Production">
  Tevm Node provides several mining modes to control how and when blocks are produced, allowing you to simulate different network conditions.
</Callout>

Mining modes determine when transactions are included in blocks and confirmed. By choosing the right mining mode, you can accurately simulate real blockchain networks or optimize for specific testing scenarios.

## Available Mining Modes

<CardGrid>
  <Card title="Auto Mining" icon="âš¡">
    Mines a block after each transaction
  </Card>
  <Card title="Interval Mining" icon="â±ï¸">
    Mines blocks at fixed time intervals
  </Card>
  <Card title="Manual Mining" icon="ðŸ”¨">
    Only mines when explicitly requested
  </Card>
  <Card title="Gas-Based Mining" icon="â›½">
    Mines when gas threshold is reached
  </Card>
</CardGrid>

<Tabs>
</Tabs>

## Changing Mining Modes

<Callout type="tip" title="Dynamic Configuration">
  You can change the mining mode at any time during the node's lifecycle to adapt to different testing phases.
</Callout>

```typescript showLineNumbers {2-5,8-10} filename="changing-mining-modes.ts"
// Switch to interval mining
await node.setMiningConfig({ // [!code focus]
  type: 'interval', // [!code focus]
  interval: 5000 // 5 seconds // [!code focus]
}) // [!code focus]

// Switch to manual mining
await node.setMiningConfig({ // [!code focus]
  type: 'manual' // [!code focus]
}) // [!code focus]
```

## Event Handlers

Tevm provides event handlers for mining operations, allowing you to monitor blocks, receipts, and logs in real-time:

```typescript showLineNumbers {8-25} filename="mine-with-events.ts"
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()

// Mine with event handlers
const result = await client.mine({
  blockCount: 2,
  // Monitor each block as it's mined
  onBlock: (block, next) => {
    console.log(`Block #${block.header.number} mined:`, {
      hash: block.hash().toString('hex'),
      timestamp: block.header.timestamp,
      gasUsed: block.header.gasUsed
    })
    next?.() // Must call next to continue processing
  },
  // Monitor transaction receipts
  onReceipt: (receipt, blockHash, next) => {
    console.log(`Receipt for tx ${receipt.transactionHash}:`, {
      blockHash,
      gasUsed: receipt.gasUsed
    })
    next?.()
  },
  // Monitor logs from transactions
  onLog: (log, receipt, next) => {
    console.log(`Log from ${log.address}:`, {
      topics: log.topics,
      data: log.data
    })
    next?.()
  }
})
```

<Callout type="info">
  Event handlers are called synchronously by default. Always call the `next()` function to continue processing, similar to middleware patterns.
</Callout>

## Best Practices

<Steps>
  ### Choose the Right Mode for Your Use Case

  <CardGrid columns="grid grid-cols-1 sm:grid-cols-2 gap-4">
    <Card title="Development" icon="ðŸ’»">
      Use <code>auto</code> mining for the fastest feedback loop during development
    </Card>
    <Card title="Testing" icon="ðŸ§ª">
      Use <code>manual</code> mining for deterministic tests with precise control
    </Card>
    <Card title="Simulation" icon="ðŸ”„">
      Use <code>interval</code> mining to simulate real-world network conditions
    </Card>
    <Card title="Load Testing" icon="ðŸ“Š">
      Use <code>gas</code> mining to test application behavior under congestion
    </Card>
  </CardGrid>

  ### Consider Performance Implications

  <Callout type="warning">
    Different mining modes have varying performance characteristics:

    - <strong>Auto mining</strong> can be resource-intensive with many transactions
    - <strong>Interval mining</strong> might delay transaction processing
    - <strong>Gas mining</strong> helps simulate network congestion but requires careful configuration
  </Callout>

  ### Testing Best Practices

  ```typescript filename="testing-strategies.ts"
  // For time-sensitive logic testing
  const timeNode = createTevmNode({
    miningConfig: { type: 'interval', interval: 10000 }
  })

  // For deterministic test cases
  const deterministicNode = createTevmNode({
    miningConfig: { type: 'manual' }
  })

  // For gas-sensitive contract testing
  const gasNode = createTevmNode({
    miningConfig: { type: 'gas', gasLimit: 8000000 }
  })
  ```
</Steps>

## Example: Testing Different Mining Modes

<Tabs>
</Tabs>

## Related Resources

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1rem', margin: '1.5rem 0' }}>
  <Button href="../advanced/txpool" style={{ height: 'auto', padding: '1rem', display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
    <div style={{ fontWeight: 'var(--vocs-fontWeight_medium)', marginBottom: '0.5rem' }}>Transaction Pool</div>
    <div style={{ fontSize: 'var(--vocs-fontSize_14)', textAlign: 'left' }}>Understanding pending transaction handling and mempool behavior</div>
  </Button>

  <Button href="../advanced/performance-profiler" style={{ height: 'auto', padding: '1rem', display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
    <div style={{ fontWeight: 'var(--vocs-fontWeight_medium)', marginBottom: '0.5rem' }}>Performance Optimization</div>
    <div style={{ fontSize: 'var(--vocs-fontSize_14)', textAlign: 'left' }}>Tuning mining modes for better performance</div>
  </Button>

  <Button href="../api/methods#block-methods" variant="accent" style={{ height: 'auto', padding: '1rem', display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
    <div style={{ fontWeight: 'var(--vocs-fontWeight_medium)', marginBottom: '0.5rem' }}>Block Management</div>
    <div style={{ fontSize: 'var(--vocs-fontSize_14)', textAlign: 'left' }}>Low-level block control and manipulation</div>
  </Button>
</div>