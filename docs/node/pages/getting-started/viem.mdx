---
title: Getting Started with Viem
description: Get started with Tevm Node using the viem library with full TypeScript support
authors:
  - "[William Cory](https://x.com/fucory)"
  - "[Tevm Team](https://github.com/evmts)"
---

import { Tabs, Tab, Steps, Step } from "vocs/components";

import { Callout, Steps, Button } from 'vocs/components'

# Getting Started with Viem

<Callout type="tip" title="Perfect for Viem Users">
If you're already familiar with [viem](https://viem.sh), Tevm works seamlessly with your existing knowledge, providing a nearly identical API.
</Callout>

This guide will help you integrate Tevm with [viem](https://viem.sh), the modern TypeScript interface for Ethereum. By the end, you'll have a working setup with Tevm Node and understand how to leverage viem's actions with Tevm.

## Installation

<Steps>
<Step title="Install Dependencies">

First, install Tevm along with viem as a peer dependency:

<Tabs>
<Tab title="npm">
```bash
npm install tevm viem@latest
```
</Tab>

<Tab title="pnpm">
```bash
pnpm add tevm viem@latest
```
</Tab>

<Tab title="yarn">
```bash
yarn add tevm viem@latest
```
</Tab>

<Tab title="bun">
```bash
bun add tevm viem@latest
```
</Tab>

<Tab title="jsr">
```bash
jsr add @tevm/tevm
# Also install viem from npm
npm install viem@latest
```
</Tab>

</Tabs>

</Step>

<Step title="Create Your Client">

For the quickest start, create a memory client:

<Tabs>
<Tab title="npm">
```ts
import { createMemoryClient } from 'tevm'

const client = createMemoryClient()
```
</Tab>

<Tab title="jsr">
```ts
import { createMemoryClient } from '@tevm/tevm'

const client = createMemoryClient()
```
</Tab>

</Tabs>

Or, to fork from an existing chain:

<Tabs>
<Tab title="npm">
```ts
import { createMemoryClient, http } from 'tevm'
import { optimism } from 'tevm/chains'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

// Wait for the node to be ready before using it
await client.tevmReady()
```
</Tab>

<Tab title="jsr">
```ts
import { createMemoryClient, http } from '@tevm/tevm'
import { optimism } from '@tevm/tevm/chains'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

// Wait for the node to be ready before using it
await client.tevmReady()
```
</Tab>

</Tabs>

</Step>

<Step title="You're Ready!">

Start using your client with familiar viem actions:

```ts
// Get the current block number
const blockNumber = await client.getBlockNumber()
console.log(`Current block: ${blockNumber}`)
```
</Step>

</Steps>

## Complete Example

The following example demonstrates the key capabilities of Tevm with viem:

<Tabs>
</Tabs>

<details>
  <summary>Code Walkthrough</summary>
  ### 1. Imports & Client Creation

```ts
import { createMemoryClient, http } from 'tevm'
import { optimism } from 'tevm/common'
import { parseAbi, parseEther } from 'viem'

const client = createMemoryClient({
  fork: {
    transport: http('https://mainnet.optimism.io'),
    common: optimism,
  },
})

await client.tevmReady()
```

- We create a client that **forks** from Optimism mainnet
- This gives us a local sandbox with all of mainnet's state
- `client.tevmReady()` ensures the fork is complete before proceeding

### 2. Contract Interaction

```ts
// Define the contract interface
const greeterAbi = parseAbi([
  'function greet() view returns (string)',
  'function setGreeting(string memory _greeting) public'
])

// Read from contract
const currentGreeting = await client.readContract({
  address: greeterContractAddress,
  abi: greeterAbi,
  functionName: 'greet',
})

// Write to contract
const txHash = await client.writeContract({
  account,
  address: greeterContractAddress,
  abi: greeterAbi,
  functionName: 'setGreeting',
  args: ["Hello from Tevm!"],
  chain: optimism,
})
```

- The API matches viem exactly - anyone familiar with viem can use this immediately
- Write operations return a transaction hash just like on a real network

### 3. Mining Control

```ts
// Mine a block to include our transaction
await client.mine({ blocks: 1 })
```

- Unlike real networks, you control exactly when blocks are mined
- This gives you complete determinism for testing and development

</details>

## Key Viem-Compatible Features

Tevm's viem client implements the full viem API, maintaining compatibility while adding powerful features:

<Tabs>
<Tab title="Standard viem API">
```ts
// These standard viem actions work exactly as expected
await client.getBalance({ address: '0x...' })
await client.getBlockNumber()
await client.readContract({ ... })
await client.writeContract({ ... })
await client.estimateGas({ ... })
await client.sendTransaction({ ... })
// And all other viem actions
```
</Tab>

<Tab title="Tevm Extensions">
```ts
// Tevm adds powerful extensions
await client.tevmReady() // Wait for fork initialization
await client.setBalance({ address: '0x...', value: 100n })
await client.setCode({ address: '0x...', bytecode: '0x...' })
await client.mine({ blocks: 1 })
await client.reset() // Reset to initial state
await client.impersonateAccount({ address: '0x...' })
```
</Tab>

<Tab title="EVM Debugging">
```ts
// Advanced EVM debugging and inspection
await client.tevmContract({
  address: '0x...',
  abi: [...],
  functionName: 'transfer',
  args: ['0x...', 100n],
  // Get step-by-step EVM execution details
  onStep: (data, next) => {
    console.log(`Opcode: ${data.opcode.name}`)
    console.log(`Stack: ${data.stack.join(', ')}`)
    next() // Continue execution
  }
})
```
</Tab>

</Tabs>

## Tree-Shakeable API

For production applications, especially in browser environments, you may want to use Tevm's tree-shakeable API to minimize bundle size:

<Tabs>
</Tabs>

<Callout type="tip" title="Tree-Shaking Benefit">
Using the tree-shakeable API can significantly reduce your bundle size when you're using only a subset of Tevm's features.
</Callout>

## EVM Execution Hooks

One of Tevm's most powerful features is the ability to hook directly into EVM execution:

```ts showLineNumbers {7-16}
await client.tevmContract({
  address: greeterContractAddress,
  abi: greeterAbi,
  functionName: 'setGreeting',
  args: ['Hello!'],

  // onStep is called for each EVM operation // [!code focus]
  onStep: (stepInfo, next) => { // [!code focus]
    console.log(`Executing: ${stepInfo.opcode.name} at PC=${stepInfo.pc}`) // [!code focus]
    console.log(`Stack: ${stepInfo.stack.map(val => val.toString())}`) // [!code focus]
    console.log(`Memory: ${stepInfo.memory.toString('hex')}`) // [!code focus]

    // You can also modify EVM state here if needed // [!code focus]

    // Call next() to continue execution // [!code focus]
    next?.() // [!code focus]
  }, // [!code focus]

  // You can also access the detailed result after execution
  onResult: (result) => {
    console.log(`Gas used: ${result.executionGasUsed}`)
    console.log(`Return value: 0x${result.returnValue?.toString('hex')}`)
  }
})
```

This enables advanced use cases like:

- **Visual Debuggers**: Create step-by-step transaction debuggers
- **Educational Tools**: Explain EVM execution for learning purposes
- **Custom Instrumentation**: Profile and analyze contract execution
- **Intercepting Execution**: Modify execution behavior for testing

## Tevm-Specific Actions

Tevm extends viem with specialized actions that provide enhanced capabilities:

| Action | Description | Use Case |
|--------|-------------|----------|
| `tevmCall` | Low-level EVM call with execution hooks | Deep inspection of contract execution |
| `tevmContract` | Enhanced contract interaction with EVM hooks | Detailed debugging of contract calls |
| `tevmDeploy` | Deploy with execution hooks | Understanding deployment execution flow |
| `tevmMine` | Control block mining | Precise transaction inclusion control |
| `tevmSetAccount` | Modify account state | Test different account scenarios |
| `tevmGetAccount` | Read detailed account state | Inspect nonce, code, storage |
| `tevmDumpState` | Export full EVM state | State persistence and analysis |
| `tevmLoadState` | Import saved EVM state | Restore a specific state for testing |
| `tevmReady` | Wait for fork to initialize | Ensure node is ready before use |
| `tevmEnableTracing` | Enable detailed execution tracing | Capture full execution traces |
| `tevmReset` | Reset node to initial state | Start fresh for new test scenarios |

<Callout type="info">
All tevm-specific actions are also available as individual imports from `tevm/actions` for tree-shaking.
</Callout>

## Next Steps

Now that you're familiar with using Tevm with viem, you can:

<Steps>
<Step title="Explore More Tevm Features">

Dive deeper into Tevm's powerful capabilities:

- [Forking capabilities](/core/forking) to simulate production chains
- [State management](/core/managing-state) for manipulating the blockchain
- [Mining modes](/core/mining-modes) for controlling transaction inclusion
- [Direct Solidity imports](/getting-started/bundler) with the Tevm Bundler

</Step>

<Step title="Check Out Examples">

See how Tevm solves real-world problems:

- [Forking mainnet](/examples/forking-mainnet) for production simulation
- [Building a debugger UI](/examples/debugger-ui) with EVM insights
- [Local testing flows](/examples/local-testing) for development

</Step>

<Step title="Advanced API Usage">

Master the Tevm API for more sophisticated applications:

- [EVM events & hooks](/api/evm-events) for detailed execution analysis
- [Custom precompiles](/advanced/custom-precompiles) for extending the EVM
- [Transaction pool management](/advanced/txpool) for pending transaction control
- [Contract Bundler](/reference/bundler) for importing Solidity files directly
</Step>

</Steps>

<div style={{ display: 'flex', gap: '1rem', marginTop: '2rem' }}>
  <Button href="./overview" variant="accent">← Back to Overview</Button>
  <Button href="./ethers">Ethers Integration →</Button>
</div>