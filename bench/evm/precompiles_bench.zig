const std = @import("std");
const zbench = @import("zbench");
const Precompiles = @import("Precompiles");

// Test data constants matching REVM benchmarks

// ECRECOVER test data - generated secp256k1 signature
const ECRECOVER_INPUT = [_]u8{
    // Hash (32 bytes) - SHA256 of "1337133713371337"
    0x45, 0x6e, 0x9a, 0xea, 0x5e, 0x19, 0x7a, 0x1f,
    0x1a, 0xf7, 0xa3, 0xe8, 0x5e, 0x2f, 0x12, 0xdc,
    0xa5, 0x6d, 0xc7, 0x68, 0x6c, 0x91, 0x4a, 0x2d,
    0x9a, 0x77, 0x2e, 0xd2, 0xb9, 0x6b, 0x7e, 0xd1,
    // V (32 bytes, padded)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,
    // R (32 bytes)
    0x9b, 0xab, 0xfe, 0xc6, 0xdd, 0x9d, 0x9f, 0x0e,
    0x96, 0x9a, 0x8b, 0x62, 0x55, 0x2e, 0x05, 0x91,
    0x07, 0xa7, 0xbd, 0xca, 0x65, 0xe4, 0x06, 0x02,
    0x52, 0x5d, 0xf7, 0xdf, 0x5e, 0x88, 0x2e, 0x4e,
    // S (32 bytes)
    0x5b, 0x99, 0xd5, 0xb5, 0xfb, 0xa6, 0x8a, 0x89,
    0xbf, 0x26, 0xa5, 0x94, 0xb7, 0xfc, 0x28, 0xa4,
    0x08, 0x2b, 0xc0, 0x1a, 0xe0, 0x36, 0x85, 0xd9,
    0x23, 0x4f, 0x2e, 0xc8, 0x3b, 0x41, 0x14, 0x83,
};

// SHA256 test data
const SHA256_INPUT_SMALL = "hello world";
const SHA256_INPUT_MEDIUM = "The quick brown fox jumps over the lazy dog. This is a longer message to test SHA256 performance with medium-sized inputs.";
const SHA256_INPUT_LARGE = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo." ** 4; // ~2KB

// RIPEMD160 test data
const RIPEMD160_INPUT_SMALL = "abc";
const RIPEMD160_INPUT_MEDIUM = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";

// BN128 test data from REVM benchmarks (hex-decoded)
const BN128_ADD_INPUT = [_]u8{
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const BN128_MUL_INPUT = [_]u8{
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// BN128 Pairing test data (multiple pairs)
const BN128_PAIRING_INPUT = [_]u8{
    0x2c, 0xf4, 0x4e, 0xa9, 0xf7, 0xa3, 0xc8, 0x89, 0xbc, 0x38, 0x71, 0x18, 0x45, 0xc4, 0xd4, 0x00,
    0xcc, 0x58, 0x98, 0x7e, 0x5b, 0x36, 0x85, 0x4c, 0x0e, 0xbb, 0xdf, 0xf8, 0xb2, 0xd4, 0x77, 0x8d,
    0x23, 0x6d, 0xeb, 0xf6, 0x58, 0xe7, 0xa9, 0x7d, 0x2d, 0x26, 0xf4, 0xc8, 0x07, 0x6c, 0x6c, 0xa8,
    0x90, 0x54, 0x96, 0x35, 0xe2, 0x42, 0xb0, 0xb7, 0xb2, 0x2d, 0x3b, 0x0a, 0x5e, 0xb4, 0x25, 0x2e,
    0x09, 0x03, 0x1b, 0x60, 0x30, 0xa8, 0x34, 0xfe, 0x8a, 0x28, 0xf4, 0x4b, 0xc0, 0x85, 0x2b, 0x98,
    0xa9, 0x7d, 0x5a, 0x43, 0x02, 0x96, 0xd7, 0xc8, 0x65, 0xbe, 0x98, 0x44, 0xfd, 0xb4, 0x97, 0xf9,
    0x2c, 0x18, 0x15, 0xc5, 0x82, 0x6a, 0x6c, 0x9c, 0x4a, 0xb7, 0x66, 0x97, 0x37, 0x94, 0xf9, 0xa6,
    0x9f, 0x5f, 0x35, 0x2b, 0x28, 0xad, 0xe3, 0xbc, 0x75, 0x4b, 0x79, 0x46, 0x46, 0x1f, 0x82, 0x0f,
    0x20, 0x3b, 0xa6, 0xf8, 0x1a, 0x43, 0xc4, 0xba, 0x50, 0x1c, 0x7a, 0x7b, 0x8e, 0x20, 0xc0, 0x14,
    0x28, 0xa4, 0x45, 0x4d, 0x14, 0x41, 0xf6, 0x2b, 0xb9, 0x5a, 0xa1, 0x41, 0xb1, 0x1f, 0x1f, 0x1b,
    0x1c, 0xc5, 0x34, 0x5c, 0x9c, 0xa8, 0x28, 0xa0, 0xd5, 0x2b, 0xa1, 0x82, 0xea, 0xfb, 0x16, 0x7a,
    0x29, 0x3a, 0x69, 0x8e, 0x8f, 0xe0, 0x43, 0x66, 0x80, 0x8f, 0xeb, 0x8f, 0x03, 0x3f, 0x3b, 0x52,
} ** 2; // 384 bytes (2 pairs)

// BLAKE2F test data (213 bytes)
const BLAKE2F_INPUT = [_]u8{
    0x00, 0x00, 0x00, 0x0c, // rounds (12)
    // h (64 bytes)
    0x48, 0xc9, 0xbd, 0xf2, 0x67, 0xe6, 0x09, 0x6a, 0x3b, 0xa7, 0xca, 0x84, 0x85, 0xae, 0x67, 0xbb,
    0x2b, 0xf8, 0x94, 0xfe, 0x72, 0xf3, 0x6e, 0x3c, 0xf1, 0x36, 0x1d, 0x5f, 0x3a, 0xf5, 0x4f, 0xa5,
    0xd1, 0x82, 0xe6, 0xad, 0x7f, 0x52, 0x0e, 0x51, 0x1f, 0x6c, 0x3e, 0x2b, 0x8c, 0x68, 0x05, 0x9b,
    0x6b, 0xbd, 0x41, 0xfb, 0xab, 0xd9, 0x83, 0x1f, 0x79, 0x21, 0x7e, 0x13, 0x19, 0xcd, 0xe0, 0x5b,
    // m (128 bytes)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // t (16 bytes)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // f (1 byte)
    0x01,
};

// KZG Point Evaluation test data (from EIP-4844 benchmarks)
const KZG_INPUT = [_]u8{
    // versioned_hash (32 bytes)
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
    // z (32 bytes)
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
    // y (32 bytes)
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
    // commitment (48 bytes)
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
    0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
    // proof (48 bytes)
    0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0,
    0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
    0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
};

// Benchmark functions

/// Benchmark ECRECOVER precompile
fn benchmarkEcrecover(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ecrecover_addr = Precompiles.Precompiles.get_address(.ecrecover) catch return;
    
    var result = precompiles_instance.run(ecrecover_addr, &ECRECOVER_INPUT, 3000) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark SHA256 with small input
fn benchmarkSha256Small(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const sha256_addr = Precompiles.Precompiles.get_address(.sha256) catch return;
    
    var result = precompiles_instance.run(sha256_addr, SHA256_INPUT_SMALL, 100) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark SHA256 with medium input
fn benchmarkSha256Medium(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const sha256_addr = Precompiles.Precompiles.get_address(.sha256) catch return;
    
    var result = precompiles_instance.run(sha256_addr, SHA256_INPUT_MEDIUM, 200) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark SHA256 with large input
fn benchmarkSha256Large(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const sha256_addr = Precompiles.Precompiles.get_address(.sha256) catch return;
    
    var result = precompiles_instance.run(sha256_addr, SHA256_INPUT_LARGE, 1000) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark RIPEMD160 with small input
fn benchmarkRipemd160Small(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ripemd160_addr = Precompiles.Precompiles.get_address(.ripemd160) catch return;
    
    var result = precompiles_instance.run(ripemd160_addr, RIPEMD160_INPUT_SMALL, 600) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark RIPEMD160 with medium input
fn benchmarkRipemd160Medium(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ripemd160_addr = Precompiles.Precompiles.get_address(.ripemd160) catch return;
    
    var result = precompiles_instance.run(ripemd160_addr, RIPEMD160_INPUT_MEDIUM, 720) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark IDENTITY precompile
fn benchmarkIdentity(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const identity_addr = Precompiles.Precompiles.get_address(.identity) catch return;
    
    var result = precompiles_instance.run(identity_addr, SHA256_INPUT_MEDIUM, 100) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark MODEXP precompile
fn benchmarkModexp(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const modexp_addr = Precompiles.Precompiles.get_address(.modexp) catch return;
    
    // Simple modexp input: base=3, exp=2, mod=5 (should return 4)
    const modexp_input = [_]u8{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // base_len = 1
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // exp_len = 1
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // mod_len = 1
        0x03, // base = 3
        0x02, // exp = 2
        0x05, // mod = 5
    };
    
    var result = precompiles_instance.run(modexp_addr, &modexp_input, 20000) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark BN128 Addition (EIP-196)
fn benchmarkBn128Add(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ecadd_addr = Precompiles.Precompiles.get_address(.ecadd) catch return;
    
    var result = precompiles_instance.run(ecadd_addr, &BN128_ADD_INPUT, 150) catch return; // Istanbul gas cost
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark BN128 Multiplication (EIP-196)
fn benchmarkBn128Mul(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ecmul_addr = Precompiles.Precompiles.get_address(.ecmul) catch return;
    
    var result = precompiles_instance.run(ecmul_addr, &BN128_MUL_INPUT, 6000) catch return; // Istanbul gas cost
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark BN128 Pairing (EIP-197)
fn benchmarkBn128Pairing(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const ecpairing_addr = Precompiles.Precompiles.get_address(.ecpairing) catch return;
    
    var result = precompiles_instance.run(ecpairing_addr, &BN128_PAIRING_INPUT, 100000) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark BLAKE2F precompile (EIP-152)
fn benchmarkBlake2f(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const blake2f_addr = Precompiles.Precompiles.get_address(.blake2f) catch return;
    
    var result = precompiles_instance.run(blake2f_addr, &BLAKE2F_INPUT, 12) catch return; // 1 gas per round
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark KZG Point Evaluation (EIP-4844)
fn benchmarkKzgPointEval(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const kzg_addr = Precompiles.Precompiles.get_address(.kzg_point_evaluation) catch return;
    
    var result = precompiles_instance.run(kzg_addr, &KZG_INPUT, 50000) catch return;
    defer result.deinit();
    
    std.mem.doNotOptimizeAway(&result);
}

/// Benchmark gas cost calculation overhead
fn benchmarkGasCostCalculation(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const sha256_addr = Precompiles.Precompiles.get_address(.sha256) catch return;
    
    // Benchmark just the gas cost calculation
    for (0..100) |_| {
        const cost = precompiles_instance.gas_cost(sha256_addr, SHA256_INPUT_MEDIUM);
        std.mem.doNotOptimizeAway(cost);
    }
}

/// Benchmark precompile address lookup
fn benchmarkAddressLookup(allocator: std.mem.Allocator) void {
    _ = allocator;
    
    // Benchmark address generation for all precompile types
    const precompile_types = [_]Precompiles.PrecompileType{
        .ecrecover, .sha256, .ripemd160, .identity, .modexp,
        .ecadd, .ecmul, .ecpairing, .blake2f, .kzg_point_evaluation,
    };
    
    for (precompile_types) |precompile_type| {
        const addr = Precompiles.Precompiles.get_address(precompile_type) catch return;
        std.mem.doNotOptimizeAway(&addr);
    }
}

/// Benchmark precompile existence checking
fn benchmarkContainsCheck(allocator: std.mem.Allocator) void {
    var precompiles_instance = Precompiles.Precompiles.create_latest(allocator) catch return;
    defer precompiles_instance.deinit();

    const sha256_addr = Precompiles.Precompiles.get_address(.sha256) catch return;
    const invalid_addr = [_]u8{0xFF} ** 20;
    
    // Check existence of valid and invalid addresses
    for (0..50) |_| {
        const exists1 = precompiles_instance.contains(sha256_addr);
        const exists2 = precompiles_instance.contains(invalid_addr);
        std.mem.doNotOptimizeAway(exists1);
        std.mem.doNotOptimizeAway(exists2);
    }
}

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print("REVM Precompiles Benchmarks\n", .{});
    try stdout.print("============================\n\n", .{});

    var bench = zbench.Benchmark.init(std.heap.page_allocator, .{});
    defer bench.deinit();

    // Core Cryptographic Precompiles (Frontier/Homestead)
    try bench.add("ECRECOVER", benchmarkEcrecover, .{});
    try bench.add("SHA256 (Small)", benchmarkSha256Small, .{});
    try bench.add("SHA256 (Medium)", benchmarkSha256Medium, .{});
    try bench.add("SHA256 (Large)", benchmarkSha256Large, .{});
    try bench.add("RIPEMD160 (Small)", benchmarkRipemd160Small, .{});
    try bench.add("RIPEMD160 (Medium)", benchmarkRipemd160Medium, .{});
    try bench.add("IDENTITY", benchmarkIdentity, .{});
    
    // Mathematical Operations (Byzantium)
    try bench.add("MODEXP", benchmarkModexp, .{});
    
    // BN128 Elliptic Curve Operations (Byzantium/Istanbul)
    try bench.add("BN128 ADD", benchmarkBn128Add, .{});
    try bench.add("BN128 MUL", benchmarkBn128Mul, .{});
    try bench.add("BN128 PAIRING", benchmarkBn128Pairing, .{});
    
    // Advanced Cryptography
    try bench.add("BLAKE2F", benchmarkBlake2f, .{});
    try bench.add("KZG Point Eval", benchmarkKzgPointEval, .{});
    
    // Infrastructure Benchmarks
    try bench.add("Gas Cost Calc", benchmarkGasCostCalculation, .{});
    try bench.add("Address Lookup", benchmarkAddressLookup, .{});
    try bench.add("Contains Check", benchmarkContainsCheck, .{});

    // Run benchmarks
    try stdout.print("Running benchmarks...\n\n", .{});
    try bench.run(stdout);
}