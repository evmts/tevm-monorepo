{"version":3,"sources":["../src/readCache.js","../src/writeCache.js","../src/resolveModuleAsync.js","../src/readCacheSync.js","../src/writeCacheSync.js","../src/resolveModuleSync.js","../src/bundler.js"],"names":["generateRuntime"],"mappings":"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","sourcesContent":["/**\n * @param {import('@tevm/compiler').Logger} logger\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @param {string} modulePath\n * @param {boolean} includeAst\n * @param {boolean} includeBytecode\n * @returns {ReturnType<import('@tevm/bundler-cache').Cache['readArtifacts']>}\n */\nexport const readCache = async (\n\tlogger,\n\tcache,\n\tmodulePath,\n\tincludeAst,\n\tincludeBytecode,\n) => {\n\ttry {\n\t\tconst cachedArtifacts = await cache.readArtifacts(modulePath)\n\n\t\tconst isCachedAsts = () =>\n\t\t\tcachedArtifacts?.asts && Object.keys(cachedArtifacts.asts).length > 0\n\t\tconst isCachedBytecode = () =>\n\t\t\tObject.values(cachedArtifacts?.artifacts ?? {}).some(\n\t\t\t\t(artifact) => artifact.evm.deployedBytecode,\n\t\t\t)\n\n\t\tif (!cachedArtifacts) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeAst && !isCachedAsts()) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeBytecode && !isCachedBytecode()) {\n\t\t\treturn undefined\n\t\t}\n\t\treturn cachedArtifacts\n\t} catch (e) {\n\t\tlogger.error(\n\t\t\t`there was an error in tevm plugin reading cache for ${modulePath}. Continuing without cache. This may hurt performance`,\n\t\t)\n\t\tlogger.error(/** @type any */ (e))\n\t\treturn undefined\n\t}\n}\n","/**\n * Writes the result of a bundler result to cache\n * @param {import('./types.js').Logger} logger\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @param {import('@tevm/compiler').ResolvedArtifacts} artifacts\n * @param {string} code\n * @param {string} modulePath\n * @param {string} moduleType\n * @param {boolean} writeArtifacts\n * @returns {Promise<void>}\n */\nexport const writeCache = async (\n\tlogger,\n\tcache,\n\tartifacts,\n\tcode,\n\tmodulePath,\n\tmoduleType,\n\t// This is kinda quick and dirty but works for now\n\t// we will skip writing artifacts if there is an error\n\t// but still write dts and mjs files since they always\n\t// fall back to generating an empty file with error messages\n\twriteArtifacts,\n) => {\n\t/**\n\t * @type {Array<Promise<any>>}\n\t */\n\tconst promises = []\n\tif (writeArtifacts) {\n\t\tpromises.push(cache.writeArtifacts(modulePath, artifacts))\n\t}\n\tif (moduleType === 'dts') {\n\t\tpromises.push(cache.writeDts(modulePath, code))\n\t} else if (moduleType === 'mjs') {\n\t\tpromises.push(cache.writeMjs(modulePath, code))\n\t} else {\n\t\tlogger.warn(`No caching for module type ${moduleType}} implemented yet`)\n\t}\n\tawait Promise.all(promises)\n}\n","import { readCache } from './readCache.js'\nimport { writeCache } from './writeCache.js'\nimport { resolveArtifacts } from '@tevm/compiler'\nimport { generateRuntime } from '@tevm/runtime'\nimport { runPromise } from 'effect/Effect'\n\n/**\n * @param {import('@tevm/compiler').Logger} logger\n * @param {import('@tevm/config').ResolvedCompilerConfig} config\n * @param {import('@tevm/compiler').FileAccessObject} fao\n * @param {import('@tevm/solc').Solc} solc\n * @param {string} modulePath\n * @param {string} basedir\n * @param {boolean} includeAst\n * @param {boolean} includeBytecode\n * @param {import('@tevm/runtime').ModuleType} moduleType\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @returns {Promise<import('./types.js').BundlerResult>} a promise that resolves to a bundler result object\n */\nexport const resolveModuleAsync = async (\n\tlogger,\n\tconfig,\n\tfao,\n\tsolc,\n\tmodulePath,\n\tbasedir,\n\tincludeAst,\n\tincludeBytecode,\n\tmoduleType,\n\tcache,\n) => {\n\tconst cachedResult = await readCache(\n\t\tlogger,\n\t\tcache,\n\t\tmodulePath,\n\t\tincludeAst,\n\t\tincludeBytecode,\n\t)\n\ttry {\n\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\tcachedResult ??\n\t\t\t(await resolveArtifacts(\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t))\n\t\tlet code = ''\n\t\tconst artifactsExist = artifacts && Object.keys(artifacts).length > 0\n\t\tif (artifactsExist) {\n\t\t\tcode = await runPromise(\n\t\t\t\tgenerateRuntime(artifacts, moduleType, includeBytecode),\n\t\t\t)\n\t\t} else {\n\t\t\tconst message = `there were no artifacts for ${modulePath}. This is likely a bug in tevm`\n\t\t\tcode = `// ${message}`\n\t\t\tlogger.warn(message)\n\t\t}\n\n\t\t// The `writeCache` function is intentionally not awaited to allow non-blocking cache writes.\n\t\t// This enables the rest of the module resolution to proceed without waiting for the cache operation to complete.\n\t\twriteCache(\n\t\t\tlogger,\n\t\t\tcache,\n\t\t\t{ solcInput, solcOutput, asts, artifacts, modules },\n\t\t\tcode,\n\t\t\tmodulePath,\n\t\t\tmoduleType,\n\t\t\t// This is kinda quick and dirty but works for now\n\t\t\t// We are skipping writing artifacts if there is an error\n\t\t\t// But still write dts and mjs files since they always\n\t\t\t// fall back to generating an empty file with error messages\n\t\t\tartifactsExist,\n\t\t).catch((e) => {\n\t\t\tlogger.error(e)\n\t\t\tlogger.error(\n\t\t\t\t'there was an error writing to the cache. This may cause peformance issues',\n\t\t\t)\n\t\t})\n\n\t\treturn { solcInput, solcOutput, asts, modules, code }\n\t} catch (e) {\n\t\tlogger.error(`there was an error in tevm plugin resolving .${moduleType}`)\n\t\tlogger.error(/** @type any */ (e))\n\t\tthrow e\n\t}\n}\n","/**\n * @param {import('@tevm/compiler').Logger} logger\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @param {string} modulePath\n * @param {boolean} includeAst\n * @param {boolean} includeBytecode\n * @returns {ReturnType<import('@tevm/bundler-cache').Cache['readArtifactsSync']>}\n */\nexport const readCacheSync = (\n\tlogger,\n\tcache,\n\tmodulePath,\n\tincludeAst,\n\tincludeBytecode,\n) => {\n\ttry {\n\t\tconst cachedArtifacts = cache.readArtifactsSync(modulePath)\n\n\t\tconst isCachedAsts = () =>\n\t\t\tcachedArtifacts?.asts && Object.keys(cachedArtifacts.asts).length > 0\n\t\tconst isCachedBytecode = () =>\n\t\t\tObject.values(cachedArtifacts?.artifacts ?? {}).some(\n\t\t\t\t(artifact) => artifact.evm.deployedBytecode,\n\t\t\t)\n\n\t\tif (!cachedArtifacts) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeAst && !isCachedAsts()) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeBytecode && !isCachedBytecode()) {\n\t\t\treturn undefined\n\t\t}\n\t\treturn cachedArtifacts\n\t} catch (e) {\n\t\tlogger.error(\n\t\t\t`there was an error in tevm plugin reading cache for ${modulePath}. Continuing without cache. This may hurt performance`,\n\t\t)\n\t\tlogger.error(/** @type any */ (e))\n\t\treturn undefined\n\t}\n}\n","/**\n * Writes the result of a bundler result to cache\n * @param {import('./types.js').Logger} logger\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @param {import('@tevm/compiler').ResolvedArtifacts} artifacts\n * @param {string} code\n * @param {string} modulePath\n * @param {string} moduleType\n * @param {boolean} writeArtifacts\n * @returns {void}\n */\nexport const writeCacheSync = (\n\tlogger,\n\tcache,\n\tartifacts,\n\tcode,\n\tmodulePath,\n\tmoduleType,\n\t// This is kinda quick and dirty but works for now\n\t// we will skip writing artifacts if there is an error\n\t// but still write dts and mjs files since they always\n\t// fall back to generating an empty file with error messages\n\twriteArtifacts,\n) => {\n\tif (writeArtifacts) {\n\t\tcache.writeArtifactsSync(modulePath, artifacts)\n\t}\n\tif (moduleType === 'dts') {\n\t\tcache.writeDts(modulePath, code)\n\t} else if (moduleType === 'mjs') {\n\t\tcache.writeMjs(modulePath, code)\n\t} else {\n\t\tlogger.warn(`No caching for module type ${moduleType}} implemented yet`)\n\t}\n}\n","import { readCacheSync } from './readCacheSync.js'\nimport { writeCacheSync } from './writeCacheSync.js'\nimport { resolveArtifactsSync } from '@tevm/compiler'\nimport { generateRuntime } from '@tevm/runtime'\nimport { runSync } from 'effect/Effect'\n\n/**\n * @param {import('@tevm/compiler').Logger} logger\n * @param {import('@tevm/config').ResolvedCompilerConfig} config\n * @param {import('@tevm/compiler').FileAccessObject} fao\n * @param {import('@tevm/solc').Solc} solc\n * @param {string} modulePath\n * @param {string} basedir\n * @param {boolean} includeAst\n * @param {boolean} includeBytecode\n * @param {import('@tevm/runtime').ModuleType} moduleType\n * @param {import('@tevm/bundler-cache').Cache} cache\n * @returns {import('./types.js').BundlerResult} a bundler result object\n */\nexport const resolveModuleSync = (\n\tlogger,\n\tconfig,\n\tfao,\n\tsolc,\n\tmodulePath,\n\tbasedir,\n\tincludeAst,\n\tincludeBytecode,\n\tmoduleType,\n\tcache,\n) => {\n\tconst cachedResult = readCacheSync(\n\t\tlogger,\n\t\tcache,\n\t\tmodulePath,\n\t\tincludeAst,\n\t\tincludeBytecode,\n\t)\n\ttry {\n\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\tcachedResult ??\n\t\t\tresolveArtifactsSync(\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t)\n\t\tlet code = ''\n\t\tconst artifactsExist = artifacts && Object.keys(artifacts).length > 0\n\t\tif (artifactsExist) {\n\t\t\tcode = runSync(generateRuntime(artifacts, moduleType, includeBytecode))\n\t\t} else {\n\t\t\tconst message = `there were no artifacts for ${modulePath}. This is likely a bug in tevm`\n\t\t\tcode = `// ${message}`\n\t\t\tlogger.warn(message)\n\t\t}\n\n\t\twriteCacheSync(\n\t\t\tlogger,\n\t\t\tcache,\n\t\t\t{ solcInput, solcOutput, asts, artifacts, modules },\n\t\t\tcode,\n\t\t\tmodulePath,\n\t\t\tmoduleType,\n\t\t\t// This is kinda quick and dirty but works for now\n\t\t\t// We are skipping writing artifacts if there is an error\n\t\t\t// But still write dts and mjs files since they always\n\t\t\t// fall back to generating an empty file with error messages\n\t\t\tartifactsExist,\n\t\t)\n\n\t\treturn { solcInput, solcOutput, asts, modules, code }\n\t} catch (e) {\n\t\tlogger.error(`there was an error in tevm plugin resolving .${moduleType}`)\n\t\tlogger.error(/** @type any */ (e))\n\t\tthrow e\n\t}\n}\n","import { resolveModuleAsync } from './resolveModuleAsync.js'\nimport { resolveModuleSync } from './resolveModuleSync.js'\n\n/**\n * The base bundler instance used within tevm to generate JavaScript and TypeScript files\n * from solidity files. This is used internally by all other tevm build tooling including\n * the ts-plugin, the webpack plugin, the bun plugin, the vite plugin, and more.\n * @param config - The tevm config. Can be loaded with `loadConfig()`\n * @param logger - The logger to use for logging. Can be `console`\n * @param fao - The file access object to use for reading and writing files. Can use fs to fill this out\n * @param solc - The solc compiler to use. Can be loaded with `createSolc()`\n * @param cache - The cache to use. Can be created with `createCache()`\n * @type {import('./types.js').Bundler}\n *\n * Since ts-plugin must be synchronous, this bundler supports both async and sync methods.\n *\n * To use initialize the bundler and then call a resolve* methods\n *\n * @example\n * ```typescript\n * import { bundler } from '@tevm/base-bundler-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n * import { readFile, writeFile } from 'fs/promises'\n * import { readFileSync, writeFileSync, existsSync } from 'fs'\n * import { createSolc } from '@tevm/solc'\n * import { loadConfig } from '@tevm/config'\n *\n * const fao = {\n *   readFile,\n *   writeFile,\n *   readFileSync,\n *   writeFileSync,\n *   existsSync,\n *   // may need more methods\n * }\n *\n * const b = bundler(await loadConfig(), console, fao, await createSolc(), createCache())\n *\n * const path = '../contracts/ERC20.sol'\n *\n * const { abi, bytecode } = await b.resolveTs(path, __dirname, true, true)\n * ```\n */\nexport const bundler = (config, logger, fao, solc, cache) => {\n\treturn {\n\t\tname: bundler.name,\n\t\tconfig,\n\t\tresolveDts: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'dts',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveDtsSync: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'dts',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveTsModuleSync: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'ts',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveTsModule: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'ts',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveCjsModuleSync: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'cjs',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveCjsModule: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'cjs',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveEsmModuleSync: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'mjs',\n\t\t\t\tcache,\n\t\t\t),\n\t\tresolveEsmModule: (modulePath, basedir, includeAst, includeBytecode) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'mjs',\n\t\t\t\tcache,\n\t\t\t),\n\t}\n}\n"]}