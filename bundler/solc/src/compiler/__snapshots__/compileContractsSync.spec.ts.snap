// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`compileContractSync > should successfully compile a contract without errors 1`] = `
"{
  \\"artifacts\\": {
    \\"WagmiMintExample\\": {
      \\"abi\\": [
        {
          \\"inputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"constructor\\"
        },
        {
          \\"anonymous\\": false,
          \\"inputs\\": [
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"owner\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"approved\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"Approval\\",
          \\"type\\": \\"event\\"
        },
        {
          \\"anonymous\\": false,
          \\"inputs\\": [
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"owner\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"operator\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": false,
              \\"internalType\\": \\"bool\\",
              \\"name\\": \\"approved\\",
              \\"type\\": \\"bool\\"
            }
          ],
          \\"name\\": \\"ApprovalForAll\\",
          \\"type\\": \\"event\\"
        },
        {
          \\"anonymous\\": false,
          \\"inputs\\": [
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"from\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"to\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"indexed\\": true,
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"Transfer\\",
          \\"type\\": \\"event\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"to\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"approve\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"owner\\",
              \\"type\\": \\"address\\"
            }
          ],
          \\"name\\": \\"balanceOf\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"getApproved\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"address\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"owner\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"operator\\",
              \\"type\\": \\"address\\"
            }
          ],
          \\"name\\": \\"isApprovedForAll\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"bool\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"bool\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [],
          \\"name\\": \\"mint\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"mint\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [],
          \\"name\\": \\"name\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"string\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"string\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"ownerOf\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"address\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"from\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"to\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"safeTransferFrom\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"from\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"to\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            },
            {
              \\"internalType\\": \\"bytes\\",
              \\"name\\": \\"data\\",
              \\"type\\": \\"bytes\\"
            }
          ],
          \\"name\\": \\"safeTransferFrom\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"operator\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"bool\\",
              \\"name\\": \\"approved\\",
              \\"type\\": \\"bool\\"
            }
          ],
          \\"name\\": \\"setApprovalForAll\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"bytes4\\",
              \\"name\\": \\"interfaceId\\",
              \\"type\\": \\"bytes4\\"
            }
          ],
          \\"name\\": \\"supportsInterface\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"bool\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"bool\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [],
          \\"name\\": \\"symbol\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"string\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"string\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"tokenURI\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"string\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"string\\"
            }
          ],
          \\"stateMutability\\": \\"pure\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [],
          \\"name\\": \\"totalSupply\\",
          \\"outputs\\": [
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"stateMutability\\": \\"view\\",
          \\"type\\": \\"function\\"
        },
        {
          \\"inputs\\": [
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"from\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"address\\",
              \\"name\\": \\"to\\",
              \\"type\\": \\"address\\"
            },
            {
              \\"internalType\\": \\"uint256\\",
              \\"name\\": \\"tokenId\\",
              \\"type\\": \\"uint256\\"
            }
          ],
          \\"name\\": \\"transferFrom\\",
          \\"outputs\\": [],
          \\"stateMutability\\": \\"nonpayable\\",
          \\"type\\": \\"function\\"
        }
      ],
      \\"userdoc\\": {
        \\"kind\\": \\"user\\",
        \\"methods\\": {
          \\"mint()\\": {
            \\"notice\\": \\"Allows an address to mint\\"
          },
          \\"mint(uint256)\\": {
            \\"notice\\": \\"Returns the token URI for a given token by ID\\"
          },
          \\"tokenURI(uint256)\\": {
            \\"notice\\": \\"Returns the token URI for a given token by ID\\"
          }
        },
        \\"notice\\": \\"An example token original from the wagmi template\\",
        \\"version\\": 1
      }
    }
  },
  \\"modules\\": {
    \\"./Contract.sol\\": {
      \\"id\\": \\"./Contract.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\npragma solidity >0.8.16;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n// import \\\\\\"this shouldn't be imorted\\\\\\";\\\\n\\\\n/// @author Wagmi\\\\n/// @author EVMts\\\\n/// @title  WagmiMintExample\\\\n/// @notice An example token original from the wagmi template\\\\ncontract WagmiMintExample is ERC721 {\\\\n    uint256 public totalSupply;\\\\n\\\\n// import \\\\\\"@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n    uint256 private nextTokenId = 0;\\\\n\\\\n    constructor() ERC721(\\\\\\"wagmi\\\\\\", \\\\\\"WAGMI\\\\\\") {}\\\\n\\\\n    /// @notice Allows an address to mint\\\\n    function mint() external {\\\\n        uint256 tokenId = nextTokenId;\\\\n        while (_exists(tokenId)) {\\\\n            unchecked {\\\\n                tokenId++;\\\\n            }\\\\n        }\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n            nextTokenId = tokenId + 1;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to mint.\\\\n    function mint(uint256 tokenId) external {\\\\n        require(!_exists(tokenId), \\\\\\"Token ID is taken\\\\\\");\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to query.\\\\n    /// @return uri_ Token URI for the given token by ID.\\\\n    function tokenURI(\\\\n        uint256 tokenId\\\\n    ) public pure override returns (string memory) {\\\\n        uint256 foregroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"foreground\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        uint256 backgroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"background\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        string memory json = Base64.encode(\\\\n            bytes(\\\\n                abi.encodePacked(\\\\n                    '{\\\\\\"name\\\\\\": \\\\\\"wagmi #',\\\\n                    toString(tokenId),\\\\n                    '\\\\\\", \\\\\\"image\\\\\\": \\\\\\"data:image/svg+xml;base64,',\\\\n                    Base64.encode(\\\\n                        bytes(\\\\n                            abi.encodePacked(\\\\n                                '<svg xmlns=\\\\\\"http://www.w3.org/2000/svg\\\\\\" width=\\\\\\"1024\\\\\\" height=\\\\\\"1024\\\\\\" fill=\\\\\\"none\\\\\\"><path fill=\\\\\\"hsl(',\\\\n                                toString(foregroundHue),\\\\n                                ', 100%, 10%)\\\\\\" d=\\\\\\"M0 0h1024v1024H0z\\\\\\" /><g fill=\\\\\\"hsl(',\\\\n                                toString(backgroundHue),\\\\n                                ', 100%, 90%)\\\\\\"><path d=\\\\\\"M903 437.5c0 9.113-7.388 16.5-16.5 16.5s-16.5-7.387-16.5-16.5 7.388-16.5 16.5-16.5 16.5 7.387 16.5 16.5zM698.529 566c6.921 0 12.53-5.596 12.53-12.5v-50c0-6.904 5.609-12.5 12.529-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.53 12.5s12.529-5.596 12.529-12.5v-50c0-6.904 5.609-12.5 12.53-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.529 12.5h37.589c6.92 0 12.529-5.596 12.529-12.5v-75c0-6.904-5.609-12.5-12.529-12.5s-12.53 5.596-12.53 12.5v56.25a6.264 6.264 0 1 1-12.529 0V478.5c0-6.904-5.609-12.5-12.53-12.5H698.529c-6.92 0-12.529 5.596-12.529 12.5v75c0 6.904 5.609 12.5 12.529 12.5z\\\\\\" /><path d=\\\\\\"M157.655 541c-6.932 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.619-12.5-12.551-12.5S120 471.596 120 478.5v75c0 6.904 5.62 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-50c0-6.904 5.619-12.5 12.552-12.5h144.345c3.465 0 6.276 2.798 6.276 6.25s-2.811 6.25-6.276 6.25H320.828c-6.933 0-12.552 5.596-12.552 12.5v37.5c0 6.904 5.619 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-75c0-6.904-5.619-12.5-12.552-12.5H283.172c-6.932 0-12.551 5.596-12.551 12.5v50c0 6.904-5.619 12.5-12.552 12.5h-25.103c-6.933 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.62-12.5-12.552-12.5s-12.552 5.596-12.552 12.5v50c0 6.904-5.619 12.5-12.551 12.5h-25.104zm301.242-6.25c0 3.452-2.811 6.25-6.276 6.25H339.655c-3.465 0-6.276-2.798-6.276-6.25s2.811-6.25 6.276-6.25h112.966c3.465 0 6.276 2.798 6.276 6.25zM497 553.818c0 6.929 5.628 12.546 12.571 12.546h132a6.28 6.28 0 0 1 6.286 6.272 6.28 6.28 0 0 1-6.286 6.273h-132c-6.943 0-12.571 5.616-12.571 12.546A12.56 12.56 0 0 0 509.571 604h150.858c6.943 0 12.571-5.616 12.571-12.545v-112.91c0-6.928-5.628-12.545-12.571-12.545H509.571c-6.943 0-12.571 5.617-12.571 12.545v75.273zm37.714-62.727c-6.943 0-12.571 5.617-12.571 12.545v25.091c0 6.929 5.628 12.546 12.571 12.546h100.572c6.943 0 12.571-5.617 12.571-12.546v-25.091c0-6.928-5.628-12.545-12.571-12.545H534.714z\\\\\\" fill-rule=\\\\\\"evenodd\\\\\\" /></g></svg>'\\\\n                            )\\\\n                        )\\\\n                    ),\\\\n                    '\\\\\\"}'\\\\n                )\\\\n            )\\\\n        );\\\\n        string memory output = string(\\\\n            abi.encodePacked(\\\\\\"data:application/json;base64,\\\\\\", json)\\\\n        );\\\\n        return output;\\\\n    }\\\\n\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\\\n\\\\n        if (value == 0) {\\\\n            return \\\\\\"0\\\\\\";\\\\n        }\\\\n        uint256 temp = value;\\\\n        uint256 digits;\\\\n        while (temp != 0) {\\\\n            digits++;\\\\n            temp /= 10;\\\\n        }\\\\n        bytes memory buffer = new bytes(digits);\\\\n        while (value != 0) {\\\\n            digits -= 1;\\\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\\\n            value /= 10;\\\\n        }\\\\n        return string(buffer);\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\npragma solidity >0.8.16;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n// import \\\\\\"this shouldn't be imorted\\\\\\";\\\\n\\\\n/// @author Wagmi\\\\n/// @author EVMts\\\\n/// @title  WagmiMintExample\\\\n/// @notice An example token original from the wagmi template\\\\ncontract WagmiMintExample is ERC721 {\\\\n    uint256 public totalSupply;\\\\n\\\\n// import \\\\\\"@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n    uint256 private nextTokenId = 0;\\\\n\\\\n    constructor() ERC721(\\\\\\"wagmi\\\\\\", \\\\\\"WAGMI\\\\\\") {}\\\\n\\\\n    /// @notice Allows an address to mint\\\\n    function mint() external {\\\\n        uint256 tokenId = nextTokenId;\\\\n        while (_exists(tokenId)) {\\\\n            unchecked {\\\\n                tokenId++;\\\\n            }\\\\n        }\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n            nextTokenId = tokenId + 1;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to mint.\\\\n    function mint(uint256 tokenId) external {\\\\n        require(!_exists(tokenId), \\\\\\"Token ID is taken\\\\\\");\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to query.\\\\n    /// @return uri_ Token URI for the given token by ID.\\\\n    function tokenURI(\\\\n        uint256 tokenId\\\\n    ) public pure override returns (string memory) {\\\\n        uint256 foregroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"foreground\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        uint256 backgroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"background\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        string memory json = Base64.encode(\\\\n            bytes(\\\\n                abi.encodePacked(\\\\n                    '{\\\\\\"name\\\\\\": \\\\\\"wagmi #',\\\\n                    toString(tokenId),\\\\n                    '\\\\\\", \\\\\\"image\\\\\\": \\\\\\"data:image/svg+xml;base64,',\\\\n                    Base64.encode(\\\\n                        bytes(\\\\n                            abi.encodePacked(\\\\n                                '<svg xmlns=\\\\\\"http://www.w3.org/2000/svg\\\\\\" width=\\\\\\"1024\\\\\\" height=\\\\\\"1024\\\\\\" fill=\\\\\\"none\\\\\\"><path fill=\\\\\\"hsl(',\\\\n                                toString(foregroundHue),\\\\n                                ', 100%, 10%)\\\\\\" d=\\\\\\"M0 0h1024v1024H0z\\\\\\" /><g fill=\\\\\\"hsl(',\\\\n                                toString(backgroundHue),\\\\n                                ', 100%, 90%)\\\\\\"><path d=\\\\\\"M903 437.5c0 9.113-7.388 16.5-16.5 16.5s-16.5-7.387-16.5-16.5 7.388-16.5 16.5-16.5 16.5 7.387 16.5 16.5zM698.529 566c6.921 0 12.53-5.596 12.53-12.5v-50c0-6.904 5.609-12.5 12.529-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.53 12.5s12.529-5.596 12.529-12.5v-50c0-6.904 5.609-12.5 12.53-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.529 12.5h37.589c6.92 0 12.529-5.596 12.529-12.5v-75c0-6.904-5.609-12.5-12.529-12.5s-12.53 5.596-12.53 12.5v56.25a6.264 6.264 0 1 1-12.529 0V478.5c0-6.904-5.609-12.5-12.53-12.5H698.529c-6.92 0-12.529 5.596-12.529 12.5v75c0 6.904 5.609 12.5 12.529 12.5z\\\\\\" /><path d=\\\\\\"M157.655 541c-6.932 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.619-12.5-12.551-12.5S120 471.596 120 478.5v75c0 6.904 5.62 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-50c0-6.904 5.619-12.5 12.552-12.5h144.345c3.465 0 6.276 2.798 6.276 6.25s-2.811 6.25-6.276 6.25H320.828c-6.933 0-12.552 5.596-12.552 12.5v37.5c0 6.904 5.619 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-75c0-6.904-5.619-12.5-12.552-12.5H283.172c-6.932 0-12.551 5.596-12.551 12.5v50c0 6.904-5.619 12.5-12.552 12.5h-25.103c-6.933 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.62-12.5-12.552-12.5s-12.552 5.596-12.552 12.5v50c0 6.904-5.619 12.5-12.551 12.5h-25.104zm301.242-6.25c0 3.452-2.811 6.25-6.276 6.25H339.655c-3.465 0-6.276-2.798-6.276-6.25s2.811-6.25 6.276-6.25h112.966c3.465 0 6.276 2.798 6.276 6.25zM497 553.818c0 6.929 5.628 12.546 12.571 12.546h132a6.28 6.28 0 0 1 6.286 6.272 6.28 6.28 0 0 1-6.286 6.273h-132c-6.943 0-12.571 5.616-12.571 12.546A12.56 12.56 0 0 0 509.571 604h150.858c6.943 0 12.571-5.616 12.571-12.545v-112.91c0-6.928-5.628-12.545-12.571-12.545H509.571c-6.943 0-12.571 5.617-12.571 12.545v75.273zm37.714-62.727c-6.943 0-12.571 5.617-12.571 12.545v25.091c0 6.929 5.628 12.546 12.571 12.546h100.572c6.943 0 12.571-5.617 12.571-12.546v-25.091c0-6.928-5.628-12.545-12.571-12.545H534.714z\\\\\\" fill-rule=\\\\\\"evenodd\\\\\\" /></g></svg>'\\\\n                            )\\\\n                        )\\\\n                    ),\\\\n                    '\\\\\\"}'\\\\n                )\\\\n            )\\\\n        );\\\\n        string memory output = string(\\\\n            abi.encodePacked(\\\\\\"data:application/json;base64,\\\\\\", json)\\\\n        );\\\\n        return output;\\\\n    }\\\\n\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\\\n\\\\n        if (value == 0) {\\\\n            return \\\\\\"0\\\\\\";\\\\n        }\\\\n        uint256 temp = value;\\\\n        uint256 digits;\\\\n        while (temp != 0) {\\\\n            digits++;\\\\n            temp /= 10;\\\\n        }\\\\n        bytes memory buffer = new bytes(digits);\\\\n        while (value != 0) {\\\\n            digits -= 1;\\\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\\\n            value /= 10;\\\\n        }\\\\n        return string(buffer);\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides a set of functions to operate with Base64 strings.\\\\n *\\\\n * _Available since v4.5._\\\\n */\\\\nlibrary Base64 {\\\\n    /**\\\\n     * @dev Base64 Encoding/Decoding Table\\\\n     */\\\\n    string internal constant _TABLE = \\\\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\\\\";\\\\n\\\\n    /**\\\\n     * @dev Converts a \`bytes\` to its Bytes64 \`string\` representation.\\\\n     */\\\\n    function encode(bytes memory data) internal pure returns (string memory) {\\\\n        /**\\\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\\\n         */\\\\n        if (data.length == 0) return \\\\\\"\\\\\\";\\\\n\\\\n        // Loads the table into memory\\\\n        string memory table = _TABLE;\\\\n\\\\n        // Encoding takes 3 bytes chunks of binary data from \`bytes\` data parameter\\\\n        // and split into 4 numbers of 6 bits.\\\\n        // The final Base64 length should be \`bytes\` data length multiplied by 4/3 rounded up\\\\n        // - \`data.length + 2\`  -> Round up\\\\n        // - \`/ 3\`              -> Number of 3-bytes chunks\\\\n        // - \`4 *\`              -> 4 characters for each chunk\\\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\\\n\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            // Prepare the lookup table (skip the first \\\\\\"length\\\\\\" byte)\\\\n            let tablePtr := add(table, 1)\\\\n\\\\n            // Prepare result pointer, jump over length\\\\n            let resultPtr := add(result, 32)\\\\n\\\\n            // Run over the input, 3 bytes at a time\\\\n            for {\\\\n                let dataPtr := data\\\\n                let endPtr := add(data, mload(data))\\\\n            } lt(dataPtr, endPtr) {\\\\n\\\\n            } {\\\\n                // Advance 3 bytes\\\\n                dataPtr := add(dataPtr, 3)\\\\n                let input := mload(dataPtr)\\\\n\\\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\\\n                // and apply logical AND with 0x3F which is the number of\\\\n                // the previous character in the ASCII table prior to the Base64 Table\\\\n                // The result is then added to the table to get the character to write,\\\\n                // and finally write it in the result pointer but with a left shift\\\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n            }\\\\n\\\\n            // When data \`bytes\` is not exactly 3 bytes long\\\\n            // it is padded with \`=\` characters at the end\\\\n            switch mod(mload(data), 3)\\\\n            case 1 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n                mstore8(sub(resultPtr, 2), 0x3d)\\\\n            }\\\\n            case 2 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n            }\\\\n        }\\\\n\\\\n        return result;\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides a set of functions to operate with Base64 strings.\\\\n *\\\\n * _Available since v4.5._\\\\n */\\\\nlibrary Base64 {\\\\n    /**\\\\n     * @dev Base64 Encoding/Decoding Table\\\\n     */\\\\n    string internal constant _TABLE = \\\\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\\\\";\\\\n\\\\n    /**\\\\n     * @dev Converts a \`bytes\` to its Bytes64 \`string\` representation.\\\\n     */\\\\n    function encode(bytes memory data) internal pure returns (string memory) {\\\\n        /**\\\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\\\n         */\\\\n        if (data.length == 0) return \\\\\\"\\\\\\";\\\\n\\\\n        // Loads the table into memory\\\\n        string memory table = _TABLE;\\\\n\\\\n        // Encoding takes 3 bytes chunks of binary data from \`bytes\` data parameter\\\\n        // and split into 4 numbers of 6 bits.\\\\n        // The final Base64 length should be \`bytes\` data length multiplied by 4/3 rounded up\\\\n        // - \`data.length + 2\`  -> Round up\\\\n        // - \`/ 3\`              -> Number of 3-bytes chunks\\\\n        // - \`4 *\`              -> 4 characters for each chunk\\\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\\\n\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            // Prepare the lookup table (skip the first \\\\\\"length\\\\\\" byte)\\\\n            let tablePtr := add(table, 1)\\\\n\\\\n            // Prepare result pointer, jump over length\\\\n            let resultPtr := add(result, 32)\\\\n\\\\n            // Run over the input, 3 bytes at a time\\\\n            for {\\\\n                let dataPtr := data\\\\n                let endPtr := add(data, mload(data))\\\\n            } lt(dataPtr, endPtr) {\\\\n\\\\n            } {\\\\n                // Advance 3 bytes\\\\n                dataPtr := add(dataPtr, 3)\\\\n                let input := mload(dataPtr)\\\\n\\\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\\\n                // and apply logical AND with 0x3F which is the number of\\\\n                // the previous character in the ASCII table prior to the Base64 Table\\\\n                // The result is then added to the table to get the character to write,\\\\n                // and finally write it in the result pointer but with a left shift\\\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n            }\\\\n\\\\n            // When data \`bytes\` is not exactly 3 bytes long\\\\n            // it is padded with \`=\` characters at the end\\\\n            switch mod(mload(data), 3)\\\\n            case 1 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n                mstore8(sub(resultPtr, 2), 0x3d)\\\\n            }\\\\n            case 2 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n            }\\\\n        }\\\\n\\\\n        return result;\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"./IERC721.sol\\\\\\";\\\\nimport \\\\\\"./IERC721Receiver.sol\\\\\\";\\\\nimport \\\\\\"./extensions/IERC721Metadata.sol\\\\\\";\\\\nimport \\\\\\"../../utils/Address.sol\\\\\\";\\\\nimport \\\\\\"../../utils/Context.sol\\\\\\";\\\\nimport \\\\\\"../../utils/Strings.sol\\\\\\";\\\\nimport \\\\\\"../../utils/introspection/ERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\\\n * {ERC721Enumerable}.\\\\n */\\\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\\\n    using Address for address;\\\\n    using Strings for uint256;\\\\n\\\\n    // Token name\\\\n    string private _name;\\\\n\\\\n    // Token symbol\\\\n    string private _symbol;\\\\n\\\\n    // Mapping from token ID to owner address\\\\n    mapping(uint256 => address) private _owners;\\\\n\\\\n    // Mapping owner address to token count\\\\n    mapping(address => uint256) private _balances;\\\\n\\\\n    // Mapping from token ID to approved address\\\\n    mapping(uint256 => address) private _tokenApprovals;\\\\n\\\\n    // Mapping from owner to operator approvals\\\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\\\n\\\\n    /**\\\\n     * @dev Initializes the contract by setting a \`name\` and a \`symbol\` to the token collection.\\\\n     */\\\\n    constructor(string memory name_, string memory symbol_) {\\\\n        _name = name_;\\\\n        _symbol = symbol_;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\\\n        return\\\\n            interfaceId == type(IERC721).interfaceId ||\\\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-balanceOf}.\\\\n     */\\\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\\\n        require(owner != address(0), \\\\\\"ERC721: address zero is not a valid owner\\\\\\");\\\\n        return _balances[owner];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-ownerOf}.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\\\n        address owner = _ownerOf(tokenId);\\\\n        require(owner != address(0), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n        return owner;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-name}.\\\\n     */\\\\n    function name() public view virtual override returns (string memory) {\\\\n        return _name;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-symbol}.\\\\n     */\\\\n    function symbol() public view virtual override returns (string memory) {\\\\n        return _symbol;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-tokenURI}.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        string memory baseURI = _baseURI();\\\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\\\n     * token will be the concatenation of the \`baseURI\` and the \`tokenId\`. Empty\\\\n     * by default, can be overridden in child contracts.\\\\n     */\\\\n    function _baseURI() internal view virtual returns (string memory) {\\\\n        return \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-approve}.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) public virtual override {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        require(to != owner, \\\\\\"ERC721: approval to current owner\\\\\\");\\\\n\\\\n        require(\\\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\\\n            \\\\\\"ERC721: approve caller is not token owner or approved for all\\\\\\"\\\\n        );\\\\n\\\\n        _approve(to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-getApproved}.\\\\n     */\\\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        return _tokenApprovals[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-setApprovalForAll}.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\\\n        _setApprovalForAll(_msgSender(), operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-isApprovedForAll}.\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\\\n        return _operatorApprovals[owner][operator];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-transferFrom}.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        //solhint-disable-next-line max-line-length\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n\\\\n        _transfer(from, to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        safeTransferFrom(from, to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n        _safeTransfer(from, to, tokenId, data);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * \`data\` is additional data, it has no specified format and it is sent in call to \`to\`.\\\\n     *\\\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _transfer(from, to, tokenId);\\\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\`. Does NOT revert if token doesn't exist\\\\n     */\\\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\\\n        return _owners[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`tokenId\` exists.\\\\n     *\\\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Tokens start existing when they are minted (\`_mint\`),\\\\n     * and stop existing when they are burned (\`_burn\`).\\\\n     */\\\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\\\n        return _ownerOf(tokenId) != address(0);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`spender\` is allowed to manage \`tokenId\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\\\n        _safeMint(to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[\`_safeMint\`], with an additional \`data\` parameter which is\\\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _mint(to, tokenId);\\\\n        require(\\\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\\\n            \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\"\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - \`to\` cannot be the zero address.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _mint(address to, uint256 tokenId) internal virtual {\\\\n        require(to != address(0), \\\\\\"ERC721: mint to the zero address\\\\\\");\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not minted by \`_beforeTokenTransfer\` hook\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        unchecked {\\\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\\\n            // Given that tokens are minted one by one, it is impossible in practice that\\\\n            // this ever happens. Might change if we allow batch minting.\\\\n            // The ERC fails to describe this case.\\\\n            _balances[to] += 1;\\\\n        }\\\\n\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(address(0), to, tokenId);\\\\n\\\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Destroys \`tokenId\`.\\\\n     * The approval is cleared when the token is burned.\\\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _burn(uint256 tokenId) internal virtual {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\\\n\\\\n        // Update ownership in case tokenId was transferred by \`_beforeTokenTransfer\` hook\\\\n        owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        // Clear approvals\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\\\n            // out than the owner initially received through minting and transferring in.\\\\n            _balances[owner] -= 1;\\\\n        }\\\\n        delete _owners[tokenId];\\\\n\\\\n        emit Transfer(owner, address(0), tokenId);\\\\n\\\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` from \`from\` to \`to\`.\\\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n        require(to != address(0), \\\\\\"ERC721: transfer to the zero address\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not transferred by \`_beforeTokenTransfer\` hook\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n\\\\n        // Clear approvals from the previous owner\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // \`_balances[from]\` cannot overflow for the same reason as described in \`_burn\`:\\\\n            // \`from\`'s balance is the number of token held, which is at least one before the current\\\\n            // transfer.\\\\n            // \`_balances[to]\` could overflow in the conditions described in \`_mint\`. That would require\\\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\\\n            _balances[from] -= 1;\\\\n            _balances[to] += 1;\\\\n        }\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(from, to, tokenId);\\\\n\\\\n        _afterTokenTransfer(from, to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`to\` to operate on \`tokenId\`\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function _approve(address to, uint256 tokenId) internal virtual {\\\\n        _tokenApprovals[tokenId] = to;\\\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`operator\` to operate on all of \`owner\` tokens\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\\\n        require(owner != operator, \\\\\\"ERC721: approve to caller\\\\\\");\\\\n        _operatorApprovals[owner][operator] = approved;\\\\n        emit ApprovalForAll(owner, operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Reverts if the \`tokenId\` has not been minted yet.\\\\n     */\\\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\\\n        require(_exists(tokenId), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\\\n     * The call is not executed if the target address is not a contract.\\\\n     *\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param to target address that will receive the tokens\\\\n     * @param tokenId uint256 ID of the token to be transferred\\\\n     * @param data bytes optional data to send along with the call\\\\n     * @return bool whether the call correctly returned the expected magic value\\\\n     */\\\\n    function _checkOnERC721Received(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId,\\\\n        bytes memory data\\\\n    ) private returns (bool) {\\\\n        if (to.isContract()) {\\\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\\\n                return retval == IERC721Receiver.onERC721Received.selector;\\\\n            } catch (bytes memory reason) {\\\\n                if (reason.length == 0) {\\\\n                    revert(\\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n                } else {\\\\n                    /// @solidity memory-safe-assembly\\\\n                    assembly {\\\\n                        revert(add(32, reason), mload(reason))\\\\n                    }\\\\n                }\\\\n            }\\\\n        } else {\\\\n            return true;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens will be transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens will be minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens will be burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens were transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens were minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens were burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Unsafe write access to the balances, used by extensions that \\\\\\"mint\\\\\\" tokens using an {ownerOf} override.\\\\n     *\\\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\\\n     * being that for any address \`a\` the value returned by \`balanceOf(a)\` must be equal to the number of tokens such\\\\n     * that \`ownerOf(tokenId)\` is \`a\`.\\\\n     */\\\\n    // solhint-disable-next-line func-name-mixedcase\\\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\\\n        _balances[account] += amount;\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\\\n * {ERC721Enumerable}.\\\\n */\\\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\\\n    using Address for address;\\\\n    using Strings for uint256;\\\\n\\\\n    // Token name\\\\n    string private _name;\\\\n\\\\n    // Token symbol\\\\n    string private _symbol;\\\\n\\\\n    // Mapping from token ID to owner address\\\\n    mapping(uint256 => address) private _owners;\\\\n\\\\n    // Mapping owner address to token count\\\\n    mapping(address => uint256) private _balances;\\\\n\\\\n    // Mapping from token ID to approved address\\\\n    mapping(uint256 => address) private _tokenApprovals;\\\\n\\\\n    // Mapping from owner to operator approvals\\\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\\\n\\\\n    /**\\\\n     * @dev Initializes the contract by setting a \`name\` and a \`symbol\` to the token collection.\\\\n     */\\\\n    constructor(string memory name_, string memory symbol_) {\\\\n        _name = name_;\\\\n        _symbol = symbol_;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\\\n        return\\\\n            interfaceId == type(IERC721).interfaceId ||\\\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-balanceOf}.\\\\n     */\\\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\\\n        require(owner != address(0), \\\\\\"ERC721: address zero is not a valid owner\\\\\\");\\\\n        return _balances[owner];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-ownerOf}.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\\\n        address owner = _ownerOf(tokenId);\\\\n        require(owner != address(0), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n        return owner;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-name}.\\\\n     */\\\\n    function name() public view virtual override returns (string memory) {\\\\n        return _name;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-symbol}.\\\\n     */\\\\n    function symbol() public view virtual override returns (string memory) {\\\\n        return _symbol;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-tokenURI}.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        string memory baseURI = _baseURI();\\\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\\\n     * token will be the concatenation of the \`baseURI\` and the \`tokenId\`. Empty\\\\n     * by default, can be overridden in child contracts.\\\\n     */\\\\n    function _baseURI() internal view virtual returns (string memory) {\\\\n        return \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-approve}.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) public virtual override {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        require(to != owner, \\\\\\"ERC721: approval to current owner\\\\\\");\\\\n\\\\n        require(\\\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\\\n            \\\\\\"ERC721: approve caller is not token owner or approved for all\\\\\\"\\\\n        );\\\\n\\\\n        _approve(to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-getApproved}.\\\\n     */\\\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        return _tokenApprovals[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-setApprovalForAll}.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\\\n        _setApprovalForAll(_msgSender(), operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-isApprovedForAll}.\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\\\n        return _operatorApprovals[owner][operator];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-transferFrom}.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        //solhint-disable-next-line max-line-length\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n\\\\n        _transfer(from, to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        safeTransferFrom(from, to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n        _safeTransfer(from, to, tokenId, data);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * \`data\` is additional data, it has no specified format and it is sent in call to \`to\`.\\\\n     *\\\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _transfer(from, to, tokenId);\\\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\`. Does NOT revert if token doesn't exist\\\\n     */\\\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\\\n        return _owners[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`tokenId\` exists.\\\\n     *\\\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Tokens start existing when they are minted (\`_mint\`),\\\\n     * and stop existing when they are burned (\`_burn\`).\\\\n     */\\\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\\\n        return _ownerOf(tokenId) != address(0);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`spender\` is allowed to manage \`tokenId\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\\\n        _safeMint(to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[\`_safeMint\`], with an additional \`data\` parameter which is\\\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _mint(to, tokenId);\\\\n        require(\\\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\\\n            \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\"\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - \`to\` cannot be the zero address.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _mint(address to, uint256 tokenId) internal virtual {\\\\n        require(to != address(0), \\\\\\"ERC721: mint to the zero address\\\\\\");\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not minted by \`_beforeTokenTransfer\` hook\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        unchecked {\\\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\\\n            // Given that tokens are minted one by one, it is impossible in practice that\\\\n            // this ever happens. Might change if we allow batch minting.\\\\n            // The ERC fails to describe this case.\\\\n            _balances[to] += 1;\\\\n        }\\\\n\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(address(0), to, tokenId);\\\\n\\\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Destroys \`tokenId\`.\\\\n     * The approval is cleared when the token is burned.\\\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _burn(uint256 tokenId) internal virtual {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\\\n\\\\n        // Update ownership in case tokenId was transferred by \`_beforeTokenTransfer\` hook\\\\n        owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        // Clear approvals\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\\\n            // out than the owner initially received through minting and transferring in.\\\\n            _balances[owner] -= 1;\\\\n        }\\\\n        delete _owners[tokenId];\\\\n\\\\n        emit Transfer(owner, address(0), tokenId);\\\\n\\\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` from \`from\` to \`to\`.\\\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n        require(to != address(0), \\\\\\"ERC721: transfer to the zero address\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not transferred by \`_beforeTokenTransfer\` hook\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n\\\\n        // Clear approvals from the previous owner\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // \`_balances[from]\` cannot overflow for the same reason as described in \`_burn\`:\\\\n            // \`from\`'s balance is the number of token held, which is at least one before the current\\\\n            // transfer.\\\\n            // \`_balances[to]\` could overflow in the conditions described in \`_mint\`. That would require\\\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\\\n            _balances[from] -= 1;\\\\n            _balances[to] += 1;\\\\n        }\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(from, to, tokenId);\\\\n\\\\n        _afterTokenTransfer(from, to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`to\` to operate on \`tokenId\`\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function _approve(address to, uint256 tokenId) internal virtual {\\\\n        _tokenApprovals[tokenId] = to;\\\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`operator\` to operate on all of \`owner\` tokens\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\\\n        require(owner != operator, \\\\\\"ERC721: approve to caller\\\\\\");\\\\n        _operatorApprovals[owner][operator] = approved;\\\\n        emit ApprovalForAll(owner, operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Reverts if the \`tokenId\` has not been minted yet.\\\\n     */\\\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\\\n        require(_exists(tokenId), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\\\n     * The call is not executed if the target address is not a contract.\\\\n     *\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param to target address that will receive the tokens\\\\n     * @param tokenId uint256 ID of the token to be transferred\\\\n     * @param data bytes optional data to send along with the call\\\\n     * @return bool whether the call correctly returned the expected magic value\\\\n     */\\\\n    function _checkOnERC721Received(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId,\\\\n        bytes memory data\\\\n    ) private returns (bool) {\\\\n        if (to.isContract()) {\\\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\\\n                return retval == IERC721Receiver.onERC721Received.selector;\\\\n            } catch (bytes memory reason) {\\\\n                if (reason.length == 0) {\\\\n                    revert(\\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n                } else {\\\\n                    /// @solidity memory-safe-assembly\\\\n                    assembly {\\\\n                        revert(add(32, reason), mload(reason))\\\\n                    }\\\\n                }\\\\n            }\\\\n        } else {\\\\n            return true;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens will be transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens will be minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens will be burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens were transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens were minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens were burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Unsafe write access to the balances, used by extensions that \\\\\\"mint\\\\\\" tokens using an {ownerOf} override.\\\\n     *\\\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\\\n     * being that for any address \`a\` the value returned by \`balanceOf(a)\` must be equal to the number of tokens such\\\\n     * that \`ownerOf(tokenId)\` is \`a\`.\\\\n     */\\\\n    // solhint-disable-next-line func-name-mixedcase\\\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\\\n        _balances[account] += amount;\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"./IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * \`\`\`solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * \`\`\`\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * \`\`\`solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * \`\`\`\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * \`interfaceId\`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * \`interfaceId\`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"./math/Math.sol\\\\\\";\\\\nimport \\\\\\"./math/SignedMath.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev String operations.\\\\n */\\\\nlibrary Strings {\\\\n    bytes16 private constant _SYMBOLS = \\\\\\"0123456789abcdef\\\\\\";\\\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            uint256 length = Math.log10(value) + 1;\\\\n            string memory buffer = new string(length);\\\\n            uint256 ptr;\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                ptr := add(buffer, add(32, length))\\\\n            }\\\\n            while (true) {\\\\n                ptr--;\\\\n                /// @solidity memory-safe-assembly\\\\n                assembly {\\\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\\\n                }\\\\n                value /= 10;\\\\n                if (value == 0) break;\\\\n            }\\\\n            return buffer;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`int256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(int256 value) internal pure returns (string memory) {\\\\n        return string(abi.encodePacked(value < 0 ? \\\\\\"-\\\\\\" : \\\\\\"\\\\\\", toString(SignedMath.abs(value))));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            return toHexString(value, Math.log256(value) + 1);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation with fixed length.\\\\n     */\\\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\\\n        bytes memory buffer = new bytes(2 * length + 2);\\\\n        buffer[0] = \\\\\\"0\\\\\\";\\\\n        buffer[1] = \\\\\\"x\\\\\\";\\\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\\\n            buffer[i] = _SYMBOLS[value & 0xf];\\\\n            value >>= 4;\\\\n        }\\\\n        require(value == 0, \\\\\\"Strings: hex length insufficient\\\\\\");\\\\n        return string(buffer);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts an \`address\` with fixed length of 20 bytes to its not checksummed ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(address addr) internal pure returns (string memory) {\\\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns true if the two strings are equal.\\\\n     */\\\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev String operations.\\\\n */\\\\nlibrary Strings {\\\\n    bytes16 private constant _SYMBOLS = \\\\\\"0123456789abcdef\\\\\\";\\\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            uint256 length = Math.log10(value) + 1;\\\\n            string memory buffer = new string(length);\\\\n            uint256 ptr;\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                ptr := add(buffer, add(32, length))\\\\n            }\\\\n            while (true) {\\\\n                ptr--;\\\\n                /// @solidity memory-safe-assembly\\\\n                assembly {\\\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\\\n                }\\\\n                value /= 10;\\\\n                if (value == 0) break;\\\\n            }\\\\n            return buffer;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`int256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(int256 value) internal pure returns (string memory) {\\\\n        return string(abi.encodePacked(value < 0 ? \\\\\\"-\\\\\\" : \\\\\\"\\\\\\", toString(SignedMath.abs(value))));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            return toHexString(value, Math.log256(value) + 1);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation with fixed length.\\\\n     */\\\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\\\n        bytes memory buffer = new bytes(2 * length + 2);\\\\n        buffer[0] = \\\\\\"0\\\\\\";\\\\n        buffer[1] = \\\\\\"x\\\\\\";\\\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\\\n            buffer[i] = _SYMBOLS[value & 0xf];\\\\n            value >>= 4;\\\\n        }\\\\n        require(value == 0, \\\\\\"Strings: hex length insufficient\\\\\\");\\\\n        return string(buffer);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts an \`address\` with fixed length of 20 bytes to its not checksummed ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(address addr) internal pure returns (string memory) {\\\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns true if the two strings are equal.\\\\n     */\\\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard signed math utilities missing in the Solidity language.\\\\n */\\\\nlibrary SignedMath {\\\\n    /**\\\\n     * @dev Returns the largest of two signed numbers.\\\\n     */\\\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two signed numbers.\\\\n     */\\\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two signed numbers without overflow.\\\\n     * The result is rounded towards zero.\\\\n     */\\\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\\\n        // Formula from the book \\\\\\"Hacker's Delight\\\\\\"\\\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the absolute unsigned value of a signed value.\\\\n     */\\\\n    function abs(int256 n) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            // must be unchecked in order to support \`n = type(int256).min\`\\\\n            return uint256(n >= 0 ? n : -n);\\\\n        }\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard signed math utilities missing in the Solidity language.\\\\n */\\\\nlibrary SignedMath {\\\\n    /**\\\\n     * @dev Returns the largest of two signed numbers.\\\\n     */\\\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two signed numbers.\\\\n     */\\\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two signed numbers without overflow.\\\\n     * The result is rounded towards zero.\\\\n     */\\\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\\\n        // Formula from the book \\\\\\"Hacker's Delight\\\\\\"\\\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the absolute unsigned value of a signed value.\\\\n     */\\\\n    function abs(int256 n) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            // must be unchecked in order to support \`n = type(int256).min\`\\\\n            return uint256(n >= 0 ? n : -n);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard math utilities missing in the Solidity language.\\\\n */\\\\nlibrary Math {\\\\n    enum Rounding {\\\\n        Down, // Toward negative infinity\\\\n        Up, // Toward infinity\\\\n        Zero // Toward zero\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the largest of two numbers.\\\\n     */\\\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two numbers.\\\\n     */\\\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two numbers. The result is rounded towards\\\\n     * zero.\\\\n     */\\\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b) / 2 can overflow.\\\\n        return (a & b) + (a ^ b) / 2;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the ceiling of the division of two numbers.\\\\n     *\\\\n     * This differs from standard division with \`/\` in that it rounds up instead\\\\n     * of rounding down.\\\\n     */\\\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\\\n     * with further edits by Uniswap Labs also under MIT license.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\\\n        unchecked {\\\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\\\n            // variables such that product = prod1 * 2^256 + prod0.\\\\n            uint256 prod0; // Least significant 256 bits of the product\\\\n            uint256 prod1; // Most significant 256 bits of the product\\\\n            assembly {\\\\n                let mm := mulmod(x, y, not(0))\\\\n                prod0 := mul(x, y)\\\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\\\n            }\\\\n\\\\n            // Handle non-overflow cases, 256 by 256 division.\\\\n            if (prod1 == 0) {\\\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\\\n                // The surrounding unchecked block does not change this fact.\\\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\\\n                return prod0 / denominator;\\\\n            }\\\\n\\\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\\\n            require(denominator > prod1, \\\\\\"Math: mulDiv overflow\\\\\\");\\\\n\\\\n            ///////////////////////////////////////////////\\\\n            // 512 by 256 division.\\\\n            ///////////////////////////////////////////////\\\\n\\\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\\\n            uint256 remainder;\\\\n            assembly {\\\\n                // Compute remainder using mulmod.\\\\n                remainder := mulmod(x, y, denominator)\\\\n\\\\n                // Subtract 256 bit number from 512 bit number.\\\\n                prod1 := sub(prod1, gt(remainder, prod0))\\\\n                prod0 := sub(prod0, remainder)\\\\n            }\\\\n\\\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\\\n            // See https://cs.stackexchange.com/q/138556/92363.\\\\n\\\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\\\n            uint256 twos = denominator & (~denominator + 1);\\\\n            assembly {\\\\n                // Divide denominator by twos.\\\\n                denominator := div(denominator, twos)\\\\n\\\\n                // Divide [prod1 prod0] by twos.\\\\n                prod0 := div(prod0, twos)\\\\n\\\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\\\n                twos := add(div(sub(0, twos), twos), 1)\\\\n            }\\\\n\\\\n            // Shift in bits from prod1 into prod0.\\\\n            prod0 |= prod1 * twos;\\\\n\\\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\\\n            uint256 inverse = (3 * denominator) ^ 2;\\\\n\\\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\\\n            // in modular arithmetic, doubling the correct bits in each step.\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\\\n\\\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\\\n            // is no longer required.\\\\n            result = prod0 * inverse;\\\\n            return result;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\\\n        uint256 result = mulDiv(x, y, denominator);\\\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\\\n            result += 1;\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\\\n     *\\\\n     * Inspired by Henry S. Warren, Jr.'s \\\\\\"Hacker's Delight\\\\\\" (Chapter 11).\\\\n     */\\\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\\\n        if (a == 0) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\\\n        //\\\\n        // We know that the \\\\\\"msb\\\\\\" (most significant bit) of our target number \`a\` is a power of 2 such that we have\\\\n        // \`msb(a) <= a < 2*msb(a)\`. This value can be written \`msb(a)=2**k\` with \`k=log2(a)\`.\\\\n        //\\\\n        // This can be rewritten \`2**log2(a) <= a < 2**(log2(a) + 1)\`\\\\n        //  \`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))\`\\\\n        //  \`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)\`\\\\n        //\\\\n        // Consequently, \`2**(log2(a) / 2)\` is a good first approximation of \`sqrt(a)\` with at least 1 correct bit.\\\\n        uint256 result = 1 << (log2(a) >> 1);\\\\n\\\\n        // At this point \`result\` is an estimation with one bit of precision. We know the true value is a uint128,\\\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\\\n        // into the expected uint128 result.\\\\n        unchecked {\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            return min(result, a / result);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\\\n     */\\\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = sqrt(a);\\\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 128;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                value >>= 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 4 > 0) {\\\\n                value >>= 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 2 > 0) {\\\\n                value >>= 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 1 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log2(value);\\\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >= 10 ** 64) {\\\\n                value /= 10 ** 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >= 10 ** 32) {\\\\n                value /= 10 ** 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >= 10 ** 16) {\\\\n                value /= 10 ** 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >= 10 ** 8) {\\\\n                value /= 10 ** 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >= 10 ** 4) {\\\\n                value /= 10 ** 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >= 10 ** 2) {\\\\n                value /= 10 ** 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >= 10 ** 1) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log10(value);\\\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     *\\\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent \`value\` as a hex string.\\\\n     */\\\\n    function log256(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log256(value);\\\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard math utilities missing in the Solidity language.\\\\n */\\\\nlibrary Math {\\\\n    enum Rounding {\\\\n        Down, // Toward negative infinity\\\\n        Up, // Toward infinity\\\\n        Zero // Toward zero\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the largest of two numbers.\\\\n     */\\\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two numbers.\\\\n     */\\\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two numbers. The result is rounded towards\\\\n     * zero.\\\\n     */\\\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b) / 2 can overflow.\\\\n        return (a & b) + (a ^ b) / 2;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the ceiling of the division of two numbers.\\\\n     *\\\\n     * This differs from standard division with \`/\` in that it rounds up instead\\\\n     * of rounding down.\\\\n     */\\\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\\\n     * with further edits by Uniswap Labs also under MIT license.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\\\n        unchecked {\\\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\\\n            // variables such that product = prod1 * 2^256 + prod0.\\\\n            uint256 prod0; // Least significant 256 bits of the product\\\\n            uint256 prod1; // Most significant 256 bits of the product\\\\n            assembly {\\\\n                let mm := mulmod(x, y, not(0))\\\\n                prod0 := mul(x, y)\\\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\\\n            }\\\\n\\\\n            // Handle non-overflow cases, 256 by 256 division.\\\\n            if (prod1 == 0) {\\\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\\\n                // The surrounding unchecked block does not change this fact.\\\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\\\n                return prod0 / denominator;\\\\n            }\\\\n\\\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\\\n            require(denominator > prod1, \\\\\\"Math: mulDiv overflow\\\\\\");\\\\n\\\\n            ///////////////////////////////////////////////\\\\n            // 512 by 256 division.\\\\n            ///////////////////////////////////////////////\\\\n\\\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\\\n            uint256 remainder;\\\\n            assembly {\\\\n                // Compute remainder using mulmod.\\\\n                remainder := mulmod(x, y, denominator)\\\\n\\\\n                // Subtract 256 bit number from 512 bit number.\\\\n                prod1 := sub(prod1, gt(remainder, prod0))\\\\n                prod0 := sub(prod0, remainder)\\\\n            }\\\\n\\\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\\\n            // See https://cs.stackexchange.com/q/138556/92363.\\\\n\\\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\\\n            uint256 twos = denominator & (~denominator + 1);\\\\n            assembly {\\\\n                // Divide denominator by twos.\\\\n                denominator := div(denominator, twos)\\\\n\\\\n                // Divide [prod1 prod0] by twos.\\\\n                prod0 := div(prod0, twos)\\\\n\\\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\\\n                twos := add(div(sub(0, twos), twos), 1)\\\\n            }\\\\n\\\\n            // Shift in bits from prod1 into prod0.\\\\n            prod0 |= prod1 * twos;\\\\n\\\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\\\n            uint256 inverse = (3 * denominator) ^ 2;\\\\n\\\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\\\n            // in modular arithmetic, doubling the correct bits in each step.\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\\\n\\\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\\\n            // is no longer required.\\\\n            result = prod0 * inverse;\\\\n            return result;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\\\n        uint256 result = mulDiv(x, y, denominator);\\\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\\\n            result += 1;\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\\\n     *\\\\n     * Inspired by Henry S. Warren, Jr.'s \\\\\\"Hacker's Delight\\\\\\" (Chapter 11).\\\\n     */\\\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\\\n        if (a == 0) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\\\n        //\\\\n        // We know that the \\\\\\"msb\\\\\\" (most significant bit) of our target number \`a\` is a power of 2 such that we have\\\\n        // \`msb(a) <= a < 2*msb(a)\`. This value can be written \`msb(a)=2**k\` with \`k=log2(a)\`.\\\\n        //\\\\n        // This can be rewritten \`2**log2(a) <= a < 2**(log2(a) + 1)\`\\\\n        //  \`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))\`\\\\n        //  \`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)\`\\\\n        //\\\\n        // Consequently, \`2**(log2(a) / 2)\` is a good first approximation of \`sqrt(a)\` with at least 1 correct bit.\\\\n        uint256 result = 1 << (log2(a) >> 1);\\\\n\\\\n        // At this point \`result\` is an estimation with one bit of precision. We know the true value is a uint128,\\\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\\\n        // into the expected uint128 result.\\\\n        unchecked {\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            return min(result, a / result);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\\\n     */\\\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = sqrt(a);\\\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 128;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                value >>= 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 4 > 0) {\\\\n                value >>= 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 2 > 0) {\\\\n                value >>= 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 1 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log2(value);\\\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >= 10 ** 64) {\\\\n                value /= 10 ** 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >= 10 ** 32) {\\\\n                value /= 10 ** 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >= 10 ** 16) {\\\\n                value /= 10 ** 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >= 10 ** 8) {\\\\n                value /= 10 ** 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >= 10 ** 4) {\\\\n                value /= 10 ** 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >= 10 ** 2) {\\\\n                value /= 10 ** 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >= 10 ** 1) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log10(value);\\\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     *\\\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent \`value\` as a hex string.\\\\n     */\\\\n    function log256(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log256(value);\\\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides information about the current execution context, including the\\\\n * sender of the transaction and its data. While these are generally available\\\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\\\n * manner, since when dealing with meta-transactions the account sending and\\\\n * paying for execution may not be the actual sender (as far as an application\\\\n * is concerned).\\\\n *\\\\n * This contract is only required for intermediate, library-like contracts.\\\\n */\\\\nabstract contract Context {\\\\n    function _msgSender() internal view virtual returns (address) {\\\\n        return msg.sender;\\\\n    }\\\\n\\\\n    function _msgData() internal view virtual returns (bytes calldata) {\\\\n        return msg.data;\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides information about the current execution context, including the\\\\n * sender of the transaction and its data. While these are generally available\\\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\\\n * manner, since when dealing with meta-transactions the account sending and\\\\n * paying for execution may not be the actual sender (as far as an application\\\\n * is concerned).\\\\n *\\\\n * This contract is only required for intermediate, library-like contracts.\\\\n */\\\\nabstract contract Context {\\\\n    function _msgSender() internal view virtual returns (address) {\\\\n        return msg.sender;\\\\n    }\\\\n\\\\n    function _msgData() internal view virtual returns (bytes calldata) {\\\\n        return msg.data;\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary Address {\\\\n    /**\\\\n     * @dev Returns true if \`account\` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, \`isContract\` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     *\\\\n     * Furthermore, \`isContract\` will also return true if the target contract within\\\\n     * the same transaction is already scheduled for destruction by \`SELFDESTRUCT\`,\\\\n     * which only has an effect at the end of a transaction.\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn't rely on \`isContract\` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity's \`transfer\`: sends \`amount\` wei to\\\\n     * \`recipient\`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by \`transfer\`, making them unable to receive funds via\\\\n     * \`transfer\`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to \`recipient\`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\"Address: insufficient balance\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\"\\\\\\");\\\\n        require(success, \\\\\\"Address: unable to send value, recipient may have reverted\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level \`call\`. A\\\\n     * plain \`call\` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If \`target\` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[\`abi.decode\`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`target\` must be a contract.\\\\n     * - calling \`target\` with \`data\` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\"Address: low-level call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`], but with\\\\n     * \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but also transferring \`value\` wei to \`target\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least \`value\`.\\\\n     * - the called Solidity function must be \`payable\`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\"Address: low-level call with value failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[\`functionCallWithValue\`], but\\\\n     * with \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\"Address: insufficient balance for call\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\"Address: low-level static call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\"Address: low-level delegate call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\"Address: call to non-contract\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary Address {\\\\n    /**\\\\n     * @dev Returns true if \`account\` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, \`isContract\` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     *\\\\n     * Furthermore, \`isContract\` will also return true if the target contract within\\\\n     * the same transaction is already scheduled for destruction by \`SELFDESTRUCT\`,\\\\n     * which only has an effect at the end of a transaction.\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn't rely on \`isContract\` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity's \`transfer\`: sends \`amount\` wei to\\\\n     * \`recipient\`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by \`transfer\`, making them unable to receive funds via\\\\n     * \`transfer\`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to \`recipient\`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\"Address: insufficient balance\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\"\\\\\\");\\\\n        require(success, \\\\\\"Address: unable to send value, recipient may have reverted\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level \`call\`. A\\\\n     * plain \`call\` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If \`target\` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[\`abi.decode\`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`target\` must be a contract.\\\\n     * - calling \`target\` with \`data\` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\"Address: low-level call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`], but with\\\\n     * \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but also transferring \`value\` wei to \`target\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least \`value\`.\\\\n     * - the called Solidity function must be \`payable\`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\"Address: low-level call with value failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[\`functionCallWithValue\`], but\\\\n     * with \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\"Address: insufficient balance for call\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\"Address: low-level static call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\"Address: low-level delegate call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\"Address: call to non-contract\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Metadata is IERC721 {\\\\n    /**\\\\n     * @dev Returns the token collection name.\\\\n     */\\\\n    function name() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the token collection symbol.\\\\n     */\\\\n    function symbol() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the Uniform Resource Identifier (URI) for \`tokenId\` token.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Metadata is IERC721 {\\\\n    /**\\\\n     * @dev Returns the token collection name.\\\\n     */\\\\n    function name() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the token collection symbol.\\\\n     */\\\\n    function symbol() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the Uniform Resource Identifier (URI) for \`tokenId\` token.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC721 compliant contract.\\\\n */\\\\ninterface IERC721 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when \`tokenId\` token is transferred from \`from\` to \`to\`.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables \`approved\` to manage the \`tokenId\` token.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables or disables (\`approved\`) \`operator\` to manage all of its assets.\\\\n     */\\\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Returns the number of tokens in \`\`owner\`\`'s account.\\\\n     */\\\\n    function balanceOf(address owner) external view returns (uint256 balance);\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Gives permission to \`to\` to transfer \`tokenId\` token to another account.\\\\n     * The approval is cleared when the token is transferred.\\\\n     *\\\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The caller must own the token or be an approved operator.\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Approve or remove \`operator\` as an operator for the caller.\\\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The \`operator\` cannot be the caller.\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the account approved for \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\\\n\\\\n    /**\\\\n     * @dev Returns if the \`operator\` is allowed to manage all of the assets of \`owner\`.\\\\n     *\\\\n     * See {setApprovalForAll}\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC721 compliant contract.\\\\n */\\\\ninterface IERC721 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when \`tokenId\` token is transferred from \`from\` to \`to\`.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables \`approved\` to manage the \`tokenId\` token.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables or disables (\`approved\`) \`operator\` to manage all of its assets.\\\\n     */\\\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Returns the number of tokens in \`\`owner\`\`'s account.\\\\n     */\\\\n    function balanceOf(address owner) external view returns (uint256 balance);\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Gives permission to \`to\` to transfer \`tokenId\` token to another account.\\\\n     * The approval is cleared when the token is transferred.\\\\n     *\\\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The caller must own the token or be an approved operator.\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Approve or remove \`operator\` as an operator for the caller.\\\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The \`operator\` cannot be the caller.\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the account approved for \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\\\n\\\\n    /**\\\\n     * @dev Returns if the \`operator\` is allowed to manage all of the assets of \`owner\`.\\\\n     *\\\\n     * See {setApprovalForAll}\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @title ERC721 token receiver interface\\\\n * @dev Interface for any contract that wants to support safeTransfers\\\\n * from ERC721 asset contracts.\\\\n */\\\\ninterface IERC721Receiver {\\\\n    /**\\\\n     * @dev Whenever an {IERC721} \`tokenId\` token is transferred to this contract via {IERC721-safeTransferFrom}\\\\n     * by \`operator\` from \`from\`, this function is called.\\\\n     *\\\\n     * It must return its Solidity selector to confirm the token transfer.\\\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\\\n     *\\\\n     * The selector can be obtained in Solidity with \`IERC721Receiver.onERC721Received.selector\`.\\\\n     */\\\\n    function onERC721Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\",
      \\"importedIds\\": [],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @title ERC721 token receiver interface\\\\n * @dev Interface for any contract that wants to support safeTransfers\\\\n * from ERC721 asset contracts.\\\\n */\\\\ninterface IERC721Receiver {\\\\n    /**\\\\n     * @dev Whenever an {IERC721} \`tokenId\` token is transferred to this contract via {IERC721-safeTransferFrom}\\\\n     * by \`operator\` from \`from\`, this function is called.\\\\n     *\\\\n     * It must return its Solidity selector to confirm the token transfer.\\\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\\\n     *\\\\n     * The selector can be obtained in Solidity with \`IERC721Receiver.onERC721Received.selector\`.\\\\n     */\\\\n    function onERC721Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../ERC721.sol\\\\\\";\\\\nimport \\\\\\"./IERC721Enumerable.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\\\n * account.\\\\n */\\\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\\\n    // Mapping from owner to list of owned token IDs\\\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\\\n\\\\n    // Mapping from token ID to index of the owner tokens list\\\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\\\n\\\\n    // Array with all token ids, used for enumeration\\\\n    uint256[] private _allTokens;\\\\n\\\\n    // Mapping from token id to position in the allTokens array\\\\n    mapping(uint256 => uint256) private _allTokensIndex;\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721.balanceOf(owner), \\\\\\"ERC721Enumerable: owner index out of bounds\\\\\\");\\\\n        return _ownedTokens[owner][index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-totalSupply}.\\\\n     */\\\\n    function totalSupply() public view virtual override returns (uint256) {\\\\n        return _allTokens.length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\\\n     */\\\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721Enumerable.totalSupply(), \\\\\\"ERC721Enumerable: global index out of bounds\\\\\\");\\\\n        return _allTokens[index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\\\n     */\\\\n    function _beforeTokenTransfer(\\\\n        address from,\\\\n        address to,\\\\n        uint256 firstTokenId,\\\\n        uint256 batchSize\\\\n    ) internal virtual override {\\\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\\\n\\\\n        if (batchSize > 1) {\\\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\\\n            revert(\\\\\\"ERC721Enumerable: consecutive transfers not supported\\\\\\");\\\\n        }\\\\n\\\\n        uint256 tokenId = firstTokenId;\\\\n\\\\n        if (from == address(0)) {\\\\n            _addTokenToAllTokensEnumeration(tokenId);\\\\n        } else if (from != to) {\\\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\\\n        }\\\\n        if (to == address(0)) {\\\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\\\n        } else if (to != from) {\\\\n            _addTokenToOwnerEnumeration(to, tokenId);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\\\n     * @param to address representing the new owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\\\n     */\\\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\\\n        uint256 length = ERC721.balanceOf(to);\\\\n        _ownedTokens[to][length] = tokenId;\\\\n        _ownedTokensIndex[tokenId] = length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\\\n     */\\\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\\\n        _allTokensIndex[tokenId] = _allTokens.length;\\\\n        _allTokens.push(tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\\\n     * while the token is not assigned a new owner, the \`_ownedTokensIndex\` mapping is _not_ updated: this allows for\\\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\\\n     */\\\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary\\\\n        if (tokenIndex != lastTokenIndex) {\\\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\\\n\\\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n        }\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _ownedTokensIndex[tokenId];\\\\n        delete _ownedTokens[from][lastTokenIndex];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\\\n     */\\\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\\\n\\\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _allTokensIndex[tokenId];\\\\n        _allTokens.pop();\\\\n    }\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\",
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\\\n * account.\\\\n */\\\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\\\n    // Mapping from owner to list of owned token IDs\\\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\\\n\\\\n    // Mapping from token ID to index of the owner tokens list\\\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\\\n\\\\n    // Array with all token ids, used for enumeration\\\\n    uint256[] private _allTokens;\\\\n\\\\n    // Mapping from token id to position in the allTokens array\\\\n    mapping(uint256 => uint256) private _allTokensIndex;\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721.balanceOf(owner), \\\\\\"ERC721Enumerable: owner index out of bounds\\\\\\");\\\\n        return _ownedTokens[owner][index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-totalSupply}.\\\\n     */\\\\n    function totalSupply() public view virtual override returns (uint256) {\\\\n        return _allTokens.length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\\\n     */\\\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721Enumerable.totalSupply(), \\\\\\"ERC721Enumerable: global index out of bounds\\\\\\");\\\\n        return _allTokens[index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\\\n     */\\\\n    function _beforeTokenTransfer(\\\\n        address from,\\\\n        address to,\\\\n        uint256 firstTokenId,\\\\n        uint256 batchSize\\\\n    ) internal virtual override {\\\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\\\n\\\\n        if (batchSize > 1) {\\\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\\\n            revert(\\\\\\"ERC721Enumerable: consecutive transfers not supported\\\\\\");\\\\n        }\\\\n\\\\n        uint256 tokenId = firstTokenId;\\\\n\\\\n        if (from == address(0)) {\\\\n            _addTokenToAllTokensEnumeration(tokenId);\\\\n        } else if (from != to) {\\\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\\\n        }\\\\n        if (to == address(0)) {\\\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\\\n        } else if (to != from) {\\\\n            _addTokenToOwnerEnumeration(to, tokenId);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\\\n     * @param to address representing the new owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\\\n     */\\\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\\\n        uint256 length = ERC721.balanceOf(to);\\\\n        _ownedTokens[to][length] = tokenId;\\\\n        _ownedTokensIndex[tokenId] = length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\\\n     */\\\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\\\n        _allTokensIndex[tokenId] = _allTokens.length;\\\\n        _allTokens.push(tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\\\n     * while the token is not assigned a new owner, the \`_ownedTokensIndex\` mapping is _not_ updated: this allows for\\\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\\\n     */\\\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary\\\\n        if (tokenIndex != lastTokenIndex) {\\\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\\\n\\\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n        }\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _ownedTokensIndex[tokenId];\\\\n        delete _ownedTokens[from][lastTokenIndex];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\\\n     */\\\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\\\n\\\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _allTokensIndex[tokenId];\\\\n        _allTokens.pop();\\\\n    }\\\\n}\\\\n\\"
    },
    \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\": {
      \\"id\\": \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\",
      \\"rawCode\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Enumerable is IERC721 {\\\\n    /**\\\\n     * @dev Returns the total amount of tokens stored by the contract.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID owned by \`owner\` at a given \`index\` of its token list.\\\\n     * Use along with {balanceOf} to enumerate all of \`\`owner\`\`'s tokens.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID at a given \`index\` of all the tokens stored by the contract.\\\\n     * Use along with {totalSupply} to enumerate all tokens.\\\\n     */\\\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\\\n}\\\\n\\",
      \\"importedIds\\": [
        \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\"
      ],
      \\"code\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Enumerable is IERC721 {\\\\n    /**\\\\n     * @dev Returns the total amount of tokens stored by the contract.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID owned by \`owner\` at a given \`index\` of its token list.\\\\n     * Use along with {balanceOf} to enumerate all of \`\`owner\`\`'s tokens.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID at a given \`index\` of all the tokens stored by the contract.\\\\n     * Use along with {totalSupply} to enumerate all tokens.\\\\n     */\\\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\\\n}\\\\n\\"
    }
  },
  \\"solcInput\\": {
    \\"language\\": \\"Solidity\\",
    \\"sources\\": {
      \\"./Contract.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\npragma solidity >0.8.16;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n// import \\\\\\"this shouldn't be imorted\\\\\\";\\\\n\\\\n/// @author Wagmi\\\\n/// @author EVMts\\\\n/// @title  WagmiMintExample\\\\n/// @notice An example token original from the wagmi template\\\\ncontract WagmiMintExample is ERC721 {\\\\n    uint256 public totalSupply;\\\\n\\\\n// import \\\\\\"@openzeppelin/contracts/utils/Base64.sol\\\\\\";\\\\n    uint256 private nextTokenId = 0;\\\\n\\\\n    constructor() ERC721(\\\\\\"wagmi\\\\\\", \\\\\\"WAGMI\\\\\\") {}\\\\n\\\\n    /// @notice Allows an address to mint\\\\n    function mint() external {\\\\n        uint256 tokenId = nextTokenId;\\\\n        while (_exists(tokenId)) {\\\\n            unchecked {\\\\n                tokenId++;\\\\n            }\\\\n        }\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n            nextTokenId = tokenId + 1;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to mint.\\\\n    function mint(uint256 tokenId) external {\\\\n        require(!_exists(tokenId), \\\\\\"Token ID is taken\\\\\\");\\\\n        _safeMint(msg.sender, tokenId);\\\\n        unchecked {\\\\n            totalSupply++;\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Returns the token URI for a given token by ID\\\\n    /// @param tokenId Token ID to query.\\\\n    /// @return uri_ Token URI for the given token by ID.\\\\n    function tokenURI(\\\\n        uint256 tokenId\\\\n    ) public pure override returns (string memory) {\\\\n        uint256 foregroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"foreground\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        uint256 backgroundHue = uint256(\\\\n            keccak256(abi.encodePacked(\\\\\\"background\\\\\\", tokenId))\\\\n        ) % 360;\\\\n        string memory json = Base64.encode(\\\\n            bytes(\\\\n                abi.encodePacked(\\\\n                    '{\\\\\\"name\\\\\\": \\\\\\"wagmi #',\\\\n                    toString(tokenId),\\\\n                    '\\\\\\", \\\\\\"image\\\\\\": \\\\\\"data:image/svg+xml;base64,',\\\\n                    Base64.encode(\\\\n                        bytes(\\\\n                            abi.encodePacked(\\\\n                                '<svg xmlns=\\\\\\"http://www.w3.org/2000/svg\\\\\\" width=\\\\\\"1024\\\\\\" height=\\\\\\"1024\\\\\\" fill=\\\\\\"none\\\\\\"><path fill=\\\\\\"hsl(',\\\\n                                toString(foregroundHue),\\\\n                                ', 100%, 10%)\\\\\\" d=\\\\\\"M0 0h1024v1024H0z\\\\\\" /><g fill=\\\\\\"hsl(',\\\\n                                toString(backgroundHue),\\\\n                                ', 100%, 90%)\\\\\\"><path d=\\\\\\"M903 437.5c0 9.113-7.388 16.5-16.5 16.5s-16.5-7.387-16.5-16.5 7.388-16.5 16.5-16.5 16.5 7.387 16.5 16.5zM698.529 566c6.921 0 12.53-5.596 12.53-12.5v-50c0-6.904 5.609-12.5 12.529-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.53 12.5s12.529-5.596 12.529-12.5v-50c0-6.904 5.609-12.5 12.53-12.5h25.059c6.92 0 12.529 5.596 12.529 12.5v50c0 6.904 5.609 12.5 12.529 12.5h37.589c6.92 0 12.529-5.596 12.529-12.5v-75c0-6.904-5.609-12.5-12.529-12.5s-12.53 5.596-12.53 12.5v56.25a6.264 6.264 0 1 1-12.529 0V478.5c0-6.904-5.609-12.5-12.53-12.5H698.529c-6.92 0-12.529 5.596-12.529 12.5v75c0 6.904 5.609 12.5 12.529 12.5z\\\\\\" /><path d=\\\\\\"M157.655 541c-6.932 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.619-12.5-12.551-12.5S120 471.596 120 478.5v75c0 6.904 5.62 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-50c0-6.904 5.619-12.5 12.552-12.5h144.345c3.465 0 6.276 2.798 6.276 6.25s-2.811 6.25-6.276 6.25H320.828c-6.933 0-12.552 5.596-12.552 12.5v37.5c0 6.904 5.619 12.5 12.552 12.5h150.62c6.933 0 12.552-5.596 12.552-12.5v-75c0-6.904-5.619-12.5-12.552-12.5H283.172c-6.932 0-12.551 5.596-12.551 12.5v50c0 6.904-5.619 12.5-12.552 12.5h-25.103c-6.933 0-12.552-5.596-12.552-12.5v-50c0-6.904-5.62-12.5-12.552-12.5s-12.552 5.596-12.552 12.5v50c0 6.904-5.619 12.5-12.551 12.5h-25.104zm301.242-6.25c0 3.452-2.811 6.25-6.276 6.25H339.655c-3.465 0-6.276-2.798-6.276-6.25s2.811-6.25 6.276-6.25h112.966c3.465 0 6.276 2.798 6.276 6.25zM497 553.818c0 6.929 5.628 12.546 12.571 12.546h132a6.28 6.28 0 0 1 6.286 6.272 6.28 6.28 0 0 1-6.286 6.273h-132c-6.943 0-12.571 5.616-12.571 12.546A12.56 12.56 0 0 0 509.571 604h150.858c6.943 0 12.571-5.616 12.571-12.545v-112.91c0-6.928-5.628-12.545-12.571-12.545H509.571c-6.943 0-12.571 5.617-12.571 12.545v75.273zm37.714-62.727c-6.943 0-12.571 5.617-12.571 12.545v25.091c0 6.929 5.628 12.546 12.571 12.546h100.572c6.943 0 12.571-5.617 12.571-12.546v-25.091c0-6.928-5.628-12.545-12.571-12.545H534.714z\\\\\\" fill-rule=\\\\\\"evenodd\\\\\\" /></g></svg>'\\\\n                            )\\\\n                        )\\\\n                    ),\\\\n                    '\\\\\\"}'\\\\n                )\\\\n            )\\\\n        );\\\\n        string memory output = string(\\\\n            abi.encodePacked(\\\\\\"data:application/json;base64,\\\\\\", json)\\\\n        );\\\\n        return output;\\\\n    }\\\\n\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\\\n\\\\n        if (value == 0) {\\\\n            return \\\\\\"0\\\\\\";\\\\n        }\\\\n        uint256 temp = value;\\\\n        uint256 digits;\\\\n        while (temp != 0) {\\\\n            digits++;\\\\n            temp /= 10;\\\\n        }\\\\n        bytes memory buffer = new bytes(digits);\\\\n        while (value != 0) {\\\\n            digits -= 1;\\\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\\\n            value /= 10;\\\\n        }\\\\n        return string(buffer);\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides a set of functions to operate with Base64 strings.\\\\n *\\\\n * _Available since v4.5._\\\\n */\\\\nlibrary Base64 {\\\\n    /**\\\\n     * @dev Base64 Encoding/Decoding Table\\\\n     */\\\\n    string internal constant _TABLE = \\\\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\\\\";\\\\n\\\\n    /**\\\\n     * @dev Converts a \`bytes\` to its Bytes64 \`string\` representation.\\\\n     */\\\\n    function encode(bytes memory data) internal pure returns (string memory) {\\\\n        /**\\\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\\\n         */\\\\n        if (data.length == 0) return \\\\\\"\\\\\\";\\\\n\\\\n        // Loads the table into memory\\\\n        string memory table = _TABLE;\\\\n\\\\n        // Encoding takes 3 bytes chunks of binary data from \`bytes\` data parameter\\\\n        // and split into 4 numbers of 6 bits.\\\\n        // The final Base64 length should be \`bytes\` data length multiplied by 4/3 rounded up\\\\n        // - \`data.length + 2\`  -> Round up\\\\n        // - \`/ 3\`              -> Number of 3-bytes chunks\\\\n        // - \`4 *\`              -> 4 characters for each chunk\\\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\\\n\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            // Prepare the lookup table (skip the first \\\\\\"length\\\\\\" byte)\\\\n            let tablePtr := add(table, 1)\\\\n\\\\n            // Prepare result pointer, jump over length\\\\n            let resultPtr := add(result, 32)\\\\n\\\\n            // Run over the input, 3 bytes at a time\\\\n            for {\\\\n                let dataPtr := data\\\\n                let endPtr := add(data, mload(data))\\\\n            } lt(dataPtr, endPtr) {\\\\n\\\\n            } {\\\\n                // Advance 3 bytes\\\\n                dataPtr := add(dataPtr, 3)\\\\n                let input := mload(dataPtr)\\\\n\\\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\\\n                // and apply logical AND with 0x3F which is the number of\\\\n                // the previous character in the ASCII table prior to the Base64 Table\\\\n                // The result is then added to the table to get the character to write,\\\\n                // and finally write it in the result pointer but with a left shift\\\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n\\\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\\\n                resultPtr := add(resultPtr, 1) // Advance\\\\n            }\\\\n\\\\n            // When data \`bytes\` is not exactly 3 bytes long\\\\n            // it is padded with \`=\` characters at the end\\\\n            switch mod(mload(data), 3)\\\\n            case 1 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n                mstore8(sub(resultPtr, 2), 0x3d)\\\\n            }\\\\n            case 2 {\\\\n                mstore8(sub(resultPtr, 1), 0x3d)\\\\n            }\\\\n        }\\\\n\\\\n        return result;\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\\\n * {ERC721Enumerable}.\\\\n */\\\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\\\n    using Address for address;\\\\n    using Strings for uint256;\\\\n\\\\n    // Token name\\\\n    string private _name;\\\\n\\\\n    // Token symbol\\\\n    string private _symbol;\\\\n\\\\n    // Mapping from token ID to owner address\\\\n    mapping(uint256 => address) private _owners;\\\\n\\\\n    // Mapping owner address to token count\\\\n    mapping(address => uint256) private _balances;\\\\n\\\\n    // Mapping from token ID to approved address\\\\n    mapping(uint256 => address) private _tokenApprovals;\\\\n\\\\n    // Mapping from owner to operator approvals\\\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\\\n\\\\n    /**\\\\n     * @dev Initializes the contract by setting a \`name\` and a \`symbol\` to the token collection.\\\\n     */\\\\n    constructor(string memory name_, string memory symbol_) {\\\\n        _name = name_;\\\\n        _symbol = symbol_;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\\\n        return\\\\n            interfaceId == type(IERC721).interfaceId ||\\\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-balanceOf}.\\\\n     */\\\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\\\n        require(owner != address(0), \\\\\\"ERC721: address zero is not a valid owner\\\\\\");\\\\n        return _balances[owner];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-ownerOf}.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\\\n        address owner = _ownerOf(tokenId);\\\\n        require(owner != address(0), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n        return owner;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-name}.\\\\n     */\\\\n    function name() public view virtual override returns (string memory) {\\\\n        return _name;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-symbol}.\\\\n     */\\\\n    function symbol() public view virtual override returns (string memory) {\\\\n        return _symbol;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Metadata-tokenURI}.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        string memory baseURI = _baseURI();\\\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\\\n     * token will be the concatenation of the \`baseURI\` and the \`tokenId\`. Empty\\\\n     * by default, can be overridden in child contracts.\\\\n     */\\\\n    function _baseURI() internal view virtual returns (string memory) {\\\\n        return \\\\\\"\\\\\\";\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-approve}.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) public virtual override {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        require(to != owner, \\\\\\"ERC721: approval to current owner\\\\\\");\\\\n\\\\n        require(\\\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\\\n            \\\\\\"ERC721: approve caller is not token owner or approved for all\\\\\\"\\\\n        );\\\\n\\\\n        _approve(to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-getApproved}.\\\\n     */\\\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\\\n        _requireMinted(tokenId);\\\\n\\\\n        return _tokenApprovals[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-setApprovalForAll}.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\\\n        _setApprovalForAll(_msgSender(), operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-isApprovedForAll}.\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\\\n        return _operatorApprovals[owner][operator];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-transferFrom}.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        //solhint-disable-next-line max-line-length\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n\\\\n        _transfer(from, to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\\\n        safeTransferFrom(from, to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\\\\"ERC721: caller is not token owner or approved\\\\\\");\\\\n        _safeTransfer(from, to, tokenId, data);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * \`data\` is additional data, it has no specified format and it is sent in call to \`to\`.\\\\n     *\\\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _transfer(from, to, tokenId);\\\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\`. Does NOT revert if token doesn't exist\\\\n     */\\\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\\\n        return _owners[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`tokenId\` exists.\\\\n     *\\\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Tokens start existing when they are minted (\`_mint\`),\\\\n     * and stop existing when they are burned (\`_burn\`).\\\\n     */\\\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\\\n        return _ownerOf(tokenId) != address(0);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns whether \`spender\` is allowed to manage \`tokenId\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Safely mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\\\n        _safeMint(to, tokenId, \\\\\\"\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[\`_safeMint\`], with an additional \`data\` parameter which is\\\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\\\n     */\\\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\\\n        _mint(to, tokenId);\\\\n        require(\\\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\\\n            \\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\"\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Mints \`tokenId\` and transfers it to \`to\`.\\\\n     *\\\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must not exist.\\\\n     * - \`to\` cannot be the zero address.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _mint(address to, uint256 tokenId) internal virtual {\\\\n        require(to != address(0), \\\\\\"ERC721: mint to the zero address\\\\\\");\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not minted by \`_beforeTokenTransfer\` hook\\\\n        require(!_exists(tokenId), \\\\\\"ERC721: token already minted\\\\\\");\\\\n\\\\n        unchecked {\\\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\\\n            // Given that tokens are minted one by one, it is impossible in practice that\\\\n            // this ever happens. Might change if we allow batch minting.\\\\n            // The ERC fails to describe this case.\\\\n            _balances[to] += 1;\\\\n        }\\\\n\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(address(0), to, tokenId);\\\\n\\\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Destroys \`tokenId\`.\\\\n     * The approval is cleared when the token is burned.\\\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _burn(uint256 tokenId) internal virtual {\\\\n        address owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\\\n\\\\n        // Update ownership in case tokenId was transferred by \`_beforeTokenTransfer\` hook\\\\n        owner = ERC721.ownerOf(tokenId);\\\\n\\\\n        // Clear approvals\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\\\n            // out than the owner initially received through minting and transferring in.\\\\n            _balances[owner] -= 1;\\\\n        }\\\\n        delete _owners[tokenId];\\\\n\\\\n        emit Transfer(owner, address(0), tokenId);\\\\n\\\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` from \`from\` to \`to\`.\\\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n        require(to != address(0), \\\\\\"ERC721: transfer to the zero address\\\\\\");\\\\n\\\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\\\n\\\\n        // Check that tokenId was not transferred by \`_beforeTokenTransfer\` hook\\\\n        require(ERC721.ownerOf(tokenId) == from, \\\\\\"ERC721: transfer from incorrect owner\\\\\\");\\\\n\\\\n        // Clear approvals from the previous owner\\\\n        delete _tokenApprovals[tokenId];\\\\n\\\\n        unchecked {\\\\n            // \`_balances[from]\` cannot overflow for the same reason as described in \`_burn\`:\\\\n            // \`from\`'s balance is the number of token held, which is at least one before the current\\\\n            // transfer.\\\\n            // \`_balances[to]\` could overflow in the conditions described in \`_mint\`. That would require\\\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\\\n            _balances[from] -= 1;\\\\n            _balances[to] += 1;\\\\n        }\\\\n        _owners[tokenId] = to;\\\\n\\\\n        emit Transfer(from, to, tokenId);\\\\n\\\\n        _afterTokenTransfer(from, to, tokenId, 1);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`to\` to operate on \`tokenId\`\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function _approve(address to, uint256 tokenId) internal virtual {\\\\n        _tokenApprovals[tokenId] = to;\\\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Approve \`operator\` to operate on all of \`owner\` tokens\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\\\n        require(owner != operator, \\\\\\"ERC721: approve to caller\\\\\\");\\\\n        _operatorApprovals[owner][operator] = approved;\\\\n        emit ApprovalForAll(owner, operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Reverts if the \`tokenId\` has not been minted yet.\\\\n     */\\\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\\\n        require(_exists(tokenId), \\\\\\"ERC721: invalid token ID\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\\\n     * The call is not executed if the target address is not a contract.\\\\n     *\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param to target address that will receive the tokens\\\\n     * @param tokenId uint256 ID of the token to be transferred\\\\n     * @param data bytes optional data to send along with the call\\\\n     * @return bool whether the call correctly returned the expected magic value\\\\n     */\\\\n    function _checkOnERC721Received(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId,\\\\n        bytes memory data\\\\n    ) private returns (bool) {\\\\n        if (to.isContract()) {\\\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\\\n                return retval == IERC721Receiver.onERC721Received.selector;\\\\n            } catch (bytes memory reason) {\\\\n                if (reason.length == 0) {\\\\n                    revert(\\\\\\"ERC721: transfer to non ERC721Receiver implementer\\\\\\");\\\\n                } else {\\\\n                    /// @solidity memory-safe-assembly\\\\n                    assembly {\\\\n                        revert(add(32, reason), mload(reason))\\\\n                    }\\\\n                }\\\\n            }\\\\n        } else {\\\\n            return true;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens will be transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens will be minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens will be burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by \`batchSize\` greater than 1.\\\\n     *\\\\n     * Calling conditions:\\\\n     *\\\\n     * - When \`from\` and \`to\` are both non-zero, \`\`from\`\`'s tokens were transferred to \`to\`.\\\\n     * - When \`from\` is zero, the tokens were minted for \`to\`.\\\\n     * - When \`to\` is zero, \`\`from\`\`'s tokens were burned.\\\\n     * - \`from\` and \`to\` are never both zero.\\\\n     * - \`batchSize\` is non-zero.\\\\n     *\\\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\\\n     */\\\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\\\n\\\\n    /**\\\\n     * @dev Unsafe write access to the balances, used by extensions that \\\\\\"mint\\\\\\" tokens using an {ownerOf} override.\\\\n     *\\\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\\\n     * being that for any address \`a\` the value returned by \`balanceOf(a)\` must be equal to the number of tokens such\\\\n     * that \`ownerOf(tokenId)\` is \`a\`.\\\\n     */\\\\n    // solhint-disable-next-line func-name-mixedcase\\\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\\\n        _balances[account] += amount;\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * \`\`\`solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * \`\`\`\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * \`interfaceId\`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev String operations.\\\\n */\\\\nlibrary Strings {\\\\n    bytes16 private constant _SYMBOLS = \\\\\\"0123456789abcdef\\\\\\";\\\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            uint256 length = Math.log10(value) + 1;\\\\n            string memory buffer = new string(length);\\\\n            uint256 ptr;\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                ptr := add(buffer, add(32, length))\\\\n            }\\\\n            while (true) {\\\\n                ptr--;\\\\n                /// @solidity memory-safe-assembly\\\\n                assembly {\\\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\\\n                }\\\\n                value /= 10;\\\\n                if (value == 0) break;\\\\n            }\\\\n            return buffer;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`int256\` to its ASCII \`string\` decimal representation.\\\\n     */\\\\n    function toString(int256 value) internal pure returns (string memory) {\\\\n        return string(abi.encodePacked(value < 0 ? \\\\\\"-\\\\\\" : \\\\\\"\\\\\\", toString(SignedMath.abs(value))));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\\\n        unchecked {\\\\n            return toHexString(value, Math.log256(value) + 1);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts a \`uint256\` to its ASCII \`string\` hexadecimal representation with fixed length.\\\\n     */\\\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\\\n        bytes memory buffer = new bytes(2 * length + 2);\\\\n        buffer[0] = \\\\\\"0\\\\\\";\\\\n        buffer[1] = \\\\\\"x\\\\\\";\\\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\\\n            buffer[i] = _SYMBOLS[value & 0xf];\\\\n            value >>= 4;\\\\n        }\\\\n        require(value == 0, \\\\\\"Strings: hex length insufficient\\\\\\");\\\\n        return string(buffer);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Converts an \`address\` with fixed length of 20 bytes to its not checksummed ASCII \`string\` hexadecimal representation.\\\\n     */\\\\n    function toHexString(address addr) internal pure returns (string memory) {\\\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns true if the two strings are equal.\\\\n     */\\\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard signed math utilities missing in the Solidity language.\\\\n */\\\\nlibrary SignedMath {\\\\n    /**\\\\n     * @dev Returns the largest of two signed numbers.\\\\n     */\\\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two signed numbers.\\\\n     */\\\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two signed numbers without overflow.\\\\n     * The result is rounded towards zero.\\\\n     */\\\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\\\n        // Formula from the book \\\\\\"Hacker's Delight\\\\\\"\\\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the absolute unsigned value of a signed value.\\\\n     */\\\\n    function abs(int256 n) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            // must be unchecked in order to support \`n = type(int256).min\`\\\\n            return uint256(n >= 0 ? n : -n);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Standard math utilities missing in the Solidity language.\\\\n */\\\\nlibrary Math {\\\\n    enum Rounding {\\\\n        Down, // Toward negative infinity\\\\n        Up, // Toward infinity\\\\n        Zero // Toward zero\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the largest of two numbers.\\\\n     */\\\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a > b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the smallest of two numbers.\\\\n     */\\\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        return a < b ? a : b;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the average of two numbers. The result is rounded towards\\\\n     * zero.\\\\n     */\\\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b) / 2 can overflow.\\\\n        return (a & b) + (a ^ b) / 2;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the ceiling of the division of two numbers.\\\\n     *\\\\n     * This differs from standard division with \`/\` in that it rounds up instead\\\\n     * of rounding down.\\\\n     */\\\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\\\n     * with further edits by Uniswap Labs also under MIT license.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\\\n        unchecked {\\\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\\\n            // variables such that product = prod1 * 2^256 + prod0.\\\\n            uint256 prod0; // Least significant 256 bits of the product\\\\n            uint256 prod1; // Most significant 256 bits of the product\\\\n            assembly {\\\\n                let mm := mulmod(x, y, not(0))\\\\n                prod0 := mul(x, y)\\\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\\\n            }\\\\n\\\\n            // Handle non-overflow cases, 256 by 256 division.\\\\n            if (prod1 == 0) {\\\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\\\n                // The surrounding unchecked block does not change this fact.\\\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\\\n                return prod0 / denominator;\\\\n            }\\\\n\\\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\\\n            require(denominator > prod1, \\\\\\"Math: mulDiv overflow\\\\\\");\\\\n\\\\n            ///////////////////////////////////////////////\\\\n            // 512 by 256 division.\\\\n            ///////////////////////////////////////////////\\\\n\\\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\\\n            uint256 remainder;\\\\n            assembly {\\\\n                // Compute remainder using mulmod.\\\\n                remainder := mulmod(x, y, denominator)\\\\n\\\\n                // Subtract 256 bit number from 512 bit number.\\\\n                prod1 := sub(prod1, gt(remainder, prod0))\\\\n                prod0 := sub(prod0, remainder)\\\\n            }\\\\n\\\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\\\n            // See https://cs.stackexchange.com/q/138556/92363.\\\\n\\\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\\\n            uint256 twos = denominator & (~denominator + 1);\\\\n            assembly {\\\\n                // Divide denominator by twos.\\\\n                denominator := div(denominator, twos)\\\\n\\\\n                // Divide [prod1 prod0] by twos.\\\\n                prod0 := div(prod0, twos)\\\\n\\\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\\\n                twos := add(div(sub(0, twos), twos), 1)\\\\n            }\\\\n\\\\n            // Shift in bits from prod1 into prod0.\\\\n            prod0 |= prod1 * twos;\\\\n\\\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\\\n            uint256 inverse = (3 * denominator) ^ 2;\\\\n\\\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\\\n            // in modular arithmetic, doubling the correct bits in each step.\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\\\n\\\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\\\n            // is no longer required.\\\\n            result = prod0 * inverse;\\\\n            return result;\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\\\n     */\\\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\\\n        uint256 result = mulDiv(x, y, denominator);\\\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\\\n            result += 1;\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\\\n     *\\\\n     * Inspired by Henry S. Warren, Jr.'s \\\\\\"Hacker's Delight\\\\\\" (Chapter 11).\\\\n     */\\\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\\\n        if (a == 0) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\\\n        //\\\\n        // We know that the \\\\\\"msb\\\\\\" (most significant bit) of our target number \`a\` is a power of 2 such that we have\\\\n        // \`msb(a) <= a < 2*msb(a)\`. This value can be written \`msb(a)=2**k\` with \`k=log2(a)\`.\\\\n        //\\\\n        // This can be rewritten \`2**log2(a) <= a < 2**(log2(a) + 1)\`\\\\n        //  \`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))\`\\\\n        //  \`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)\`\\\\n        //\\\\n        // Consequently, \`2**(log2(a) / 2)\` is a good first approximation of \`sqrt(a)\` with at least 1 correct bit.\\\\n        uint256 result = 1 << (log2(a) >> 1);\\\\n\\\\n        // At this point \`result\` is an estimation with one bit of precision. We know the true value is a uint128,\\\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\\\n        // into the expected uint128 result.\\\\n        unchecked {\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            result = (result + a / result) >> 1;\\\\n            return min(result, a / result);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\\\n     */\\\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = sqrt(a);\\\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 128;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                value >>= 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 4 > 0) {\\\\n                value >>= 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 2 > 0) {\\\\n                value >>= 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 1 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log2(value);\\\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >= 10 ** 64) {\\\\n                value /= 10 ** 64;\\\\n                result += 64;\\\\n            }\\\\n            if (value >= 10 ** 32) {\\\\n                value /= 10 ** 32;\\\\n                result += 32;\\\\n            }\\\\n            if (value >= 10 ** 16) {\\\\n                value /= 10 ** 16;\\\\n                result += 16;\\\\n            }\\\\n            if (value >= 10 ** 8) {\\\\n                value /= 10 ** 8;\\\\n                result += 8;\\\\n            }\\\\n            if (value >= 10 ** 4) {\\\\n                value /= 10 ** 4;\\\\n                result += 4;\\\\n            }\\\\n            if (value >= 10 ** 2) {\\\\n                value /= 10 ** 2;\\\\n                result += 2;\\\\n            }\\\\n            if (value >= 10 ** 1) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log10(value);\\\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     *\\\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent \`value\` as a hex string.\\\\n     */\\\\n    function log256(uint256 value) internal pure returns (uint256) {\\\\n        uint256 result = 0;\\\\n        unchecked {\\\\n            if (value >> 128 > 0) {\\\\n                value >>= 128;\\\\n                result += 16;\\\\n            }\\\\n            if (value >> 64 > 0) {\\\\n                value >>= 64;\\\\n                result += 8;\\\\n            }\\\\n            if (value >> 32 > 0) {\\\\n                value >>= 32;\\\\n                result += 4;\\\\n            }\\\\n            if (value >> 16 > 0) {\\\\n                value >>= 16;\\\\n                result += 2;\\\\n            }\\\\n            if (value >> 8 > 0) {\\\\n                result += 1;\\\\n            }\\\\n        }\\\\n        return result;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\\\n     * Returns 0 if given 0.\\\\n     */\\\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\\\n        unchecked {\\\\n            uint256 result = log256(value);\\\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides information about the current execution context, including the\\\\n * sender of the transaction and its data. While these are generally available\\\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\\\n * manner, since when dealing with meta-transactions the account sending and\\\\n * paying for execution may not be the actual sender (as far as an application\\\\n * is concerned).\\\\n *\\\\n * This contract is only required for intermediate, library-like contracts.\\\\n */\\\\nabstract contract Context {\\\\n    function _msgSender() internal view virtual returns (address) {\\\\n        return msg.sender;\\\\n    }\\\\n\\\\n    function _msgData() internal view virtual returns (bytes calldata) {\\\\n        return msg.data;\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary Address {\\\\n    /**\\\\n     * @dev Returns true if \`account\` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, \`isContract\` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     *\\\\n     * Furthermore, \`isContract\` will also return true if the target contract within\\\\n     * the same transaction is already scheduled for destruction by \`SELFDESTRUCT\`,\\\\n     * which only has an effect at the end of a transaction.\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn't rely on \`isContract\` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity's \`transfer\`: sends \`amount\` wei to\\\\n     * \`recipient\`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by \`transfer\`, making them unable to receive funds via\\\\n     * \`transfer\`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to \`recipient\`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\"Address: insufficient balance\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\"\\\\\\");\\\\n        require(success, \\\\\\"Address: unable to send value, recipient may have reverted\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level \`call\`. A\\\\n     * plain \`call\` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If \`target\` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[\`abi.decode\`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`target\` must be a contract.\\\\n     * - calling \`target\` with \`data\` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\"Address: low-level call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`], but with\\\\n     * \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but also transferring \`value\` wei to \`target\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least \`value\`.\\\\n     * - the called Solidity function must be \`payable\`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\"Address: low-level call with value failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[\`functionCallWithValue\`], but\\\\n     * with \`errorMessage\` as a fallback revert reason when \`target\` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\"Address: insufficient balance for call\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\"Address: low-level static call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\"Address: low-level delegate call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\"Address: call to non-contract\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Metadata is IERC721 {\\\\n    /**\\\\n     * @dev Returns the token collection name.\\\\n     */\\\\n    function name() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the token collection symbol.\\\\n     */\\\\n    function symbol() external view returns (string memory);\\\\n\\\\n    /**\\\\n     * @dev Returns the Uniform Resource Identifier (URI) for \`tokenId\` token.\\\\n     */\\\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC721 compliant contract.\\\\n */\\\\ninterface IERC721 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when \`tokenId\` token is transferred from \`from\` to \`to\`.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables \`approved\` to manage the \`tokenId\` token.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when \`owner\` enables or disables (\`approved\`) \`operator\` to manage all of its assets.\\\\n     */\\\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Returns the number of tokens in \`\`owner\`\`'s account.\\\\n     */\\\\n    function balanceOf(address owner) external view returns (uint256 balance);\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must exist and be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Transfers \`tokenId\` token from \`from\` to \`to\`.\\\\n     *\\\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`from\` cannot be the zero address.\\\\n     * - \`to\` cannot be the zero address.\\\\n     * - \`tokenId\` token must be owned by \`from\`.\\\\n     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Gives permission to \`to\` to transfer \`tokenId\` token to another account.\\\\n     * The approval is cleared when the token is transferred.\\\\n     *\\\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The caller must own the token or be an approved operator.\\\\n     * - \`tokenId\` must exist.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Approve or remove \`operator\` as an operator for the caller.\\\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The \`operator\` cannot be the caller.\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the account approved for \`tokenId\` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - \`tokenId\` must exist.\\\\n     */\\\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\\\n\\\\n    /**\\\\n     * @dev Returns if the \`operator\` is allowed to manage all of the assets of \`owner\`.\\\\n     *\\\\n     * See {setApprovalForAll}\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @title ERC721 token receiver interface\\\\n * @dev Interface for any contract that wants to support safeTransfers\\\\n * from ERC721 asset contracts.\\\\n */\\\\ninterface IERC721Receiver {\\\\n    /**\\\\n     * @dev Whenever an {IERC721} \`tokenId\` token is transferred to this contract via {IERC721-safeTransferFrom}\\\\n     * by \`operator\` from \`from\`, this function is called.\\\\n     *\\\\n     * It must return its Solidity selector to confirm the token transfer.\\\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\\\n     *\\\\n     * The selector can be obtained in Solidity with \`IERC721Receiver.onERC721Received.selector\`.\\\\n     */\\\\n    function onERC721Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\\\\\";\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\\\n * account.\\\\n */\\\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\\\n    // Mapping from owner to list of owned token IDs\\\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\\\n\\\\n    // Mapping from token ID to index of the owner tokens list\\\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\\\n\\\\n    // Array with all token ids, used for enumeration\\\\n    uint256[] private _allTokens;\\\\n\\\\n    // Mapping from token id to position in the allTokens array\\\\n    mapping(uint256 => uint256) private _allTokensIndex;\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721.balanceOf(owner), \\\\\\"ERC721Enumerable: owner index out of bounds\\\\\\");\\\\n        return _ownedTokens[owner][index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-totalSupply}.\\\\n     */\\\\n    function totalSupply() public view virtual override returns (uint256) {\\\\n        return _allTokens.length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\\\n     */\\\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\\\n        require(index < ERC721Enumerable.totalSupply(), \\\\\\"ERC721Enumerable: global index out of bounds\\\\\\");\\\\n        return _allTokens[index];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\\\n     */\\\\n    function _beforeTokenTransfer(\\\\n        address from,\\\\n        address to,\\\\n        uint256 firstTokenId,\\\\n        uint256 batchSize\\\\n    ) internal virtual override {\\\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\\\n\\\\n        if (batchSize > 1) {\\\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\\\n            revert(\\\\\\"ERC721Enumerable: consecutive transfers not supported\\\\\\");\\\\n        }\\\\n\\\\n        uint256 tokenId = firstTokenId;\\\\n\\\\n        if (from == address(0)) {\\\\n            _addTokenToAllTokensEnumeration(tokenId);\\\\n        } else if (from != to) {\\\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\\\n        }\\\\n        if (to == address(0)) {\\\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\\\n        } else if (to != from) {\\\\n            _addTokenToOwnerEnumeration(to, tokenId);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\\\n     * @param to address representing the new owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\\\n     */\\\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\\\n        uint256 length = ERC721.balanceOf(to);\\\\n        _ownedTokens[to][length] = tokenId;\\\\n        _ownedTokensIndex[tokenId] = length;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\\\n     */\\\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\\\n        _allTokensIndex[tokenId] = _allTokens.length;\\\\n        _allTokens.push(tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\\\n     * while the token is not assigned a new owner, the \`_ownedTokensIndex\` mapping is _not_ updated: this allows for\\\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\\\n     * @param from address representing the previous owner of the given token ID\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\\\n     */\\\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary\\\\n        if (tokenIndex != lastTokenIndex) {\\\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\\\n\\\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n        }\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _ownedTokensIndex[tokenId];\\\\n        delete _ownedTokens[from][lastTokenIndex];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\\\n     */\\\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\\\n        // then delete the last slot (swap and pop).\\\\n\\\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\\\n\\\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\\\n\\\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\\\n\\\\n        // This also deletes the contents at the last position of the array\\\\n        delete _allTokensIndex[tokenId];\\\\n        _allTokens.pop();\\\\n    }\\\\n}\\\\n\\"
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\": {
        \\"content\\": \\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\n/**\\\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\\\n */\\\\ninterface IERC721Enumerable is IERC721 {\\\\n    /**\\\\n     * @dev Returns the total amount of tokens stored by the contract.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID owned by \`owner\` at a given \`index\` of its token list.\\\\n     * Use along with {balanceOf} to enumerate all of \`\`owner\`\`'s tokens.\\\\n     */\\\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns a token ID at a given \`index\` of all the tokens stored by the contract.\\\\n     * Use along with {totalSupply} to enumerate all tokens.\\\\n     */\\\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\\\n}\\\\n\\"
      }
    },
    \\"settings\\": {
      \\"outputSelection\\": {
        \\"*\\": {
          \\"*\\": [
            \\"abi\\",
            \\"userdoc\\"
          ]
        }
      }
    }
  },
  \\"solcOutput\\": {
    \\"contracts\\": {
      \\"./Contract.sol\\": {
        \\"WagmiMintExample\\": {
          \\"abi\\": [
            {
              \\"inputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"constructor\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"mint\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"mint\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"name\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"symbol\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenURI\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"pure\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"totalSupply\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {
              \\"mint()\\": {
                \\"notice\\": \\"Allows an address to mint\\"
              },
              \\"mint(uint256)\\": {
                \\"notice\\": \\"Returns the token URI for a given token by ID\\"
              },
              \\"tokenURI(uint256)\\": {
                \\"notice\\": \\"Returns the token URI for a given token by ID\\"
              }
            },
            \\"notice\\": \\"An example token original from the wagmi template\\",
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\": {
        \\"ERC721\\": {
          \\"abi\\": [
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"name_\\",
                  \\"type\\": \\"string\\"
                },
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"symbol_\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"constructor\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"name\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"symbol\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenURI\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\": {
        \\"IERC721\\": {
          \\"abi\\": [
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"balance\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\": {
        \\"IERC721Receiver\\": {
          \\"abi\\": [
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"onERC721Received\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\": {
        \\"ERC721Enumerable\\": {
          \\"abi\\": [
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"name\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"symbol\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"index\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenByIndex\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"index\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenOfOwnerByIndex\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenURI\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"totalSupply\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\": {
        \\"IERC721Enumerable\\": {
          \\"abi\\": [
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"balance\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"index\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenByIndex\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"index\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenOfOwnerByIndex\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"totalSupply\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\": {
        \\"IERC721Metadata\\": {
          \\"abi\\": [
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Approval\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": false,
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"ApprovalForAll\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"anonymous\\": false,
              \\"inputs\\": [
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"indexed\\": true,
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"Transfer\\",
              \\"type\\": \\"event\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"approve\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"balanceOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"balance\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"getApproved\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"name\\": \\"isApprovedForAll\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"name\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"ownerOf\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"owner\\",
                  \\"type\\": \\"address\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                },
                {
                  \\"internalType\\": \\"bytes\\",
                  \\"name\\": \\"data\\",
                  \\"type\\": \\"bytes\\"
                }
              ],
              \\"name\\": \\"safeTransferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"operator\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"approved\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"name\\": \\"setApprovalForAll\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [],
              \\"name\\": \\"symbol\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"tokenURI\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"string\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"string\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            },
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"from\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"address\\",
                  \\"name\\": \\"to\\",
                  \\"type\\": \\"address\\"
                },
                {
                  \\"internalType\\": \\"uint256\\",
                  \\"name\\": \\"tokenId\\",
                  \\"type\\": \\"uint256\\"
                }
              ],
              \\"name\\": \\"transferFrom\\",
              \\"outputs\\": [],
              \\"stateMutability\\": \\"nonpayable\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\": {
        \\"Address\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\": {
        \\"Base64\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\": {
        \\"Context\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\": {
        \\"Strings\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\": {
        \\"ERC165\\": {
          \\"abi\\": [
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\": {
        \\"IERC165\\": {
          \\"abi\\": [
            {
              \\"inputs\\": [
                {
                  \\"internalType\\": \\"bytes4\\",
                  \\"name\\": \\"interfaceId\\",
                  \\"type\\": \\"bytes4\\"
                }
              ],
              \\"name\\": \\"supportsInterface\\",
              \\"outputs\\": [
                {
                  \\"internalType\\": \\"bool\\",
                  \\"name\\": \\"\\",
                  \\"type\\": \\"bool\\"
                }
              ],
              \\"stateMutability\\": \\"view\\",
              \\"type\\": \\"function\\"
            }
          ],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\": {
        \\"Math\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\": {
        \\"SignedMath\\": {
          \\"abi\\": [],
          \\"userdoc\\": {
            \\"kind\\": \\"user\\",
            \\"methods\\": {},
            \\"version\\": 1
          }
        }
      }
    },
    \\"sources\\": {
      \\"./Contract.sol\\": {
        \\"id\\": 0
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol\\": {
        \\"id\\": 1
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\\": {
        \\"id\\": 2
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\": {
        \\"id\\": 3
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\": {
        \\"id\\": 4
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\": {
        \\"id\\": 5
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\": {
        \\"id\\": 6
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Address.sol\\": {
        \\"id\\": 7
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Base64.sol\\": {
        \\"id\\": 8
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Context.sol\\": {
        \\"id\\": 9
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/Strings.sol\\": {
        \\"id\\": 10
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\\": {
        \\"id\\": 11
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\\": {
        \\"id\\": 12
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/Math.sol\\": {
        \\"id\\": 13
      },
      \\"/bundler/solc/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\\": {
        \\"id\\": 14
      }
    }
  }
}"
`;
