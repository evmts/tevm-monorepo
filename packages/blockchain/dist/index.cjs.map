{"version":3,"sources":["../src/txType.js","../src/TevmBlockchain.js"],"names":[],"mappings":"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","sourcesContent":["// TODO support OP\nexport const txType = {\n\tLegacy: 0,\n\tAccessListEIP2930: 1,\n\tFeeMarketEIP1559: 2,\n\tBlobEIP4844: 3,\n}\n","import { txType } from './txType.js'\nimport { Block } from '@ethereumjs/block'\n// TODO This is a class but ideally would be a factory function (or multiple factory functions) returning an interface\nimport { Blockchain } from '@ethereumjs/blockchain'\nimport { createJsonRpcFetcher } from '@tevm/jsonrpc'\nimport { hexToNumber, numberToHex } from 'viem'\n\n/**\n * A wrapper around {@link import('@ethereumjs/blockchain').Blockchain}\n * TevmBlockchain notably implements a createFromForkUrl method that properly\n * forks a live blockchain.\n */\nexport class TevmBlockchain extends Blockchain {\n\t/**\n\t * Creates a TevmBlockchain instance\n\t * @override\n\t * @param {import('@ethereumjs/blockchain').BlockchainOptions} [options]\n\t * @returns {Promise<TevmBlockchain>}\n\t */\n\tstatic create = async (options) => {\n\t\tconst blockchain = new TevmBlockchain(options)\n\t\t/**\n\t\t * @warning we are ignoring this is a private method!!!!\n\t\t */\n\t\tawait /** @type any*/ (blockchain)._init(options)\n\t\treturn blockchain\n\t}\n\t/**\n\t * Forks a a given block from rpc url and creates a blockchain\n\t * @param {object} options - A required options object\n\t * @param {string} options.url - The url being forked\n\t * @param {import('viem').BlockTag | bigint | import('viem').Hex} [options.tag] - An optional blockTag to fork\n\t * @param {import('@ethereumjs/blockchain').BlockchainOptions} [options.blockchainOptions] - Options to pass to the underlying {@link import('@ethereumjs/blockchain').Blockchain} constructor\n\t */\n\tstatic createFromForkUrl = async ({ url, tag, blockchainOptions }) => {\n\t\t/**\n\t\t * @type {import('@tevm/jsonrpc').JsonRpcResponse<'eth_getBlockByHash'|'eth_getBlockByNumber', import('@ethereumjs/block').JsonRpcBlock, any>}\n\t\t */\n\t\tlet blockResponse\n\n\t\tif (typeof tag === 'string' && tag.startsWith('0x') && tag.length === 66) {\n\t\t\tblockResponse = /** @type any*/ (\n\t\t\t\tawait createJsonRpcFetcher(url).request({\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: 1,\n\t\t\t\t\tmethod: 'eth_getBlockByHash',\n\t\t\t\t\tparams: [tag, true],\n\t\t\t\t})\n\t\t\t)\n\t\t} else if (typeof tag === 'bigint') {\n\t\t\tblockResponse = /** @type any*/ (\n\t\t\t\tawait createJsonRpcFetcher(url).request({\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: 1,\n\t\t\t\t\tmethod: 'eth_getBlockByNumber',\n\t\t\t\t\tparams: [numberToHex(tag), true],\n\t\t\t\t})\n\t\t\t)\n\t\t} else if (\n\t\t\t[\n\t\t\t\tundefined,\n\t\t\t\t'latest',\n\t\t\t\t'earliest',\n\t\t\t\t'pending',\n\t\t\t\t'safe',\n\t\t\t\t'finalized',\n\t\t\t].includes(tag)\n\t\t) {\n\t\t\tblockResponse = /** @type any*/ (\n\t\t\t\tawait createJsonRpcFetcher(url).request({\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: 1,\n\t\t\t\t\tmethod: 'eth_getBlockByNumber',\n\t\t\t\t\tparams: [tag ?? 'latest', true],\n\t\t\t\t})\n\t\t\t)\n\t\t} else {\n\t\t\tthrow new Error(`Invalid block tag provided: ${tag}`)\n\t\t}\n\n\t\tif (blockResponse.error) {\n\t\t\tthrow blockResponse.error\n\t\t}\n\t\tif (!blockResponse.result) {\n\t\t\tthrow new Error(\n\t\t\t\t'Malformed JSON-RPC response: No data nor errors returned in JSON-RPC request to forkUrl',\n\t\t\t)\n\t\t}\n\n\t\tconst uncleHeaders = await Promise.all(\n\t\t\t/** @type {Array<unknown>}*/ (blockResponse.result.uncles).map((_, i) => {\n\t\t\t\t// TODO make this do a bulk request instead\n\t\t\t\treturn createJsonRpcFetcher(url).request({\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: 1,\n\t\t\t\t\tmethod: 'eth_getUncleByBlockHashAndIndex',\n\t\t\t\t\tparams: [\n\t\t\t\t\t\t/**@type {import('@ethereumjs/block').JsonRpcBlock}*/ (\n\t\t\t\t\t\t\tblockResponse.result\n\t\t\t\t\t\t).hash,\n\t\t\t\t\t\tnumberToHex(i),\n\t\t\t\t\t],\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\tconst chain = await TevmBlockchain.create(blockchainOptions)\n\n\t\t// filter out unsupported transactions\n\t\tconst supportedTransactions = blockResponse.result.transactions.filter(\n\t\t\t(tx) =>\n\t\t\t\ttypeof tx === 'string' ||\n\t\t\t\tObject.values(txType).includes(\n\t\t\t\t\thexToNumber(/**@type {import('viem').Hex}*/ (tx.type)),\n\t\t\t\t),\n\t\t)\n\n\t\tawait chain.putBlock(\n\t\t\tBlock.fromRPC(\n\t\t\t\t{ ...blockResponse.result, transactions: supportedTransactions },\n\t\t\t\tuncleHeaders,\n\t\t\t\tblockchainOptions?.common\n\t\t\t\t\t? { common: blockchainOptions.common }\n\t\t\t\t\t: undefined,\n\t\t\t),\n\t\t)\n\n\t\treturn chain\n\t}\n\n\t/**\n\t * @type {import('@ethereumjs/block').Block | undefined}\n\t */\n\t#pendingBlock = undefined\n\n\t/**\n\t * @returns {Promise<import('@ethereumjs/block').Block | undefined>}\n\t */\n\tgetPendingBlock = async () => {\n\t\treturn this.#pendingBlock\n\t}\n\n\t/**\n\t * @param {import('@ethereumjs/block').Block | undefined} block\n\t * @returns {Promise<void>}\n\t */\n\tsetPendingBlock = async (block) => {\n\t\tthis.#pendingBlock = block\n\t}\n\n\t/**\n\t * @param {object} options\n\t * @param {import('viem').BlockTag | bigint} options.tag\n\t */\n\tgetBlockByOption = async ({ tag }) => {\n\t\tswitch (tag) {\n\t\t\tcase undefined:\n\t\t\tcase 'pending':\n\t\t\t\treturn this.getPendingBlock()\n\t\t\tcase 'earliest':\n\t\t\t\treturn this.getBlock(0n)\n\t\t\tcase 'latest':\n\t\t\t\treturn this.getCanonicalHeadBlock()\n\t\t\tcase 'safe':\n\t\t\t\treturn this.getIteratorHeadSafe()\n\t\t\tcase 'finalized':\n\t\t\t\tthrow new Error('Tevm does not support finalized block tag')\n\t\t\tdefault: {\n\t\t\t\tconst latest = await this.getCanonicalHeadBlock()\n\t\t\t\tif (tag > latest.header.number) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {import('@tevm/errors').InvalidBlockError}\n\t\t\t\t\t */\n\t\t\t\t\tconst err = {\n\t\t\t\t\t\t_tag: 'InvalidBlockError',\n\t\t\t\t\t\tname: 'InvalidBlockError',\n\t\t\t\t\t\tmessage: 'specified block greater than current height',\n\t\t\t\t\t}\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t\tif (tag === latest.header.number) {\n\t\t\t\t\treturn latest\n\t\t\t\t}\n\t\t\t\treturn this.getBlock(tag)\n\t\t\t}\n\t\t}\n\t}\n}\n"]}