[@tevm/contract](README.md) / Exports

# @tevm/contract

## Table of contents

### Type Aliases

- [Contract](modules.md#contract)
- [CreateContract](modules.md#createcontract)
- [CreateContractParams](modules.md#createcontractparams)
- [CreateScript](modules.md#createscript)
- [CreateScriptParams](modules.md#createscriptparams)
- [EventActionCreator](modules.md#eventactioncreator)
- [MaybeExtractEventArgsFromAbi](modules.md#maybeextracteventargsfromabi)
- [ReadActionCreator](modules.md#readactioncreator)
- [Script](modules.md#script)
- [ValueOf](modules.md#valueof)
- [WriteActionCreator](modules.md#writeactioncreator)

### Functions

- [createContract](modules.md#createcontract-1)
- [createScript](modules.md#createscript-1)

## Type Aliases

### Contract

Ƭ **Contract**\<`TName`, `THumanReadableAbi`\>: `Object`

An action creator for `Tevm.contract`, `Tevm.eth.getEvents` and more
It also is the type solidity contract imports are turned into.

Contracts generate actions that can be dispatched to tevm methods
such as `contract` `traceContract` and `eth.events`

**`Example`**

```typescript
tevm.contract(
-  { abi: [...], args: ['0x1234...'], functionName: 'balanceOf' },
+  MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
)
```

A contract can be made via the `createContract` function

**`Example`**

```typescript
import { type Contract, createContract} from 'tevm/contract'

const contract: Contract = createContract({
  name: 'MyContract',
 	abi: [
 		...
 	],
})
```
These contracts can be automatically generated by using [@tevm/bundler](https://todo.todo)
and then importing it. The Tevm bundler will automatically resolve your solidity imports into
tevm contract instances

**`Example`**

```typescript
import { MyContract } from './MyContract.sol'

console.log(MyContract.humanReadableAbi)
```
Address can be added to a contract using the `withAddress` method

**`Example`**

```typescript
import { MyContract } from './MyContract.sol'

const MyContractOptimism = MyContract.withAddress('0x420...')
```
Contracts can also be used with other libraries such as Viem and ethers.

**`Example`**

```typescript
import { MyContract } from './MyContract.sol'
import { createPublicClient } from 'viem'

// see viem docs
const client = createPublicClient({...})

const result = await client.readContract(
  MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
)

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends `ReadonlyArray`\<`string`\> |

#### Type declaration

| Name | Type | Description |
| :------ | :------ | :------ |
| `abi` | `ParseAbi`\<`THumanReadableAbi`\> | The json abi of the contract **`Example`** ```typescript import { MyContract } from './MyContract.sol' console.log(MyContract.abi) // [{name: 'balanceOf', inputs: [...], outputs: [...], ...}] ``` |
| `bytecode?` | `undefined` | The contract bytecode is not defined on Contract objects are expected to be deployed to the chain. See `Script` type which is a contract with bytecode It's provided here to allow easier access of the property when using a `Contract \| Script` union type |
| `deployedBytecode?` | `undefined` | The contract deployedBytecode is not defined on Contract objects are expected to be deployed to the chain. See `Script` type which is a contract with deployedBytecode It's provided here to allow easier access of the property when using a `Contract \| Script` union type |
| `events` | [`EventActionCreator`](modules.md#eventactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `undefined`\> | Action creators for events. Can be used to create event filters in a typesafe way **`Example`** ```typescript tevm.eth.getLog( MyContract.withAddress('0x420...').events.Transfer({ from: '0x1234...' }), ) === |
| `humanReadableAbi` | `THumanReadableAbi` | The human readable abi of the contract **`Example`** ```typescript import { MyContract } from './MyContract.sol' console.log(MyContract.humanReadableAbi) // ['function balanceOf(address): uint256', ...] ``` |
| `name` | `TName` | The name of the contract. If imported this will match the name of the contract import |
| `read` | [`ReadActionCreator`](modules.md#readactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `undefined`\> | Action creators for contract view and pure functions **`Example`** ```typescript tevm.contract( MyContract.withAddress('0x420...').read.balanceOf('0x1234...'), ) ``` |
| `withAddress` | \<TAddress\>(`address`: `TAddress`) => `Omit`\<[`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>, ``"read"`` \| ``"write"`` \| ``"events"`` \| ``"address"``\> & \{ `address`: `TAddress` ; `events`: [`EventActionCreator`](modules.md#eventactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `TAddress`\> ; `read`: [`ReadActionCreator`](modules.md#readactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `TAddress`\> ; `write`: [`WriteActionCreator`](modules.md#writeactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `TAddress`\>  } | Adds an address to the contract. All action creators will return the address property if added. **`Example`** ```typescript import { MyContract } from './MyContract.sol' const MyContractOptimism = MyContract.withAddress('0x420...') ``` |
| `write` | [`WriteActionCreator`](modules.md#writeactioncreator)\<`THumanReadableAbi`, `undefined`, `undefined`, `undefined`\> | Action creators for contract payable and nonpayable functions **`Example`** ```typescript tevm.contract( MyContract.withAddress('0x420...').read.balanceOf('0x1234...'), ) ``` |

#### Defined in

[Contract.ts:61](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/Contract.ts#L61)

___

### CreateContract

Ƭ **CreateContract**: \<TName, THumanReadableAbi\>(`{
	name,
	humanReadableAbi,
}`: [`CreateContractParams`](modules.md#createcontractparams)\<`TName`, `THumanReadableAbi`\>) => [`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>

Type of `createContract` factory function
Creates a tevm Contract instance from human readable abi

**`Example`**

```typescript
import { type Contract, createContract} from 'tevm/contract'

const contract: Contract = createContract({
  name: 'MyContract',
 	abi: [
 		...
 	],
})
```

To use a json abi first pass it into `formatAbi` to turn it into human readable

**`Example`**

```typescript
import { type Contract, createContract} from 'tevm/contract'

const contract = createContract({
  name: 'MyContract',
 	abi: [
 		...
 	],
})
```

#### Type declaration

▸ \<`TName`, `THumanReadableAbi`\>(`{
	name,
	humanReadableAbi,
}`): [`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>

##### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

##### Parameters

| Name | Type |
| :------ | :------ |
| `{
	name,
	humanReadableAbi,
}` | [`CreateContractParams`](modules.md#createcontractparams)\<`TName`, `THumanReadableAbi`\> |

##### Returns

[`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>

#### Defined in

[types.ts:41](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/types.ts#L41)

___

### CreateContractParams

Ƭ **CreateContractParams**\<`TName`, `THumanReadableAbi`\>: `Pick`\<[`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>, ``"name"`` \| ``"humanReadableAbi"``\>

Params for creating a [Contract](modules.md#contract) instance

**`See`**

[CreateContract](modules.md#createcontract)

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

#### Defined in

[types.ts:8](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/types.ts#L8)

___

### CreateScript

Ƭ **CreateScript**: \<TName, THumanReadableAbi\>(`{
	name,
	humanReadableAbi,
	bytecode,
	deployedBytecode,
}`: [`CreateScriptParams`](modules.md#createscriptparams)\<`TName`, `THumanReadableAbi`\>) => [`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>

Type of `createScript` factory function
Creates a tevm Script instance from human readable abi

**`Example`**

```typescript
import { type Script, createScript} from 'tevm/contract'

const script: Script = createScript({
  name: 'MyScript',
  humanReadableAbi: ['function exampleRead(): uint256', ...],
  bytecode: '0x123...',
  deployedBytecode: '0x123...',
})
```

To use a json abi first pass it into `formatAbi` to turn it into human readable

**`Example`**

```typescript
import { type Script, createScript, formatAbi} from 'tevm/contract'
import { formatAbi } from 'tevm/abi'

const script = createScript({
 name: 'MyScript',
 bytecode: '0x123...',
 deployedBytecode: '0x123...',
 humanReadableAbi: formatAbi([
  {
    name: 'balanceOf',
    inputs: [
    {
    name: 'owner',
    type: 'address',
    },
    ],
    outputs: [
    {
    name: 'balance',
    type: 'uint256',
    },
  }
  ]),
 })

#### Type declaration

▸ \<`TName`, `THumanReadableAbi`\>(`{
	name,
	humanReadableAbi,
	bytecode,
	deployedBytecode,
}`): [`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>

##### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

##### Parameters

| Name | Type |
| :------ | :------ |
| `{
	name,
	humanReadableAbi,
	bytecode,
	deployedBytecode,
}` | [`CreateScriptParams`](modules.md#createscriptparams)\<`TName`, `THumanReadableAbi`\> |

##### Returns

[`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>

#### Defined in

[types.ts:107](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/types.ts#L107)

___

### CreateScriptParams

Ƭ **CreateScriptParams**\<`TName`, `THumanReadableAbi`\>: `Pick`\<[`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>, ``"name"`` \| ``"humanReadableAbi"`` \| ``"bytecode"`` \| ``"deployedBytecode"``\>

Params for creating a [Script](modules.md#script) instance

**`See`**

[CreateScript](modules.md#createscript)

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

#### Defined in

[types.ts:56](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/types.ts#L56)

___

### EventActionCreator

Ƭ **EventActionCreator**\<`THumanReadableAbi`, `TBytecode`, `TDeployedBytecode`, `TAddress`, `TAddressArgs`\>: \{ [TEventName in ExtractAbiEventNames\<ParseAbi\<THumanReadableAbi\>\>]: Function & Object & TAddressArgs }

A mapping of event names to action creators for events. Can be used to create event filters in a typesafe way

**`Example`**

```typescript
tevm.eth.getLog(
  MyScript.withAddress('0x420...').events.Transfer({ from: '0x1234...' }),
)
===

#### Type parameters

| Name | Type |
| :------ | :------ |
| `THumanReadableAbi` | extends readonly `string`[] |
| `TBytecode` | extends `Hex` \| `undefined` |
| `TDeployedBytecode` | extends `Hex` \| `undefined` |
| `TAddress` | extends `Address` \| `undefined` |
| `TAddressArgs` | `TAddress` extends `undefined` ? {} : \{ `address`: `TAddress`  } |

#### Defined in

[event/EventActionCreator.ts:38](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/event/EventActionCreator.ts#L38)

___

### MaybeExtractEventArgsFromAbi

Ƭ **MaybeExtractEventArgsFromAbi**\<`TAbi`, `TEventName`\>: `TAbi` extends `Abi` \| readonly `unknown`[] ? `TEventName` extends `string` ? `GetEventArgs`\<`TAbi`, `TEventName`\> : `undefined` : `undefined`

Adapted from viem. This is a helper type to extract the event args from an abi

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TAbi` | extends `Abi` \| readonly `unknown`[] \| `undefined` |
| `TEventName` | extends `string` \| `undefined` |

#### Defined in

[event/EventActionCreator.ts:18](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/event/EventActionCreator.ts#L18)

___

### ReadActionCreator

Ƭ **ReadActionCreator**\<`THumanReadableAbi`, `TBytecode`, `TDeployedBytecode`, `TAddress`, `TAddressArgs`\>: \{ [TFunctionName in ExtractAbiFunctionNames\<ParseAbi\<THumanReadableAbi\>, "pure" \| "view"\>]: Function & Object & TAddressArgs }

A mapping of view and pure contract methods to action creators

**`Example`**

```typescript
tevm.contract(
  MyScript.withAddress('0x420...').read.balanceOf('0x1234...'),
)
```

#### Type parameters

| Name | Type |
| :------ | :------ |
| `THumanReadableAbi` | extends readonly `string`[] |
| `TBytecode` | extends `Hex` \| `undefined` |
| `TDeployedBytecode` | extends `Hex` \| `undefined` |
| `TAddress` | extends `Address` \| `undefined` |
| `TAddressArgs` | `TAddress` extends `undefined` ? {} : \{ `address`: `TAddress` ; `to`: `TAddress`  } |

#### Defined in

[read/ReadActionCreator.ts:23](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/read/ReadActionCreator.ts#L23)

___

### Script

Ƭ **Script**\<`TName`, `THumanReadableAbi`\>: `Object`

An action creator for `Tevm.script`, `Tevm.contract` and more
representing a solidity contract bytecode and ABI.
Scripts are akin to Foundry scripts you can run in the Tevm vm.

Script is also is the type solidity contract imports are turned into.

Scripts and contracts generate actions that can be dispatched to tevm methods
such as `contract` and `script`

**`Example`**

```typescript
tevm.script(
-  { deployedBytecode: '0x60242....', abi: [...], args: ['0x1234...'], functionName: 'balanceOf' },
+  MyScript.withAddress('0x420...').read.balanceOf('0x1234...'),
)
```

A script can be made via the `createScript` function

**`Example`**

```typescript
import { type Contract, createScript} from 'tevm/contract'

const contract: Contract = createScript({
  name: 'MyScript',
 	abi: [
 		...
 	],
})
```
These scripts can be automatically generated by using [@tevm/bundler](https://todo.todo)
and then importing it. The Tevm bundler will automatically resolve your solidity imports into
tevm contract instances

**`Example`**

```typescript
import { MyScript } from './MyScript.sol'

console.log(MyScript.humanReadableAbi)
```
Address can be added to a contract using the `withAddress` method

**`Example`**

```typescript
import { MyScript } from './MyScript.sol'

const MyScript = MyScript.withAddress('0x420...')
```
Scripts can also be used with other libraries such as Viem and ethers.

**`Example`**

```typescript
import { MyScript } from './MyScript.sol'
import { createPublicClient } from 'viem'

// see viem docs
const client = createPublicClient({...})

const result = await client.readContract(
  MyScript.withAddress('0x420...').read.balanceOf('0x1234...'),
)

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends `ReadonlyArray`\<`string`\> |

#### Type declaration

| Name | Type | Description |
| :------ | :------ | :------ |
| `abi` | `ParseAbi`\<`THumanReadableAbi`\> | The json abi of the contract **`Example`** ```typescript import { MyScript } from './MyScript.sol' console.log(MyScript.abi) // [{name: 'balanceOf', inputs: [...], outputs: [...], ...}] ``` |
| `bytecode` | `Hex` | The contract bytecode. This can be used for deploying the contract bytecode is different from deployedBytecode in that the bytecode includes the code to deploy the contract whereas the deployed bytecode is the code that is deployed |
| `deployedBytecode` | `Hex` | The deployed contract bytecode. TThis can be used with the `script` tevm method to execute arbitrary solidity code that isn't necessarily deployed to the chain deployedBytecode is different from bytecode in that the bytecode includes the code to deploy the contract whereas the deployed bytecode is the code that is deployed |
| `events` | [`EventActionCreator`](modules.md#eventactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `undefined`\> | Action creators for events. Can be used to create event filters in a typesafe way **`Example`** ```typescript tevm.eth.getLog( MyScript.withAddress('0x420...').events.Transfer({ from: '0x1234...' }), ) === |
| `humanReadableAbi` | `THumanReadableAbi` | The human readable abi of the contract **`Example`** ```typescript import { MyScript } from './MyScript.sol' console.log(MyScript.humanReadableAbi) // ['function balanceOf(address): uint256', ...] ``` |
| `name` | `TName` | The name of the contract. If imported this will match the name of the contract import |
| `read` | [`ReadActionCreator`](modules.md#readactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `undefined`\> | Action creators for contract view and pure functions **`Example`** ```typescript tevm.contract( MyScript.withAddress('0x420...').read.balanceOf('0x1234...'), ) ``` |
| `withAddress` | \<TAddress\>(`address`: `TAddress`) => `Omit`\<[`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>, ``"events"`` \| ``"read"`` \| ``"write"`` \| ``"address"``\> & \{ `address`: `TAddress` ; `events`: [`EventActionCreator`](modules.md#eventactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `TAddress`\> ; `read`: [`ReadActionCreator`](modules.md#readactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `TAddress`\> ; `write`: [`WriteActionCreator`](modules.md#writeactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `TAddress`\>  } | Adds an address to the contract. All action creators will return the address property if added. **`Example`** ```typescript import { MyScript } from './MyScript.sol' const MyScript = MyScript.withAddress('0x420...') ``` Note this is not necessary with `tevm.script` method that doesn't require a contract address to execute |
| `write` | [`WriteActionCreator`](modules.md#writeactioncreator)\<`THumanReadableAbi`, `Hex`, `Hex`, `undefined`\> | Action creators for contract payable and nonpayable functions **`Example`** ```typescript tevm.contract( MyScript.withAddress('0x420...').read.balanceOf('0x1234...'), ) ``` |

#### Defined in

[Script.ts:64](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/Script.ts#L64)

___

### ValueOf

Ƭ **ValueOf**\<`T`\>: `T`[keyof `T`]

#### Type parameters

| Name |
| :------ |
| `T` |

#### Defined in

[event/EventActionCreator.ts:27](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/event/EventActionCreator.ts#L27)

___

### WriteActionCreator

Ƭ **WriteActionCreator**\<`THumanReadableAbi`, `TBytecode`, `TDeployedBytecode`, `TAddress`, `TAddressArgs`\>: \{ [TFunctionName in ExtractAbiFunctionNames\<ParseAbi\<THumanReadableAbi\>, "payable" \| "nonpayable"\>]: Function & Object & TAddressArgs }

A mapping of payable and nonpayable contract methods to action creators

**`Example`**

```typescript
tevm.contract(
  MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
)
```

#### Type parameters

| Name | Type |
| :------ | :------ |
| `THumanReadableAbi` | extends readonly `string`[] |
| `TBytecode` | extends `Hex` \| `undefined` |
| `TDeployedBytecode` | extends `Hex` \| `undefined` |
| `TAddress` | extends `Address` \| `undefined` |
| `TAddressArgs` | `TAddress` extends `undefined` ? {} : \{ `address`: `TAddress` ; `to`: `TAddress`  } |

#### Defined in

[write/WriteActionCreator.ts:23](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/write/WriteActionCreator.ts#L23)

## Functions

### createContract

▸ **createContract**\<`TName`, `THumanReadableAbi`\>(`«destructured»`): [`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>

Creates a tevm Contract instance from human readable abi

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`CreateContractParams`](modules.md#createcontractparams)\<`TName`, `THumanReadableAbi`\> |

#### Returns

[`Contract`](modules.md#contract)\<`TName`, `THumanReadableAbi`\>

**`Example`**

```typescript
import { type Contract, createContract} from 'tevm/contract'

const contract: Contract = createContract({
  name: 'MyContract',
 	abi: [
 		...
 	],
})
```

To use a json abi first pass it into `formatAbi` to turn it into human readable

**`Example`**

```typescript
import { type Contract, createContract} from 'tevm/contract'

const contract = createContract({
  name: 'MyContract',
 	abi: [
 		...
 	],
})
```

#### Defined in

[createContract.js:34](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/createContract.js#L34)

___

### createScript

▸ **createScript**\<`TName`, `THumanReadableAbi`\>(`«destructured»`): [`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>

Creates a Tevm `Script` instance from humanReadableAbi and bytecode

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TName` | extends `string` |
| `THumanReadableAbi` | extends readonly `string`[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`CreateScriptParams`](modules.md#createscriptparams)\<`TName`, `THumanReadableAbi`\> |

#### Returns

[`Script`](modules.md#script)\<`TName`, `THumanReadableAbi`\>

**`Example`**

```typescript
import { type Script, createScript} from 'tevm/contract'

const script: Script = createScript({
  name: 'MyScript',
  humanReadableAbi: ['function exampleRead(): uint256', ...],
  bytecode: '0x123...',
  deployedBytecode: '0x123...',
})
```

To use a json abi first pass it into `formatAbi` to turn it into human readable

**`Example`**

```typescript
import { type Script, createScript, formatAbi} from 'tevm/contract'
import { formatAbi } from 'tevm/utils'

const script = createScript({
 name: 'MyScript',
 bytecode: '0x123...',
 deployedBytecode: '0x123...',
 humanReadableAbi: formatAbi([
  {
    name: 'balanceOf',
    inputs: [
    {
    name: 'owner',
    type: 'address',
    },
    ],
    outputs: [
    {
    name: 'balance',
    type: 'uint256',
    },
  }
  ]),
 })
 ```

#### Defined in

[createScript.js:50](https://github.com/evmts/tevm-monorepo/blob/main/packages/contract/src/createScript.js#L50)
