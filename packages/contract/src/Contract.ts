import type { Address, EncodeDeployDataParameters, Hex, ParseAbi } from '@tevm/utils'
import type { CreateScript } from './CreateScript.js'
import type { EventActionCreator } from './event/EventActionCreator.js'
import type { ReadActionCreator } from './read/ReadActionCreator.js'
import type { WriteActionCreator } from './write/WriteActionCreator.js'

/**
 * An action creator for `Tevm.contract`, `Tevm.eth.getEvents` and more
 * It also is the type solidity contract imports are turned into.
 *
 * Contracts generate actions that can be dispatched to tevm methods
 * such as `contract` `traceContract` and `eth.events`
 * @example
 * ```typescript
 * tevm.contract(
 * -  { abi: [...], args: ['0x1234...'], functionName: 'balanceOf' },
 * +  MyContract.atAddress('0x420...').read.balanceOf('0x1234...'),
 * )
 * ```
 *
 * A contract can be made via the `createContract` function
 * @example
 * ```typescript
 * import { type Contract, createContract} from 'tevm/contract'
 *
 * const contract: Contract = createContract({
 *   name: 'MyContract',
 *  	abi: [
 *  		...
 *  	],
 * })
 * ```
 * These contracts can be automatically generated by using [@tevm/bundler](https://todo.todo)
 * and then importing it. The Tevm bundler will automatically resolve your solidity imports into
 * tevm contract instances
 * @example
 * ```typescript
 * import { MyContract } from './MyContract.sol'
 *
 * console.log(MyContract.humanReadableAbi)
 * ```
 * Address can be added to a contract using the `withAddress` method
 * @example
 * ```typescript
 * import { MyContract } from './MyContract.sol'
 *
 * const MyContractOptimism = MyContract.withAddress('0x420...')
 * ```
 * Contracts can also be used with other libraries such as Viem and ethers.
 * @example
 * ```typescript
 * import { MyContract } from './MyContract.sol'
 * import { createPublicClient } from 'viem'
 *
 * // see viem docs
 * const client = createPublicClient({...})
 *
 * const result = await client.readContract(
 *   MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
 * )
 */
export type Contract<
	TName extends string,
	THumanReadableAbi extends ReadonlyArray<string>,
	TAddress extends undefined | Address = undefined,
	// Bytecode is the contract bytecode with constructor
	TBytecode extends undefined | Hex = undefined,
	// DeployedBytecode is the raw bytecode without constructor
	TDeployedBytecode extends undefined | Hex = undefined,
	// Code is Bytecode encoded with constructor arguments
	TCode extends undefined | Hex = undefined,
> = {
	/**
	 * Configured address of the contract. If not set it will be undefined
	 * To set use the `withAddress` method
	 */
	address: TAddress
	/**
	 * The json abi of the contract
	 * @example
	 * ```typescript
	 * import { MyContract } from './MyContract.sol'
	 * console.log(MyContract.abi) // [{name: 'balanceOf', inputs: [...], outputs: [...], ...}]
	 * ```
	 */
	abi: ParseAbi<THumanReadableAbi>
	/**
	 * Code i
	 */
	code: TCode
	/**
	 * The contract bytecode is not defined on Contract objects are expected
	 * to be deployed to the chain. See `Script` type which is a contract with bytecode
	 * It's provided here to allow easier access of the property when using a
	 * `Contract | Script` union type
	 */
	bytecode: TBytecode
	/**
	 * The contract deployedBytecode is not defined on Contract objects are expected
	 * to be deployed to the chain. See `Script` type which is a contract with deployedBytecode
	 * It's provided here to allow easier access of the property when using a
	 * `Contract | Script` union type
	 */
	deployedBytecode: TDeployedBytecode
	/**
	 * The human readable abi of the contract
	 * @example
	 * ```typescript
	 * import { MyContract } from './MyContract.sol'
	 * console.log(MyContract.humanReadableAbi)
	 * // ['function balanceOf(address): uint256', ...]
	 * ```
	 */
	humanReadableAbi: THumanReadableAbi
	/**
	 * The name of the contract. If imported this will match the name of the contract import
	 */
	name?: TName
	/**
	 * Action creators for events. Can be used to create event filters in a typesafe way
	 * @example
	 * ```typescript
	 * tevm.eth.getLog(
	 *   MyContract.withAddress('0x420...').events.Transfer({ from: '0x1234...' }),
	 * )
	 * ===
	 */
	events: EventActionCreator<THumanReadableAbi, TAddress, TBytecode, TDeployedBytecode>
	/**
	 * Action creators for contract view and pure functions
	 * @example
	 * ```typescript
	 * tevm.contract(
	 *   MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
	 *)
	 * ```
	 */
	read: ReadActionCreator<THumanReadableAbi, TAddress, TCode>
	/**
	 * Action creators for contract payable and nonpayable functions
	 * @example
	 * ```typescript
	 * tevm.contract(
	 *   MyContract.withAddress('0x420...').read.balanceOf('0x1234...'),
	 * )
	 * ```
	 */
	write: WriteActionCreator<THumanReadableAbi, TAddress, TCode>
	/**
	 * Action creator for deploying the contract
	 */
	deploy: () => EncodeDeployDataParameters<ParseAbi<THumanReadableAbi>>
	/**
	 * Adds an address to the contract. All action creators will return
	 * the address property if added. THis method returns a new contract
	 * it does not modify the existing contract.
	 * @example
	 * ```typescript
	 * import { MyContract } from './MyContract.sol'
	 * const MyContractOptimism = MyContract.withAddress('0x420...')
	 * ```
	 */
	withAddress: <TAddress extends Address>(
		address: TAddress,
	) => Contract<TName, THumanReadableAbi, TAddress, TBytecode, TDeployedBytecode, TCode>
	/**
	 * Creates a deployless instance of the contract that can be used with
	 * tevm and viem as [deployless contracts](https://viem.sh/docs/contract/readContract#deployless-reads)
	 */
	script: CreateScript<TName, THumanReadableAbi, TAddress, TBytecode>
}
