# 4.5 Precompiled Contracts

This document provides a comprehensive reference for precompiled contracts in REVM, including their specification, implementation details, gas cost calculation, and guidance on implementing custom precompiles.

## Introduction to Precompiled Contracts

Precompiled contracts are special contracts that are implemented natively in the EVM to provide functionality that would be prohibitively expensive or impossible to implement in Solidity. They are identified by predefined addresses and are called using the standard EVM `CALL` or `STATICCALL` operations.

Unlike regular smart contracts, precompiled contracts don't have bytecode stored on the blockchain. Instead, their functionality is directly implemented in the Ethereum client.

## Precompile Interface

In REVM, all precompiled contracts implement the `Precompile` trait:

```rust
pub trait Precompile: Send + Sync {
    /// Calculate the required gas for executing the precompile
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError>;
    
    /// Execute the precompile with the given input
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError>;
}
```

The `PrecompileOutput` struct contains the result data and any logs generated:

```rust
pub struct PrecompileOutput {
    /// Output data
    pub output: Bytes,
    /// Logs generated during execution
    pub logs: Vec<Log>,
}
```

When an error occurs, precompiles can return a `PrecompileError`:

```rust
pub enum PrecompileError {
    /// Out of gas
    OutOfGas,
    /// Invalid input
    InvalidInput,
    /// Other custom error
    Error(String),
}
```

## Standard Precompiled Contracts

REVM implements all standard Ethereum precompiled contracts:

### 1. ECRECOVER (0x01)

Recovers the Ethereum address associated with the public key from an elliptic curve signature.

**Input Format**:
- Bytes 0-31: 32-byte hash of the data that was signed
- Bytes 32-63: v value (recovery identifier)
- Bytes 64-95: r value (first half of the signature)
- Bytes 96-127: s value (second half of the signature)

**Output Format**:
- Bytes 0-31: 32-byte recovered address (right-padded with zeros)

**Gas Cost**: 3000 gas (fixed)

**Implementation**:

```rust
pub struct ECRecover;

impl Precompile for ECRecover {
    fn required_gas(&self, _input: &[u8]) -> Result<u64, PrecompileError> {
        Ok(3000)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Ensure input is at least 128 bytes
        if input.len() < 128 {
            // If input is less than 128 bytes, pad with zeros
            let mut padded_input = vec![0; 128];
            padded_input[..input.len()].copy_from_slice(input);
            
            return self.ecrecover(&padded_input);
        }
        
        self.ecrecover(input)
    }
}

impl ECRecover {
    fn ecrecover(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Extract hash, v, r, s from input
        let hash = H256::from_slice(&input[0..32]);
        let v = U256::from_big_endian(&input[32..64]);
        let r = H256::from_slice(&input[64..96]);
        let s = H256::from_slice(&input[96..128]);
        
        // Validate v value (must be 27 or 28 for legacy signatures)
        let recovery_id = match v.as_u64() {
            27 => 0,
            28 => 1,
            v if v >= 35 => ((v - 35) % 2) as u8,
            _ => return Ok((PrecompileOutput { 
                output: Bytes::default(),
                logs: Vec::new(),
            }, 3000))
        };
        
        // Convert r, s to signature format
        let mut signature = [0u8; 64];
        signature[0..32].copy_from_slice(r.as_bytes());
        signature[32..64].copy_from_slice(s.as_bytes());
        
        // Attempt recovery
        match secp256k1::recover(
            &secp256k1::Message::from_slice(hash.as_bytes()).unwrap(),
            &secp256k1::Signature::from_compact(&signature).unwrap(),
            &secp256k1::RecoveryId::from_i32(recovery_id as i32).unwrap(),
        ) {
            Ok(public_key) => {
                // Compute Ethereum address from public key
                let public_key = public_key.serialize_uncompressed();
                let hash = keccak256(&public_key[1..]);
                
                // Address is the last 20 bytes of the hash
                let mut address = [0u8; 32];
                address[12..32].copy_from_slice(&hash[12..32]);
                
                Ok((PrecompileOutput {
                    output: Bytes::from(address.to_vec()),
                    logs: Vec::new(),
                }, 3000))
            },
            Err(_) => {
                // Recovery failed, return empty result
                Ok((PrecompileOutput {
                    output: Bytes::default(),
                    logs: Vec::new(),
                }, 3000))
            }
        }
    }
}
```

### 2. SHA256 (0x02)

Computes the SHA-256 hash of the input data.

**Input Format**:
- Arbitrary input data

**Output Format**:
- Bytes 0-31: 32-byte SHA-256 hash of the input

**Gas Cost**: 60 gas + 12 gas per input word (rounded up)

**Implementation**:

```rust
pub struct SHA256;

impl Precompile for SHA256 {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Calculate gas cost: 60 + 12 * (input_len / 32)
        // Round up the division
        let words = (input.len() + 31) / 32;
        Ok(60 + 12 * words as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Compute SHA-256 hash
        let mut hasher = sha2::Sha256::new();
        hasher.update(input);
        let result = hasher.finalize();
        
        Ok((PrecompileOutput {
            output: Bytes::from(result.to_vec()),
            logs: Vec::new(),
        }, gas))
    }
}
```

### 3. RIPEMD160 (0x03)

Computes the RIPEMD-160 hash of the input data.

**Input Format**:
- Arbitrary input data

**Output Format**:
- Bytes 0-31: 32-byte value containing RIPEMD-160 hash (20 bytes) right-padded with zeros

**Gas Cost**: 600 gas + 120 gas per input word (rounded up)

**Implementation**:

```rust
pub struct RIPEMD160;

impl Precompile for RIPEMD160 {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Calculate gas cost: 600 + 120 * (input_len / 32)
        // Round up the division
        let words = (input.len() + 31) / 32;
        Ok(600 + 120 * words as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Compute RIPEMD-160 hash
        let mut hasher = ripemd::Ripemd160::new();
        hasher.update(input);
        let result = hasher.finalize();
        
        // Pad result to 32 bytes
        let mut padded_result = [0u8; 32];
        padded_result[12..32].copy_from_slice(&result);
        
        Ok((PrecompileOutput {
            output: Bytes::from(padded_result.to_vec()),
            logs: Vec::new(),
        }, gas))
    }
}
```

### 4. IDENTITY (0x04)

Returns the input data unmodified.

**Input Format**:
- Arbitrary input data

**Output Format**:
- Input data (unmodified)

**Gas Cost**: 15 gas + 3 gas per input word (rounded up)

**Implementation**:

```rust
pub struct Identity;

impl Precompile for Identity {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Calculate gas cost: 15 + 3 * (input_len / 32)
        // Round up the division
        let words = (input.len() + 31) / 32;
        Ok(15 + 3 * words as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Return input unchanged
        Ok((PrecompileOutput {
            output: Bytes::from(input.to_vec()),
            logs: Vec::new(),
        }, gas))
    }
}
```

### 5. MODEXP (0x05)

Performs arbitrary precision modular exponentiation.

**Input Format**:
- Bytes 0-31: Length of base (B) in bytes
- Bytes 32-63: Length of exponent (E) in bytes
- Bytes 64-95: Length of modulus (M) in bytes
- Bytes 96+: Base (B), exponent (E), and modulus (M) concatenated

**Output Format**:
- Modular exponentiation result (B^E mod M), left-padded with zeros to the same length as M

**Gas Cost**: Complex calculation based on input sizes and values (see EIP-198 and EIP-2565)

**Implementation**:

```rust
pub struct ModExp;

impl Precompile for ModExp {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Ensure input is at least 96 bytes
        if input.len() < 96 {
            return Ok(200); // Minimum gas cost
        }
        
        // Extract lengths
        let base_len = U256::from_big_endian(&input[0..32]).as_usize();
        let exp_len = U256::from_big_endian(&input[32..64]).as_usize();
        let mod_len = U256::from_big_endian(&input[64..96]).as_usize();
        
        // Calculate gas cost according to EIP-2565
        self.calculate_gas_cost(base_len, exp_len, mod_len, input)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Ensure input is at least 96 bytes
        if input.len() < 96 {
            // Return empty result for invalid input
            return Ok((PrecompileOutput {
                output: Bytes::default(),
                logs: Vec::new(),
            }, gas));
        }
        
        // Extract lengths
        let base_len = U256::from_big_endian(&input[0..32]).as_usize();
        let exp_len = U256::from_big_endian(&input[32..64]).as_usize();
        let mod_len = U256::from_big_endian(&input[64..96]).as_usize();
        
        // Calculate expected input length
        let expected_len = 96 + base_len + exp_len + mod_len;
        if input.len() < expected_len {
            // Pad input if necessary
            let mut padded_input = vec![0; expected_len];
            padded_input[..input.len()].copy_from_slice(input);
            
            return self.modexp(&padded_input, base_len, exp_len, mod_len, gas);
        }
        
        self.modexp(input, base_len, exp_len, mod_len, gas)
    }
}

impl ModExp {
    fn calculate_gas_cost(&self, base_len: usize, exp_len: usize, mod_len: usize, input: &[u8]) -> Result<u64, PrecompileError> {
        // Implementation of EIP-2565 gas cost calculation
        // ...
    }
    
    fn modexp(&self, input: &[u8], base_len: usize, exp_len: usize, mod_len: usize, gas: u64) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Extract base, exponent, and modulus
        let base_start = 96;
        let exp_start = base_start + base_len;
        let mod_start = exp_start + exp_len;
        
        // Special cases for empty inputs
        if base_len == 0 && mod_len == 0 {
            return Ok((PrecompileOutput {
                output: Bytes::default(),
                logs: Vec::new(),
            }, gas));
        }
        
        if mod_len == 0 {
            return Ok((PrecompileOutput {
                output: Bytes::default(),
                logs: Vec::new(),
            }, gas));
        }
        
        // Handle the case where base or exponent is zero
        if base_len == 0 || (exp_len == 0 || (exp_len == 1 && input[exp_start] == 0)) {
            let mut result = vec![0; mod_len];
            if mod_len > 0 {
                result[mod_len - 1] = 1;
            }
            return Ok((PrecompileOutput {
                output: Bytes::from(result),
                logs: Vec::new(),
            }, gas));
        }
        
        // Convert inputs to BigUint
        let base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);
        let exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);
        let modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);
        
        // Special case for modulus = 1
        if modulus.is_one() {
            return Ok((PrecompileOutput {
                output: Bytes::from(vec![0; mod_len]),
                logs: Vec::new(),
            }, gas));
        }
        
        // Perform modular exponentiation
        let result = base.modpow(&exponent, &modulus);
        
        // Convert result to bytes and pad
        let result_bytes = result.to_bytes_be();
        let mut padded_result = vec![0; mod_len];
        
        if !result_bytes.is_empty() {
            let offset = mod_len.saturating_sub(result_bytes.len());
            padded_result[offset..].copy_from_slice(&result_bytes);
        }
        
        Ok((PrecompileOutput {
            output: Bytes::from(padded_result),
            logs: Vec::new(),
        }, gas))
    }
}
```

### 6. ECADD (0x06)

Performs elliptic curve addition on the alt_bn128 curve.

**Input Format**:
- Bytes 0-63: First point (x1, y1) - two 32-byte values
- Bytes 64-127: Second point (x2, y2) - two 32-byte values

**Output Format**:
- Bytes 0-63: Result point (x, y) - two 32-byte values

**Gas Cost**: 
- Before Istanbul: 500 gas
- Istanbul and later: 150 gas

**Implementation**:

```rust
pub struct ECAdd;

impl Precompile for ECAdd {
    fn required_gas(&self, _input: &[u8]) -> Result<u64, PrecompileError> {
        Ok(150) // Cost after Istanbul
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Ensure input is at least 128 bytes
        if input.len() < 128 {
            // If input is less than 128 bytes, pad with zeros
            let mut padded_input = vec![0; 128];
            padded_input[..input.len()].copy_from_slice(input);
            
            return self.ec_add(&padded_input);
        }
        
        self.ec_add(input)
    }
}

impl ECAdd {
    fn ec_add(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Extract coordinates
        let x1 = U256::from_big_endian(&input[0..32]);
        let y1 = U256::from_big_endian(&input[32..64]);
        let x2 = U256::from_big_endian(&input[64..96]);
        let y2 = U256::from_big_endian(&input[96..128]);
        
        // Convert to curve points
        let p1 = match bn::G1::from_xy(x1, y1) {
            Some(p) => p,
            None => return Err(PrecompileError::InvalidInput),
        };
        
        let p2 = match bn::G1::from_xy(x2, y2) {
            Some(p) => p,
            None => return Err(PrecompileError::InvalidInput),
        };
        
        // Perform addition
        let result = p1.add(&p2);
        
        // Convert result to bytes
        let (x, y) = result.into_xy();
        
        let mut output = vec![0; 64];
        x.to_big_endian(&mut output[0..32]);
        y.to_big_endian(&mut output[32..64]);
        
        Ok((PrecompileOutput {
            output: Bytes::from(output),
            logs: Vec::new(),
        }, 150))
    }
}
```

### 7. ECMUL (0x07)

Performs elliptic curve scalar multiplication on the alt_bn128 curve.

**Input Format**:
- Bytes 0-63: Point (x, y) - two 32-byte values
- Bytes 64-95: Scalar - 32-byte value

**Output Format**:
- Bytes 0-63: Result point (x, y) - two 32-byte values

**Gas Cost**: 
- Before Istanbul: 40,000 gas
- Istanbul and later: 6,000 gas

**Implementation**:

```rust
pub struct ECMul;

impl Precompile for ECMul {
    fn required_gas(&self, _input: &[u8]) -> Result<u64, PrecompileError> {
        Ok(6000) // Cost after Istanbul
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Ensure input is at least 96 bytes
        if input.len() < 96 {
            // If input is less than 96 bytes, pad with zeros
            let mut padded_input = vec![0; 96];
            padded_input[..input.len()].copy_from_slice(input);
            
            return self.ec_mul(&padded_input);
        }
        
        self.ec_mul(input)
    }
}

impl ECMul {
    fn ec_mul(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Extract coordinates and scalar
        let x = U256::from_big_endian(&input[0..32]);
        let y = U256::from_big_endian(&input[32..64]);
        let scalar = U256::from_big_endian(&input[64..96]);
        
        // Convert to curve point
        let point = match bn::G1::from_xy(x, y) {
            Some(p) => p,
            None => return Err(PrecompileError::InvalidInput),
        };
        
        // Perform scalar multiplication
        let result = point.mul(&scalar);
        
        // Convert result to bytes
        let (x, y) = result.into_xy();
        
        let mut output = vec![0; 64];
        x.to_big_endian(&mut output[0..32]);
        y.to_big_endian(&mut output[32..64]);
        
        Ok((PrecompileOutput {
            output: Bytes::from(output),
            logs: Vec::new(),
        }, 6000))
    }
}
```

### 8. ECPAIRING (0x08)

Performs a pairing check on the alt_bn128 curve.

**Input Format**:
- Multiple pairs of points, each consisting of:
  - G1 point (x, y) - two 32-byte values
  - G2 point (x_i, x_r, y_i, y_r) - four 32-byte values

**Output Format**:
- 32-byte value: 1 if pairing check succeeds, 0 otherwise

**Gas Cost**: 
- Before Istanbul: 100,000 gas + 80,000 gas per pair
- Istanbul and later: 45,000 gas + 34,000 gas per pair

**Implementation**:

```rust
pub struct ECPairing;

impl Precompile for ECPairing {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Calculate number of pairs
        let num_pairs = input.len() / 192;
        
        // Calculate gas cost: 45,000 + 34,000 * num_pairs
        Ok(45000 + 34000 * num_pairs as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Validate input length
        if input.len() % 192 != 0 {
            return Err(PrecompileError::InvalidInput);
        }
        
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Check base case: empty input
        if input.is_empty() {
            // Empty input is valid (no pairs to check)
            let mut output = [0u8; 32];
            output[31] = 1; // true
            
            return Ok((PrecompileOutput {
                output: Bytes::from(output.to_vec()),
                logs: Vec::new(),
            }, gas));
        }
        
        self.ec_pairing(input, gas)
    }
}

impl ECPairing {
    fn ec_pairing(&self, input: &[u8], gas: u64) -> Result<(PrecompileOutput, u64), PrecompileError> {
        let num_pairs = input.len() / 192;
        
        // Parse input points
        let mut pairs = Vec::with_capacity(num_pairs);
        
        for i in 0..num_pairs {
            let offset = i * 192;
            
            // Parse G1 point
            let ax = U256::from_big_endian(&input[offset..offset + 32]);
            let ay = U256::from_big_endian(&input[offset + 32..offset + 64]);
            
            // Parse G2 point
            let bx_re = U256::from_big_endian(&input[offset + 64..offset + 96]);
            let bx_im = U256::from_big_endian(&input[offset + 96..offset + 128]);
            let by_re = U256::from_big_endian(&input[offset + 128..offset + 160]);
            let by_im = U256::from_big_endian(&input[offset + 160..offset + 192]);
            
            // Convert to curve points
            let a = match bn::G1::from_xy(ax, ay) {
                Some(p) => p,
                None => return Err(PrecompileError::InvalidInput),
            };
            
            let b = match bn::G2::from_xy((bx_re, bx_im), (by_re, by_im)) {
                Some(p) => p,
                None => return Err(PrecompileError::InvalidInput),
            };
            
            pairs.push((a, b));
        }
        
        // Perform pairing check
        let result = bn::pairing_batch(&pairs);
        
        // Prepare output
        let mut output = [0u8; 32];
        if result {
            output[31] = 1; // true
        }
        
        Ok((PrecompileOutput {
            output: Bytes::from(output.to_vec()),
            logs: Vec::new(),
        }, gas))
    }
}
```

### 9. BLAKE2F (0x09)

Performs the BLAKE2 F compression function.

**Input Format**:
- Bytes 0-3: Rounds (32-bit integer)
- Bytes 4-67: H (8 8-byte words)
- Bytes 68-131: M (16 4-byte words)
- Bytes 132-147: T (2 8-byte words)
- Byte 148: F (boolean flag)

**Output Format**:
- Bytes 0-63: Result (8 8-byte words)

**Gas Cost**: 1 gas per round

**Implementation**:

```rust
pub struct Blake2F;

impl Precompile for Blake2F {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        if input.len() != 213 {
            return Err(PrecompileError::InvalidInput);
        }
        
        // Read rounds from first 4 bytes
        let rounds = u32::from_be_bytes([input[0], input[1], input[2], input[3]]) as u64;
        
        // Gas cost is 1 per round
        Ok(rounds)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Validate input length
        if input.len() != 213 {
            return Err(PrecompileError::InvalidInput);
        }
        
        // Read rounds
        let rounds = u32::from_be_bytes([input[0], input[1], input[2], input[3]]);
        
        // Calculate required gas
        let gas = rounds as u64;
        
        // Extract state vectors
        let mut h = [0u64; 8];
        let mut m = [0u32; 16];
        let mut t = [0u64; 2];
        
        // Read h
        for i in 0..8 {
            let offset = 4 + i * 8;
            h[i] = u64::from_le_bytes([
                input[offset],
                input[offset + 1],
                input[offset + 2],
                input[offset + 3],
                input[offset + 4],
                input[offset + 5],
                input[offset + 6],
                input[offset + 7],
            ]);
        }
        
        // Read m
        for i in 0..16 {
            let offset = 68 + i * 4;
            m[i] = u32::from_le_bytes([
                input[offset],
                input[offset + 1],
                input[offset + 2],
                input[offset + 3],
            ]);
        }
        
        // Read t
        for i in 0..2 {
            let offset = 132 + i * 8;
            t[i] = u64::from_le_bytes([
                input[offset],
                input[offset + 1],
                input[offset + 2],
                input[offset + 3],
                input[offset + 4],
                input[offset + 5],
                input[offset + 6],
                input[offset + 7],
            ]);
        }
        
        // Read f
        let f = input[148] != 0;
        
        // Perform BLAKE2 F compression
        blake2_f(rounds, &mut h, m, t, f);
        
        // Prepare output
        let mut output = vec![0u8; 64];
        for i in 0..8 {
            let bytes = h[i].to_le_bytes();
            let offset = i * 8;
            output[offset..offset + 8].copy_from_slice(&bytes);
        }
        
        Ok((PrecompileOutput {
            output: Bytes::from(output),
            logs: Vec::new(),
        }, gas))
    }
}

fn blake2_f(rounds: u32, h: &mut [u64; 8], m: [u32; 16], t: [u64; 2], f: bool) {
    // Implementation of BLAKE2 F compression function
    // ...
}
```

## Precompile Manager

REVM manages precompiled contracts through a `PrecompileManager` that maps addresses to implementations:

```rust
pub struct PrecompileManager {
    precompiles: HashMap<Address, Box<dyn Precompile>>,
}

impl PrecompileManager {
    pub fn new() -> Self {
        let mut precompiles = HashMap::new();
        
        // Add standard precompiles
        precompiles.insert(address!("0x0000000000000000000000000000000000000001"), Box::new(ECRecover));
        precompiles.insert(address!("0x0000000000000000000000000000000000000002"), Box::new(SHA256));
        precompiles.insert(address!("0x0000000000000000000000000000000000000003"), Box::new(RIPEMD160));
        precompiles.insert(address!("0x0000000000000000000000000000000000000004"), Box::new(Identity));
        precompiles.insert(address!("0x0000000000000000000000000000000000000005"), Box::new(ModExp));
        precompiles.insert(address!("0x0000000000000000000000000000000000000006"), Box::new(ECAdd));
        precompiles.insert(address!("0x0000000000000000000000000000000000000007"), Box::new(ECMul));
        precompiles.insert(address!("0x0000000000000000000000000000000000000008"), Box::new(ECPairing));
        precompiles.insert(address!("0x0000000000000000000000000000000000000009"), Box::new(Blake2F));
        
        Self { precompiles }
    }
    
    pub fn insert(&mut self, address: Address, precompile: Box<dyn Precompile>) {
        self.precompiles.insert(address, precompile);
    }
    
    pub fn remove(&mut self, address: &Address) {
        self.precompiles.remove(address);
    }
    
    pub fn contains(&self, address: &Address) -> bool {
        self.precompiles.contains_key(address)
    }
    
    pub fn execute(
        &self,
        address: &Address,
        input: &[u8],
        gas_limit: u64,
    ) -> Result<(Bytes, u64), PrecompileError> {
        if let Some(precompile) = self.precompiles.get(address) {
            // Check gas
            let required_gas = precompile.required_gas(input)?;
            if required_gas > gas_limit {
                return Err(PrecompileError::OutOfGas);
            }
            
            // Execute precompile
            let (output, gas_used) = precompile.run(input)?;
            
            Ok((output.output, gas_used))
        } else {
            Err(PrecompileError::Error("Precompile not found".to_string()))
        }
    }
}
```

## Custom Precompile Implementation

To implement a custom precompile in REVM, you need to:

1. Create a struct implementing the `Precompile` trait
2. Register it with the `PrecompileManager`

Here's an example of a custom precompile that performs string concatenation:

```rust
pub struct StringConcat;

impl Precompile for StringConcat {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Calculate gas cost: 100 + 3 * (input_len / 32)
        let words = (input.len() + 31) / 32;
        Ok(100 + 3 * words as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Calculate required gas
        let gas = self.required_gas(input)?;
        
        // Parse input: format is (offset1, length1, offset2, length2)
        if input.len() < 128 {
            return Err(PrecompileError::InvalidInput);
        }
        
        let offset1 = U256::from_big_endian(&input[0..32]).as_usize();
        let length1 = U256::from_big_endian(&input[32..64]).as_usize();
        let offset2 = U256::from_big_endian(&input[64..96]).as_usize();
        let length2 = U256::from_big_endian(&input[96..128]).as_usize();
        
        // Validate offsets and lengths
        if offset1 + length1 > input.len() || offset2 + length2 > input.len() {
            return Err(PrecompileError::InvalidInput);
        }
        
        // Extract and concatenate strings
        let string1 = &input[offset1..offset1 + length1];
        let string2 = &input[offset2..offset2 + length2];
        
        // Concatenate
        let mut result = Vec::with_capacity(length1 + length2);
        result.extend_from_slice(string1);
        result.extend_from_slice(string2);
        
        Ok((PrecompileOutput {
            output: Bytes::from(result),
            logs: Vec::new(),
        }, gas))
    }
}

// Register the custom precompile
fn register_custom_precompiles(evm: &mut Evm) {
    let mut precompile_manager = PrecompileManager::new();
    
    // Add custom precompile at address 0x100
    precompile_manager.insert(
        address!("0x0000000000000000000000000000000000000100"),
        Box::new(StringConcat)
    );
    
    evm.precompiles = precompile_manager;
}
```

## Function-Based Precompiles

For simple precompiles, REVM provides a function-based approach using the `PrecompileFn` type:

```rust
pub type PrecompileFn = fn(input: &[u8], gas_limit: u64) -> Result<(Vec<u8>, u64), PrecompileError>;

// Example of a function-based precompile
fn add_numbers(input: &[u8], gas_limit: u64) -> Result<(Vec<u8>, u64), PrecompileError> {
    // Require at least 64 bytes (two 32-byte numbers)
    if input.len() < 64 {
        return Err(PrecompileError::InvalidInput);
    }
    
    // Fixed gas cost
    let gas_cost = 50;
    
    // Check gas limit
    if gas_cost > gas_limit {
        return Err(PrecompileError::OutOfGas);
    }
    
    // Parse the numbers
    let a = U256::from_big_endian(&input[0..32]);
    let b = U256::from_big_endian(&input[32..64]);
    
    // Perform addition
    let result = a.overflowing_add(b).0;
    
    // Convert result to bytes
    let mut output = vec![0u8; 32];
    result.to_big_endian(&mut output);
    
    Ok((output, gas_cost))
}

// Register the function-based precompile
let mut precompile_manager = PrecompileManager::new();
precompile_manager.register_function(
    address!("0x0000000000000000000000000000000000000101"),
    add_numbers
);
```

REVM wraps function-based precompiles in a `FunctionPrecompile` struct that implements the `Precompile` trait.

## Gas Cost Calculation

Gas cost calculation for precompiles is critical for security and proper incentivization. Here are some principles for designing gas costs:

1. **Computational Complexity**: Base gas costs on the computational complexity of the operation.
2. **Memory Usage**: Account for memory usage and storage.
3. **Consistency**: Maintain consistent pricing with similar EVM operations.
4. **Linear Scaling**: Scale gas costs linearly with input size when appropriate.
5. **Worst-Case Protection**: Price for worst-case scenarios to prevent DoS attacks.

### Examples of Gas Cost Calculations

**Linear Scaling (SHA256)**:
```rust
fn sha256_gas(input: &[u8]) -> u64 {
    // Base cost + cost per 32-byte word
    let words = (input.len() + 31) / 32;
    60 + 12 * words as u64
}
```

**Quadratic Scaling (ECPAIRING)**:
```rust
fn ecpairing_gas(input: &[u8]) -> u64 {
    // Base cost + cost per pair
    let pairs = input.len() / 192;
    45000 + 34000 * pairs as u64
}
```

**Complex Scaling (MODEXP)**:
```rust
fn modexp_gas(base_len: usize, exp_len: usize, mod_len: usize, input: &[u8]) -> u64 {
    // Implementation of EIP-2565 gas cost formula
    // ...
    
    // Simplified formula:
    let exp_bytes = min(32, exp_len);
    let exp_value = if exp_len == 0 {
        0
    } else {
        let exp_offset = 96 + base_len;
        let end = min(exp_offset + exp_bytes, input.len());
        if exp_offset >= end {
            0
        } else {
            U256::from_big_endian(&input[exp_offset..end]).as_u64()
        }
    };
    
    let msb = if exp_value == 0 { 0 } else { 64 - exp_value.leading_zeros() };
    let words = (max(mod_len, base_len) + 31) / 32;
    
    let iterations = words * max(msb, 1) as usize * max(1, exp_len - 32) / 32;
    let gas = iterations * 3;
    
    max(200, gas)
}
```

## Custom Precompile Use Cases

### 1. Specialized Cryptography

Implementing specialized cryptographic operations like zkSNARK verification:

```rust
pub struct ZkSnarkVerify;

impl Precompile for ZkSnarkVerify {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Gas cost based on the complexity of the circuit
        let circuit_size = U256::from_big_endian(&input[0..32]).as_usize();
        Ok(100000 + 1000 * circuit_size as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Parse proof and verification key
        // ...
        
        // Verify the proof
        let is_valid = verify_zksnark_proof(proof, vk, public_inputs);
        
        // Return result (1 for valid, 0 for invalid)
        let mut output = [0u8; 32];
        if is_valid {
            output[31] = 1;
        }
        
        Ok((PrecompileOutput {
            output: Bytes::from(output.to_vec()),
            logs: Vec::new(),
        }, self.required_gas(input)?))
    }
}
```

### 2. Database Interactions

Providing access to an off-chain database:

```rust
pub struct DatabaseLookup {
    db_client: DatabaseClient,
}

impl Precompile for DatabaseLookup {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        // Fixed cost plus additional cost per byte of key
        let key_len = min(32, input.len());
        Ok(10000 + 100 * key_len as u64)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Parse key
        let key = if input.len() >= 32 {
            U256::from_big_endian(&input[0..32])
        } else {
            let mut padded = [0u8; 32];
            padded[32 - input.len()..].copy_from_slice(input);
            U256::from_big_endian(&padded)
        };
        
        // Look up value in database
        let value = match self.db_client.get(&key.to_string()) {
            Some(v) => v,
            None => return Ok((PrecompileOutput {
                output: Bytes::default(),
                logs: Vec::new(),
            }, self.required_gas(input)?)),
        };
        
        // Convert to U256 and then to bytes
        let result = U256::from_dec_str(&value)
            .map_err(|_| PrecompileError::Error("Invalid database value".to_string()))?;
        
        let mut output = [0u8; 32];
        result.to_big_endian(&mut output);
        
        Ok((PrecompileOutput {
            output: Bytes::from(output.to_vec()),
            logs: Vec::new(),
        }, self.required_gas(input)?))
    }
}
```

### 3. Oracle Functionality

Implementing an oracle for external data:

```rust
pub struct PriceOracle {
    price_data: RwLock<HashMap<String, U256>>,
    last_update: RwLock<u64>,
}

impl Precompile for PriceOracle {
    fn required_gas(&self, _input: &[u8]) -> Result<u64, PrecompileError> {
        // Fixed cost for oracle access
        Ok(5000)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Parse asset symbol (assuming ASCII)
        if input.len() < 3 || input.len() > 8 {
            return Err(PrecompileError::InvalidInput);
        }
        
        let symbol = match String::from_utf8(input.to_vec()) {
            Ok(s) => s.to_uppercase(),
            Err(_) => return Err(PrecompileError::InvalidInput),
        };
        
        // Check if price data is fresh
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let last_update = *self.last_update.read().unwrap();
        if current_time - last_update > 3600 {
            // Update price data if stale (older than 1 hour)
            self.update_price_data()?;
        }
        
        // Look up price
        let price_data = self.price_data.read().unwrap();
        let price = match price_data.get(&symbol) {
            Some(p) => *p,
            None => return Err(PrecompileError::Error(format!("Unknown asset: {}", symbol))),
        };
        
        // Convert price to bytes
        let mut output = [0u8; 32];
        price.to_big_endian(&mut output);
        
        Ok((PrecompileOutput {
            output: Bytes::from(output.to_vec()),
            logs: Vec::new(),
        }, self.required_gas(input)?))
    }
}

impl PriceOracle {
    fn update_price_data(&self) -> Result<(), PrecompileError> {
        // Fetch price data from an external API
        // ...
        
        // Update price data and timestamp
        let mut price_data = self.price_data.write().unwrap();
        let mut last_update = self.last_update.write().unwrap();
        
        // Update with new data
        price_data.insert("BTC".to_string(), U256::from(50000) * U256::from(10).pow(U256::from(18)));
        price_data.insert("ETH".to_string(), U256::from(3000) * U256::from(10).pow(U256::from(18)));
        // ...
        
        *last_update = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        Ok(())
    }
}
```

## Best Practices

### 1. Gas Calculation

- Base gas costs on actual computational complexity
- Include a minimum gas cost to prevent DoS attacks
- Scale gas costs appropriately with input size
- Test with extreme inputs to ensure proper gas scaling
- Consider the worst-case scenario for variable-input operations

```rust
fn calculate_gas(&self, input: &[u8]) -> u64 {
    // Start with a base cost
    let mut gas = 100;
    
    // Add cost based on input size
    let input_words = (input.len() + 31) / 32;
    gas += 10 * input_words as u64;
    
    // Add cost for computational complexity
    // ...
    
    // Ensure minimum gas cost
    gas.max(100)
}
```

### 2. Input Validation

- Always check input length and format
- Validate parameters before processing
- Provide clear error messages for invalid inputs
- Consider padding short inputs rather than failing

```rust
fn validate_input(&self, input: &[u8]) -> Result<(), PrecompileError> {
    // Check minimum length
    if input.len() < 32 {
        return Err(PrecompileError::InvalidInput);
    }
    
    // Parse key parameters
    let param1 = U256::from_big_endian(&input[0..32]);
    
    // Validate values
    if param1 == U256::ZERO {
        return Err(PrecompileError::Error("Parameter 1 cannot be zero".to_string()));
    }
    
    Ok(())
}
```

### 3. Error Handling

- Use appropriate error types for different failure modes
- Distinguish between gas errors, input errors, and execution errors
- Provide meaningful error messages for debugging
- Handle edge cases gracefully

```rust
enum MyPrecompileError {
    OutOfGas,
    InvalidInput(String),
    ExecutionFailed(String),
}

impl From<MyPrecompileError> for PrecompileError {
    fn from(err: MyPrecompileError) -> Self {
        match err {
            MyPrecompileError::OutOfGas => PrecompileError::OutOfGas,
            MyPrecompileError::InvalidInput(msg) => 
                PrecompileError::Error(format!("Invalid input: {}", msg)),
            MyPrecompileError::ExecutionFailed(msg) => 
                PrecompileError::Error(format!("Execution failed: {}", msg)),
        }
    }
}
```

### 4. Performance Optimization

- Use efficient algorithms for cryptographic operations
- Avoid unnecessary memory allocation
- Consider using cached results for deterministic operations
- Optimize for common input patterns

```rust
// Example of caching results
pub struct CachingPrecompile<P: Precompile> {
    inner: P,
    cache: Mutex<LruCache<Vec<u8>, (Bytes, u64)>>,
}

impl<P: Precompile> Precompile for CachingPrecompile<P> {
    fn required_gas(&self, input: &[u8]) -> Result<u64, PrecompileError> {
        self.inner.required_gas(input)
    }
    
    fn run(&self, input: &[u8]) -> Result<(PrecompileOutput, u64), PrecompileError> {
        // Check cache
        let mut cache = self.cache.lock().unwrap();
        if let Some((output, gas)) = cache.get(&input.to_vec()) {
            return Ok((PrecompileOutput {
                output: output.clone(),
                logs: Vec::new(),
            }, *gas));
        }
        
        // Run the inner precompile
        let (output, gas) = self.inner.run(input)?;
        
        // Cache the result
        cache.put(input.to_vec(), (output.output.clone(), gas));
        
        Ok((output, gas))
    }
}
```

### 5. Security Considerations

- Protect against denial-of-service attacks
- Validate all inputs carefully
- Consider the potential for malicious inputs
- Test with edge cases and fuzzing
- Audit cryptographic implementations for correctness

```rust
// Protect against excessive memory usage
fn validate_memory_usage(&self, input: &[u8]) -> Result<(), PrecompileError> {
    // Parse allocation size
    let size = U256::from_big_endian(&input[0..32]).as_usize();
    
    // Limit to reasonable size to prevent DoS
    if size > 10 * 1024 * 1024 {
        return Err(PrecompileError::Error("Requested allocation too large".to_string()));
    }
    
    Ok(())
}
```

## Conclusion

Precompiled contracts are a powerful mechanism for extending the EVM with native functionality. REVM provides a flexible and extensible framework for implementing both standard Ethereum precompiles and custom functionality.

When implementing custom precompiles, follow these key principles:

1. Implement the `Precompile` trait correctly
2. Calculate gas costs fairly and securely
3. Validate inputs carefully
4. Handle errors gracefully
5. Optimize for performance
6. Consider security implications

By understanding the details of precompiled contracts, you can leverage REVM to build advanced Ethereum applications that go beyond the capabilities of standard smart contracts.