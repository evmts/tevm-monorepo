# Basic Transaction Execution

This tutorial covers how to execute Ethereum transactions using REVM. You'll learn how to set up different types of transactions, execute them, and interpret the results.

## Understanding Ethereum Transactions

Before diving into REVM-specific details, let's briefly review what an Ethereum transaction is:

An Ethereum transaction is a signed data package that contains:

- **Sender (From)**: The address initiating the transaction
- **Recipient (To)**: The address receiving the transaction (or `null` for contract creation)
- **Value**: Amount of Ether to transfer
- **Data**: Input data for contract calls or contract creation bytecode
- **Gas Limit**: Maximum amount of gas allowed for execution
- **Gas Price**: Price per unit of gas the sender is willing to pay
- **Nonce**: Sender's transaction count (prevents replay attacks)

Transactions can be:
- **Value Transfers**: Simple Ether transfers between accounts
- **Contract Calls**: Executions of functions on existing contracts
- **Contract Creations**: Deployments of new smart contracts

## Setting Up the EVM for Transaction Execution

To execute a transaction with REVM, you need to:

1. Create a suitable execution environment
2. Configure the transaction parameters
3. Execute the transaction
4. Process the results

Let's walk through these steps one by one.

### 1. Creating an Execution Environment

First, set up your project by adding REVM as a dependency as described in the [Getting Started](./1.2-getting-started.md) guide.

Then, create an execution environment with a state database. For this tutorial, we'll use an in-memory database:

```rust
use revm::{
    context::Context,
    db::{CacheDB, EmptyDB},
    primitives::{address, Account, AccountInfo, Bytecode, TxKind, U256},
    ExecuteEvm, MainBuilder, MainContext,
};

fn main() {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Create a context with the database
    let mut ctx = Context::mainnet().with_db(db);
    
    // Now we can configure and execute transactions...
}
```

### 2. Initializing Account State

Before executing transactions, we need to set up some initial state (accounts with balances):

```rust
// Define addresses
let sender = address!("0x1000000000000000000000000000000000000000");
let recipient = address!("0x2000000000000000000000000000000000000000");

// Create an account with balance for the sender
let sender_account = AccountInfo {
    nonce: 0,
    balance: U256::from(10000000000000000000u64), // 10 ETH
    code_hash: Default::default(),
    code: None,
};

// Insert the account into the database
ctx.db_mut().insert_account_info(sender, sender_account);

// Complete the context building
let mut evm = ctx.build_mainnet();
```

### 3. Configuring a Simple Value Transfer Transaction

Now, let's configure a simple Ether transfer transaction:

```rust
// Configure the transaction
evm.modify_tx(|tx| {
    tx.caller = sender;
    tx.kind = TxKind::Call(recipient);
    tx.value = U256::from(1000000000000000000u64); // 1 ETH
    tx.gas_limit = 21000; // Standard gas limit for transfers
    tx.gas_price = U256::from(1000000000u64); // 1 Gwei
    tx.nonce = 0;
});
```

### 4. Executing the Transaction

With the environment and transaction set up, we can execute the transaction:

```rust
// Execute the transaction
match evm.transact() {
    Ok(result) => {
        println!("Transaction successful!");
        println!("Gas used: {}", result.result.gas_used());
        
        // Print state changes
        println!("\nState changes:");
        for (address, account) in result.state.iter() {
            println!("Address: {}", address);
            if let Some(balance_change) = account.balance_changed() {
                println!("  Balance change: {}", balance_change);
            }
        }
    },
    Err(error) => println!("Transaction failed: {:?}", error),
}
```

### Complete Example: Simple Value Transfer

Here's a complete example of executing a simple value transfer:

```rust
use revm::{
    context::Context,
    database::{CacheDB, EmptyDB},
    primitives::{address, AccountInfo, TxKind, U256, KECCAK_EMPTY},
    ExecuteEvm, MainBuilder, MainContext,
};

fn main() {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Define addresses
    let sender = address!("0x1000000000000000000000000000000000000000");
    let recipient = address!("0x2000000000000000000000000000000000000000");
    
    // Create an account with balance for the sender
    let sender_account = AccountInfo {
        nonce: 0,
        balance: U256::from(10000000000000000000u64), // 10 ETH
        code_hash: KECCAK_EMPTY,
        code: None,
    };
    
    // Insert the account into the database
    db.insert_account_info(sender, sender_account);
    
    // Create a context and EVM instance
    let mut evm = Context::mainnet()
        .with_db(db)
        .modify_tx_chained(|tx| {
            tx.caller = sender;
            tx.kind = TxKind::Call(recipient);
            tx.value = U256::from(1000000000000000000u64); // 1 ETH
            tx.gas_limit = 21000; // Standard gas limit for transfers
            tx.gas_price = U256::from(1000000000u64); // 1 Gwei
            tx.nonce = 0;
        })
        .build_mainnet();
    
    // Execute the transaction
    match evm.transact() {
        Ok(result) => {
            println!("Transaction successful!");
            println!("Gas used: {}", result.result.gas_used());
            
            // Print state changes
            println!("\nState changes:");
            for (address, account) in result.state.iter() {
                println!("Address: {}", address);
                if let Some(balance_change) = account.balance_changed() {
                    println!("  Balance change: {}", balance_change);
                }
            }
        },
        Err(error) => println!("Transaction failed: {:?}", error),
    }
}
```

When you run this example, you should see output indicating a successful transaction with state changes showing the balance transfers.

## Contract Interaction

Now let's look at how to interact with a contract. For this, we need:

1. A deployed contract with code
2. A transaction with the appropriate call data

### Setting Up a Simple Contract

First, let's create a simple contract in our database:

```rust
use revm::{
    context::Context, 
    database::{CacheDB, EmptyDB},
    primitives::{address, hex, AccountInfo, Bytecode, TxKind, U256, KECCAK_EMPTY},
    ExecuteEvm, MainBuilder, MainContext,
};
use std::str::FromStr;

fn main() {
    // Create an in-memory database
    let mut db = CacheDB::new(EmptyDB::default());
    
    // Define addresses
    let sender = address!("0x1000000000000000000000000000000000000000");
    let contract_addr = address!("0x3000000000000000000000000000000000000000");
    
    // Create an account with balance for the sender
    let sender_account = AccountInfo {
        nonce: 0,
        balance: U256::from(10000000000000000000u64), // 10 ETH
        code_hash: KECCAK_EMPTY,
        code: None,
    };
    
    // Insert the sender account into the database
    db.insert_account_info(sender, sender_account);
    
    // Simple contract that stores a value and allows retrieving it
    // Solidity equivalent:
    // contract SimpleStorage {
    //     uint256 private _value;
    //     
    //     function setValue(uint256 value) public {
    //         _value = value;
    //     }
    //     
    //     function getValue() public view returns (uint256) {
    //         return _value;
    //     }
    // }
    let contract_code = hex::decode("608060405234801561001057600080fd5b50610150806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80633fa4f2451461003b5780635524107714610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea2646970667358221220223701d5d0d4c6cefdd5356c93a17cd1f67302f3a4f155f2578e073eadf4d55464736f6c63430008120033").expect("Failed to decode contract bytecode");
    
    // Create the contract account
    let code_hash = keccak256(&contract_code);
    let contract_account = AccountInfo {
        nonce: 1,
        balance: U256::ZERO,
        code_hash,
        code: Some(Bytecode::new_raw(contract_code.into())),
    };
    
    // Insert the contract account into the database
    db.insert_account_info(contract_addr, contract_account);
    
    // Now we can interact with this contract...
}

// Helper function to compute keccak256 hash
fn keccak256(bytes: &[u8]) -> B256 {
    revm::primitives::keccak256(bytes)
}
```

### Calling a Contract Function

Now, let's call the `setValue` function on our contract:

```rust
// ABI-encoded call to setValue(42)
// Function selector: 0x55241077
// Argument: 0x000000000000000000000000000000000000000000000000000000000000002a (42 in hex)
let call_data = hex::decode("5524107700000000000000000000000000000000000000000000000000000000000000a").expect("Failed to decode call data");

// Configure and execute the transaction
let mut evm = Context::mainnet()
    .with_db(db)
    .modify_tx_chained(|tx| {
        tx.caller = sender;
        tx.kind = TxKind::Call(contract_addr);
        tx.value = U256::ZERO;
        tx.data = call_data.into(); // Set the call data
        tx.gas_limit = 100000; // More gas for contract calls
        tx.gas_price = U256::from(1000000000u64); // 1 Gwei
        tx.nonce = 0;
    })
    .build_mainnet();

// Execute the transaction
match evm.transact() {
    Ok(result) => {
        println!("Contract call successful!");
        println!("Gas used: {}", result.result.gas_used());
        
        // Print state changes (storage updates)
        println!("\nState changes:");
        for (address, account) in result.state.iter() {
            println!("Address: {}", address);
            
            // Print storage changes
            if !account.storage.is_empty() {
                println!("  Storage changes:");
                for (slot, value) in account.storage.iter() {
                    println!("    Slot: {}, Value: {}", slot, value.present_value());
                }
            }
        }
    },
    Err(error) => println!("Contract call failed: {:?}", error),
}
```

### Reading from a Contract

Now, let's call the `getValue` function to read the value we just set:

```rust
// ABI-encoded call to getValue()
// Function selector: 0x3fa4f245
let call_data = hex::decode("3fa4f245").expect("Failed to decode call data");

// Configure and execute the transaction
let mut evm = Context::mainnet()
    .with_db(db)
    .modify_tx_chained(|tx| {
        tx.caller = sender;
        tx.kind = TxKind::Call(contract_addr);
        tx.value = U256::ZERO;
        tx.data = call_data.into(); // Set the call data
        tx.gas_limit = 100000; // More gas for contract calls
        tx.gas_price = U256::from(1000000000u64); // 1 Gwei
        tx.nonce = 1; // Increment nonce for the sender
    })
    .build_mainnet();

// Execute the transaction
match evm.transact() {
    Ok(result) => {
        println!("Contract read successful!");
        println!("Gas used: {}", result.result.gas_used());
        
        // Get the return data
        if let revm::primitives::context_interface::result::Output::Call(return_data) = &result.result.output {
            println!("\nReturn data: 0x{}", hex::encode(return_data));
            
            // Parse the return data (if it's a uint256 value)
            if return_data.len() == 32 {
                let value = U256::from_be_bytes(return_data.try_into().unwrap());
                println!("Decoded value: {}", value);
            }
        }
    },
    Err(error) => println!("Contract read failed: {:?}", error),
}
```

## Understanding Transaction Results

When you execute a transaction with REVM, it returns a `ResultAndState` struct containing:

1. **Result**: The execution result, which includes:
   - **Gas used**: Amount of gas consumed by the transaction
   - **Gas refunded**: Amount of gas refunded (e.g., from storage freeing)
   - **Output**: The transaction output (either a return value or contract address)
   - **Logs**: Event logs emitted during execution

2. **State**: The state changes that occurred during execution:
   - **Account balance changes**
   - **Account nonce changes**
   - **Storage modifications**
   - **Code deployments**

### Interpreting Different Transaction Types

Here's how to interpret results for different transaction types:

#### Value Transfer

For simple value transfers, check:
- **Gas used**: Should be exactly 21,000 (the base cost of a transaction)
- **State changes**: Balance decreases for sender, increases for recipient
- **Output**: Will be empty for a simple transfer

```rust
if let Ok(result) = evm.transact() {
    println!("Gas used: {}", result.result.gas_used());
    
    // Check balance changes
    for (address, account) in result.state.iter() {
        if let Some(balance_change) = account.balance_changed() {
            println!("Address: {}, Balance change: {}", address, balance_change);
        }
    }
}
```

#### Contract Call

For contract calls, check:
- **Gas used**: Will vary based on executed code
- **Output**: Contains the return data (if any)
- **State changes**: May include storage modifications

```rust
if let Ok(result) = evm.transact() {
    println!("Gas used: {}", result.result.gas_used());
    
    // Get the return data
    if let revm::primitives::context_interface::result::Output::Call(return_data) = &result.result.output {
        println!("Return data: 0x{}", hex::encode(return_data));
    }
    
    // Check storage changes
    for (address, account) in result.state.iter() {
        if !account.storage.is_empty() {
            println!("Storage changes for {}", address);
            for (slot, value) in account.storage.iter() {
                println!("  Slot: {}, Value: {}", slot, value.present_value());
            }
        }
    }
}
```

#### Contract Creation

For contract deployments, check:
- **Gas used**: Will include code deployment costs
- **Output**: Contains the contract address if successful
- **State changes**: Will include the newly created contract

```rust
if let Ok(result) = evm.transact() {
    println!("Gas used: {}", result.result.gas_used());
    
    // Get the created contract address
    if let revm::primitives::context_interface::result::Output::Create(_, Some(address)) = &result.result.output {
        println!("Contract deployed at: {}", address);
    }
    
    // Check the deployed code
    for (address, account) in result.state.iter() {
        if account.info.code.is_some() {
            println!("Code deployed to: {}", address);
        }
    }
}
```

## Error Handling

REVM can return various errors during transaction execution:

### Common Error Types

1. **Database Errors**: Issues retrieving data from the state database
2. **Validation Errors**: Transaction validation failures (nonce, gas price, etc.)
3. **Execution Errors**: Errors during EVM code execution (out of gas, reverts, etc.)

### Handling Errors

Use pattern matching to handle different error types:

```rust
match evm.transact() {
    Ok(result) => {
        // Handle successful execution
    },
    Err(error) => match error {
        revm::primitives::context_interface::result::EVMError::Database(db_error) => {
            println!("Database error: {:?}", db_error);
        },
        revm::primitives::context_interface::result::EVMError::Transaction(tx_error) => {
            println!("Transaction error: {:?}", tx_error);
            
            match tx_error {
                revm::primitives::context_interface::result::InvalidTransaction::NonceTooLow { .. } => {
                    // Handle nonce issues
                },
                revm::primitives::context_interface::result::InvalidTransaction::LackOfFundForMaxFee { .. } => {
                    // Handle insufficient funds
                },
                // Handle other transaction errors
                _ => println!("Other transaction error"),
            }
        },
        // Handle other EVM errors
        _ => println!("Other EVM error: {:?}", error),
    },
}
```

## Gas Calculation and Management

Gas is the unit of computation in Ethereum. Understanding gas is crucial for efficient transaction execution.

### Gas Parameters

When executing a transaction, you can configure:

- **Gas Limit**: Maximum gas allowed for the transaction
- **Gas Price**: Amount of Ether per unit of gas
- **Max Fee Per Gas**: Maximum total fee per gas unit (for EIP-1559 transactions)
- **Max Priority Fee Per Gas**: Maximum tip per gas unit (for EIP-1559 transactions)

```rust
evm.modify_tx(|tx| {
    tx.gas_limit = 100000;
    tx.gas_price = U256::from(1000000000u64); // 1 Gwei
    
    // For EIP-1559 transactions
    tx.max_fee_per_gas = Some(U256::from(2000000000u64)); // 2 Gwei
    tx.max_priority_fee_per_gas = Some(U256::from(1000000000u64)); // 1 Gwei
});
```

### Gas Refunds

Some operations in the EVM can result in gas refunds, such as clearing storage. The refunded gas is included in the transaction result:

```rust
if let Ok(result) = evm.transact() {
    println!("Gas used: {}", result.result.gas_used());
    println!("Gas refunded: {}", result.result.gas_refunded());
    println!("Net gas used: {}", result.result.gas_used() - result.result.gas_refunded());
}
```

### Estimating Gas

REVM doesn't have a built-in gas estimation function, but you can implement one by trying to execute a transaction with different gas limits and checking for out-of-gas errors.

## Advanced Transaction Configuration

REVM supports various advanced transaction configurations:

### EIP-1559 Transactions

EIP-1559 introduced a new transaction pricing mechanism:

```rust
evm.modify_tx(|tx| {
    // Set base parameters
    tx.caller = sender;
    tx.kind = TxKind::Call(recipient);
    tx.value = U256::from(1000000000000000000u64); // 1 ETH
    
    // EIP-1559 specific fields
    tx.max_fee_per_gas = Some(U256::from(2000000000u64)); // 2 Gwei
    tx.max_priority_fee_per_gas = Some(U256::from(1000000000u64)); // 1 Gwei
});
```

### Access Lists

EIP-2930 introduced access lists to reduce gas costs for accessing state:

```rust
use revm::primitives::{AccessListItem, TxAccessList};

// Create an access list
let mut access_list = TxAccessList::default();

// Add an item: an address and a list of storage slots to access
access_list.push(AccessListItem {
    address: recipient,
    slots: vec![U256::ZERO, U256::ONE],
});

evm.modify_tx(|tx| {
    // Set the access list
    tx.access_list = access_list;
});
```

### Custom Gas Limits for Different Operations

Different operations require different amounts of gas:

- **Value Transfers**: 21,000 gas
- **Contract Calls**: 21,000 gas plus the cost of executed code
- **Contract Creation**: 32,000 gas plus the cost of executed code and deployed bytecode

Always set an appropriate gas limit for your transaction type:

```rust
evm.modify_tx(|tx| {
    match tx.kind {
        TxKind::Call(_) => {
            // Simple value transfer
            if tx.data.is_empty() {
                tx.gas_limit = 21000;
            } else {
                // Contract call with data
                tx.gas_limit = 100000;
            }
        },
        TxKind::Create => {
            // Contract creation
            tx.gas_limit = 1000000;
        },
    }
});
```

## Transaction Execution in Different Environments

REVM allows you to execute transactions in different environments, such as different networks or hardforks.

### Specifying Network and Hardfork

```rust
use revm::primitives::SpecId;

let mut evm = Context::mainnet()
    .modify_cfg_chained(|cfg| {
        // Set the hardfork
        cfg.spec = SpecId::CANCUN;
        
        // Set the chain ID (1 for Ethereum mainnet)
        cfg.chain_id = 1;
    })
    .build_mainnet();
```

### Executing on Testnet Configurations

```rust
let mut evm = Context::custom()
    .modify_cfg_chained(|cfg| {
        // Set to Sepolia testnet
        cfg.chain_id = 11155111;
        cfg.spec = SpecId::CANCUN;
    })
    .build_mainnet();
```

## Summary

In this tutorial, you've learned how to:

1. Set up an EVM execution environment
2. Configure and execute different types of transactions:
   - Simple value transfers
   - Contract calls
   - Contract reads
3. Understand and interpret transaction results
4. Handle errors during transaction execution
5. Manage gas for different operation types
6. Configure advanced transaction parameters

These skills provide the foundation for more complex interactions with Ethereum smart contracts, which we'll explore in the next tutorial.

## Next Steps

In the next tutorial, we'll dive deeper into smart contract deployment, including:

- Creating and deploying contracts from bytecode
- Handling contract construction arguments
- Interacting with newly deployed contracts
- Understanding deployment gas costs

Continue to [Smart Contract Deployment](./1.4-smart-contract-deployment.md) to learn more.

---

**Note:** The code examples in this tutorial are for educational purposes. In production environments, you would typically want more robust error handling, logging, and parameter validation.