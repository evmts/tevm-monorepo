# EIP-7702 Account Abstraction Implementation Issue

## Overview

eip7702.zig implements EIP-7702 set code transaction functionality, enabling EOAs (Externally Owned Accounts) to temporarily delegate their code execution to a contract address, supporting account abstraction use cases.

## Requirements

- Parse and validate EIP-7702 authorization tuples
- Handle delegation bytecode format (0xef01 + address)
- Validate authorization signatures
- Apply delegations to accounts
- Support delegation revocation
- Handle nonce validation for authorizations
- Integrate with transaction processing
- Manage temporary code delegations
- Support chain ID validation
- Handle authorization list in transactions

## Interface

```zig
const std = @import("std");
const Address = @import("address").Address;
const B256 = @import("utils").B256;
const Signature = @import("signature").Signature;

pub const EIP7702Error = error{
    InvalidMagicBytes,
    InvalidDelegation,
    InvalidSignature,
    InvalidChainId,
    InvalidNonce,
    AuthorizationFailed,
    DelegationTooLarge,
};

/// EIP-7702 magic bytes prefix
pub const EIP7702_MAGIC: [2]u8 = .{ 0xef, 0x01 };

/// Authorization tuple for code delegation
pub const Authorization = struct {
    /// Chain ID for replay protection
    chain_id: u64,
    /// Delegated contract address
    address: Address,
    /// Nonce for ordering and replay protection
    nonce: u64,
    /// Signature components
    v: u8,
    r: B256,
    s: B256,

    /// Recover authorizer address from signature
    pub fn recoverAuthorizer(self: *const Authorization) EIP7702Error!Address {
        const hash = self.signingHash();
        const sig = Signature{ .v = self.v, .r = self.r, .s = self.s };
        return sig.recover(hash) catch error.InvalidSignature;
    }

    /// Calculate signing hash for authorization
    fn signingHash(self: *const Authorization) B256 {
        // EIP-7702 signing hash: keccak256(MAGIC || rlp([chain_id, address, nonce]))
        var buf: [256]u8 = undefined;
        var stream = std.io.fixedBufferStream(&buf);
        const writer = stream.writer();
        
        // Write magic bytes
        writer.writeAll(&EIP7702_MAGIC) catch unreachable;
        
        // RLP encode authorization data
        var items = std.ArrayList(rlp.Item).init(std.heap.page_allocator);
        defer items.deinit();
        
        items.append(.{ .String = std.mem.asBytes(&self.chain_id) }) catch unreachable;
        items.append(.{ .String = &self.address }) catch unreachable;
        items.append(.{ .String = std.mem.asBytes(&self.nonce) }) catch unreachable;
        
        const rlp_data = rlp.encode(std.heap.page_allocator, .{ .List = items.items }) catch unreachable;
        defer std.heap.page_allocator.free(rlp_data);
        
        writer.writeAll(rlp_data) catch unreachable;
        
        return B256.keccak256(stream.getWritten());
    }

    /// Validate authorization
    pub fn validate(self: *const Authorization, current_chain_id: u64) EIP7702Error!void {
        if (self.chain_id != current_chain_id) {
            return error.InvalidChainId;
        }
        
        // Check signature validity
        _ = try self.recoverAuthorizer();
    }

    /// RLP encode authorization
    pub fn encode(self: *const Authorization, allocator: std.mem.Allocator) ![]u8 {
        var items = std.ArrayList(rlp.Item).init(allocator);
        defer items.deinit();

        try items.append(.{ .String = std.mem.asBytes(&self.chain_id) });
        try items.append(.{ .String = &self.address });
        try items.append(.{ .String = std.mem.asBytes(&self.nonce) });
        try items.append(.{ .String = std.mem.asBytes(&self.v) });
        try items.append(.{ .String = &self.r });
        try items.append(.{ .String = &self.s });

        return rlp.encode(allocator, .{ .List = items.items });
    }

    /// RLP decode authorization
    pub fn decode(allocator: std.mem.Allocator, data: []const u8) !Authorization {
        const decoded = try rlp.decode(allocator, data);
        defer decoded.deinit();

        const list = decoded.List;
        if (list.len != 6) return error.InvalidDelegation;

        return Authorization{
            .chain_id = try rlp.decodeInt(u64, list[0]),
            .address = try Address.fromBytes(list[1].String),
            .nonce = try rlp.decodeInt(u64, list[2]),
            .v = try rlp.decodeInt(u8, list[3]),
            .r = try B256.fromBytes(list[4].String),
            .s = try B256.fromBytes(list[5].String),
        };
    }
};

/// EIP-7702 delegation bytecode
pub const DelegationCode = struct {
    /// The delegated address
    address: Address,

    /// Create delegation bytecode
    pub fn init(address: Address) DelegationCode {
        return .{ .address = address };
    }

    /// Parse delegation from bytecode
    pub fn fromBytecode(code: []const u8) EIP7702Error!?DelegationCode {
        // Check if this is delegation bytecode
        if (code.len != 23) return null;
        if (!std.mem.eql(u8, code[0..2], &EIP7702_MAGIC)) return null;
        
        // Extract address
        var address: Address = undefined;
        @memcpy(&address, code[2..22]);
        
        // Verify terminator
        if (code[22] != 0x00) return error.InvalidDelegation;
        
        return DelegationCode{ .address = address };
    }

    /// Encode to bytecode format
    pub fn toBytecode(self: *const DelegationCode) [23]u8 {
        var code: [23]u8 = undefined;
        code[0..2].* = EIP7702_MAGIC;
        @memcpy(code[2..22], &self.address);
        code[22] = 0x00; // Terminator
        return code;
    }

    /// Check if bytecode is a delegation
    pub fn isDelegation(code: []const u8) bool {
        return code.len >= 2 and std.mem.eql(u8, code[0..2], &EIP7702_MAGIC);
    }

    /// Get effective code address
    pub fn getEffectiveAddress(code: []const u8) ?Address {
        const delegation = fromBytecode(code) catch return null;
        return if (delegation) |d| d.address else null;
    }
};

/// Process EIP-7702 authorizations
pub const AuthorizationProcessor = struct {
    state_manager: *StateManager,
    chain_id: u64,
    allocator: std.mem.Allocator,

    /// Initialize processor
    pub fn init(
        state_manager: *StateManager,
        chain_id: u64,
        allocator: std.mem.Allocator,
    ) AuthorizationProcessor {
        return .{
            .state_manager = state_manager,
            .chain_id = chain_id,
            .allocator = allocator,
        };
    }

    /// Process a single authorization
    pub fn processAuthorization(
        self: *AuthorizationProcessor,
        auth: *const Authorization,
    ) EIP7702Error!void {
        // Validate authorization
        try auth.validate(self.chain_id);
        
        // Recover authorizer
        const authorizer = try auth.recoverAuthorizer();
        
        // Get account
        const account = try self.state_manager.getAccount(authorizer);
        if (account == null) {
            return error.AuthorizationFailed;
        }
        
        // Check nonce
        if (account.?.nonce != auth.nonce) {
            return error.InvalidNonce;
        }
        
        // Set delegation code
        const delegation = DelegationCode.init(auth.address);
        const code = delegation.toBytecode();
        try self.state_manager.setCode(authorizer, &code);
        
        // Increment nonce
        try self.state_manager.setNonce(authorizer, account.?.nonce + 1);
    }

    /// Process authorization list from transaction
    pub fn processAuthorizationList(
        self: *AuthorizationProcessor,
        authorizations: []const Authorization,
    ) !void {
        for (authorizations) |auth| {
            // Continue processing even if one fails
            self.processAuthorization(&auth) catch |err| {
                std.log.warn("Authorization failed: {}", .{err});
                continue;
            };
        }
    }

    /// Remove delegation (set empty code)
    pub fn removeDelegation(
        self: *AuthorizationProcessor,
        address: Address,
    ) !void {
        try self.state_manager.setCode(address, &[_]u8{});
    }

    /// Check if account has delegation
    pub fn hasDelegation(
        self: *AuthorizationProcessor,
        address: Address,
    ) !bool {
        const code = try self.state_manager.getCode(address);
        return DelegationCode.isDelegation(code);
    }

    /// Get delegated address
    pub fn getDelegatedAddress(
        self: *AuthorizationProcessor,
        address: Address,
    ) !?Address {
        const code = try self.state_manager.getCode(address);
        return DelegationCode.getEffectiveAddress(code);
    }
};
```

## Code Reference from Existing Implementation

From the existing eip7702.zig:

```zig
pub const EIP7702_MAGIC_BYTES = [2]u8{0xE7, 0x02};

pub const Eip7702Bytecode = struct {
    address: Address.Address,
    
    pub fn new(address: Address.Address) Eip7702Bytecode {
        return .{ .address = address };
    }
    
    pub fn newRaw(bytes: []const u8) !Eip7702Bytecode {
        var address: Address.Address = undefined;
        if (bytes.len > 20) {
            @memcpy(&address, bytes[2..22]);
        }
        return Eip7702Bytecode.new(address);
    }
```

## Reference Implementations

### Go-Ethereum (core/types/tx_setcode.go)

```go
// SetCodeTx implements EIP-7702 transaction type
type SetCodeTx struct {
    ChainID          *uint256.Int
    Nonce            uint64
    GasTipCap        *uint256.Int // a.k.a. maxPriorityFeePerGas
    GasFeeCap        *uint256.Int // a.k.a. maxFeePerGas
    Gas              uint64
    To               common.Address
    Value            *uint256.Int
    Data             []byte
    AccessList       AccessList
    AuthList         []Authorization
    V, R, S          *uint256.Int // signature values
}

// Authorization is an EIP-7702 authorization tuple
type Authorization struct {
    ChainID uint64          `json:"chainId"`
    Address common.Address  `json:"address"`
    Nonce   uint64          `json:"nonce"`
    V       uint8           `json:"v"`
    R       common.Hash     `json:"r"`
    S       common.Hash     `json:"s"`
}

// RecoverSigner recovers the address that signed the authorization
func (a *Authorization) RecoverSigner(data *bytes.Buffer) (common.Address, error) {
    sighash := crypto.Keccak256(data.Bytes())
    
    if !crypto.ValidateSignatureValues(a.V, a.R[:], a.S[:]) {
        return common.Address{}, ErrInvalidSig
    }
    
    pub, err := crypto.Ecrecover(sighash, append(append(a.R[:], a.S[:]...), a.V))
    if err != nil {
        return common.Address{}, err
    }
    
    return crypto.PubkeyToAddress(*crypto.UnmarshalPubkey(pub)), nil
}
```

### revm (crates/primitives/src/eip7702.rs)

```rust
/// EIP-7702 authorization list
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Authorization {
    pub chain_id: U256,
    pub address: Address,
    pub nonce: u64,
    pub signature: Signature,
}

impl Authorization {
    /// Recover the signer of the authorization
    pub fn recover_signer(&self) -> Result<Address, SignatureError> {
        let mut buf = Vec::with_capacity(128);
        buf.extend_from_slice(&MAGIC);
        
        // RLP encode the authorization data
        let mut stream = RlpStream::new();
        stream.begin_list(3);
        stream.append(&self.chain_id);
        stream.append(&self.address);
        stream.append(&self.nonce);
        buf.extend_from_slice(&stream.out());
        
        let hash = keccak256(&buf);
        self.signature.recover_signer(&hash)
    }
}

/// EIP-7702 delegation designation
pub const DELEGATION_DESIGNATION: &[u8] = &[0xef, 0x01];

/// Check if the given bytecode is a delegation designation
pub fn is_eip7702_bytecode(bytecode: &[u8]) -> bool {
    bytecode.starts_with(DELEGATION_DESIGNATION)
}

/// Extract the address from an EIP-7702 delegation designation
pub fn eip7702_address(bytecode: &[u8]) -> Option<Address> {
    if bytecode.len() == 23 && is_eip7702_bytecode(bytecode) {
        let mut address = Address::ZERO;
        address.0.copy_from_slice(&bytecode[2..22]);
        Some(address)
    } else {
        None
    }
}
```

## Usage Example

```zig
// Create authorization for delegation
const auth = Authorization{
    .chain_id = 1,
    .address = implementation_contract,
    .nonce = current_nonce,
    .v = sig_v,
    .r = sig_r,
    .s = sig_s,
};

// Initialize processor
var processor = AuthorizationProcessor.init(&state_manager, chain_id, allocator);

// Process authorization
try processor.processAuthorization(&auth);

// Check if account now has delegation
if (try processor.hasDelegation(eoa_address)) {
    // Get delegated address
    const delegated = try processor.getDelegatedAddress(eoa_address);
    std.log.info("EOA {} delegated to {}", .{ eoa_address, delegated });
}

// In transaction processing, check for delegated code
const code = try state_manager.getCode(to_address);
if (DelegationCode.isDelegation(code)) {
    // Execute code from delegated address
    const effective_address = DelegationCode.getEffectiveAddress(code).?;
    const implementation_code = try state_manager.getCode(effective_address);
    // Execute implementation_code in context of to_address
}
```

## Testing Requirements

1. **Authorization Processing**:
   - Test signature recovery
   - Test chain ID validation
   - Test nonce validation
   - Test authorization application

2. **Delegation Code**:
   - Test delegation bytecode format
   - Test address extraction
   - Test delegation detection
   - Test code size limits

3. **State Updates**:
   - Test code setting
   - Test nonce increment
   - Test delegation removal
   - Test multiple authorizations

4. **Edge Cases**:
   - Test invalid signatures
   - Test wrong chain ID
   - Test incorrect nonce
   - Test empty authorization list

5. **Integration**:
   - Test with transaction processing
   - Test with EVM execution
   - Test delegation chains
   - Test gas accounting

## References

- [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) - Set EOA account code
- [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) - Ethereum roadmap
- [Go-Ethereum PR #30078](https://github.com/ethereum/go-ethereum/pull/30078) - EIP-7702 implementation