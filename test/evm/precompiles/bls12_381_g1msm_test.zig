const std = @import("std");
const testing = std.testing;
const evm = @import("evm");
const Address = @import("Address").Address;

// Convenience aliases
const bls12_381_g1msm = evm.precompiles.bls12_381_g1msm;
const precompiles = evm.precompiles.precompiles;
const PrecompileOutput = evm.precompiles.precompile_result.PrecompileOutput;
const PrecompileError = evm.precompiles.precompile_result.PrecompileError;
const ChainRules = evm.hardforks.chain_rules;


fn create_test_chain_rules() ChainRules {
    const rules = ChainRules.for_hardfork(.CANCUN);
    // When EIP-2537 is formally adopted, we'll need to update this
    // For now, assume it's available in post-Cancun
    return rules;
}

const TestVector = struct {
    input: []const u8,
    expected_output: []const u8,
    gas_cost: u64,
    should_succeed: bool,
    description: []const u8,
};

// Simple test vector for G1MSM with one scalar-point pair
const simple_msm_vector = TestVector{
    .input = &[_]u8{
        // Scalar (32 bytes) - 1
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        // G1 point (128 bytes) - Generator point G1
        0x17, 0xf1, 0xd3, 0xa7, 0x31, 0x97, 0xd7, 0x94, 0x2c, 0x95, 0xf9, 0x1c, 0xc9, 0x82, 0x6a, 0x26,
        0xb2, 0x3c, 0x59, 0xd1, 0xad, 0xf4, 0xf9, 0x5c, 0xa4, 0x31, 0x45, 0x2e, 0x3c, 0x9c, 0x86, 0x27,
        0x0e, 0xb6, 0xd5, 0xa5, 0x53, 0x8e, 0x9d, 0x1e, 0xd6, 0x5b, 0x7f, 0xa2, 0x1c, 0x51, 0x51, 0x45,
        0x08, 0x12, 0xd7, 0xf2, 0x9d, 0xa8, 0x89, 0xdb, 0x82, 0x86, 0x7e, 0x94, 0xed, 0x52, 0x94, 0x80,
        0x0b, 0xc1, 0x7b, 0x89, 0x66, 0xb1, 0xa7, 0x0e, 0xd0, 0xda, 0xac, 0xb3, 0x4e, 0x7e, 0xd4, 0xce,
        0x9c, 0x6b, 0x5c, 0xba, 0x43, 0x44, 0x86, 0x9d, 0xb6, 0x5b, 0x7c, 0xa9, 0xbb, 0x2e, 0x77, 0xc8,
        0x07, 0x73, 0xe8, 0x2a, 0xef, 0xb4, 0x9e, 0x99, 0xdc, 0x8b, 0x64, 0x6b, 0xd5, 0x89, 0x5d, 0xa3,
        0x8b, 0x89, 0xd4, 0x36, 0x9c, 0x9d, 0xf4, 0x7d, 0x39, 0x97, 0x6a, 0x3c, 0x28, 0x1f, 0x7d, 0x96,
    },
    .expected_output = &[_]u8{
        // Expected result: G1 generator point (since 1 * G1 = G1)
        0x17, 0xf1, 0xd3, 0xa7, 0x31, 0x97, 0xd7, 0x94, 0x2c, 0x95, 0xf9, 0x1c, 0xc9, 0x82, 0x6a, 0x26,
        0xb2, 0x3c, 0x59, 0xd1, 0xad, 0xf4, 0xf9, 0x5c, 0xa4, 0x31, 0x45, 0x2e, 0x3c, 0x9c, 0x86, 0x27,
        0x0e, 0xb6, 0xd5, 0xa5, 0x53, 0x8e, 0x9d, 0x1e, 0xd6, 0x5b, 0x7f, 0xa2, 0x1c, 0x51, 0x51, 0x45,
        0x08, 0x12, 0xd7, 0xf2, 0x9d, 0xa8, 0x89, 0xdb, 0x82, 0x86, 0x7e, 0x94, 0xed, 0x52, 0x94, 0x80,
        0x0b, 0xc1, 0x7b, 0x89, 0x66, 0xb1, 0xa7, 0x0e, 0xd0, 0xda, 0xac, 0xb3, 0x4e, 0x7e, 0xd4, 0xce,
        0x9c, 0x6b, 0x5c, 0xba, 0x43, 0x44, 0x86, 0x9d, 0xb6, 0x5b, 0x7c, 0xa9, 0xbb, 0x2e, 0x77, 0xc8,
        0x07, 0x73, 0xe8, 0x2a, 0xef, 0xb4, 0x9e, 0x99, 0xdc, 0x8b, 0x64, 0x6b, 0xd5, 0x89, 0x5d, 0xa3,
        0x8b, 0x89, 0xd4, 0x36, 0x9c, 0x9d, 0xf4, 0x7d, 0x39, 0x97, 0x6a, 0x3c, 0x28, 0x1f, 0x7d, 0x96,
    },
    .gas_cost = 12275 + 15900, // base_cost + 1 * per_pair_cost
    .should_succeed = true,
    .description = "Simple G1MSM with scalar 1 and generator point",
};

// Test vector for G1MSM with zero scalar
const zero_scalar_vector = TestVector{
    .input = &[_]u8{
        // Scalar (32 bytes) - 0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // G1 point (128 bytes) - Generator point G1
        0x17, 0xf1, 0xd3, 0xa7, 0x31, 0x97, 0xd7, 0x94, 0x2c, 0x95, 0xf9, 0x1c, 0xc9, 0x82, 0x6a, 0x26,
        0xb2, 0x3c, 0x59, 0xd1, 0xad, 0xf4, 0xf9, 0x5c, 0xa4, 0x31, 0x45, 0x2e, 0x3c, 0x9c, 0x86, 0x27,
        0x0e, 0xb6, 0xd5, 0xa5, 0x53, 0x8e, 0x9d, 0x1e, 0xd6, 0x5b, 0x7f, 0xa2, 0x1c, 0x51, 0x51, 0x45,
        0x08, 0x12, 0xd7, 0xf2, 0x9d, 0xa8, 0x89, 0xdb, 0x82, 0x86, 0x7e, 0x94, 0xed, 0x52, 0x94, 0x80,
        0x0b, 0xc1, 0x7b, 0x89, 0x66, 0xb1, 0xa7, 0x0e, 0xd0, 0xda, 0xac, 0xb3, 0x4e, 0x7e, 0xd4, 0xce,
        0x9c, 0x6b, 0x5c, 0xba, 0x43, 0x44, 0x86, 0x9d, 0xb6, 0x5b, 0x7c, 0xa9, 0xbb, 0x2e, 0x77, 0xc8,
        0x07, 0x73, 0xe8, 0x2a, 0xef, 0xb4, 0x9e, 0x99, 0xdc, 0x8b, 0x64, 0x6b, 0xd5, 0x89, 0x5d, 0xa3,
        0x8b, 0x89, 0xd4, 0x36, 0x9c, 0x9d, 0xf4, 0x7d, 0x39, 0x97, 0x6a, 0x3c, 0x28, 0x1f, 0x7d, 0x96,
    },
    .expected_output = &[_]u8{
        // Expected result: Point at infinity (0 * G1 = O)
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    .gas_cost = 12275 + 15900, // base_cost + 1 * per_pair_cost
    .should_succeed = true,
    .description = "G1MSM with zero scalar should return point at infinity",
};

// Test vector for invalid input length
const invalid_length_vector = TestVector{
    .input = &[_]u8{
        // Incomplete input - should be 160 bytes per pair
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        // Incomplete G1 point (only 64 bytes instead of 128)
        0x17, 0xf1, 0xd3, 0xa7, 0x31, 0x97, 0xd7, 0x94, 0x2c, 0x95, 0xf9, 0x1c, 0xc9, 0x82, 0x6a, 0x26,
        0xb2, 0x3c, 0x59, 0xd1, 0xad, 0xf4, 0xf9, 0x5c, 0xa4, 0x31, 0x45, 0x2e, 0x3c, 0x9c, 0x86, 0x27,
        0x0e, 0xb6, 0xd5, 0xa5, 0x53, 0x8e, 0x9d, 0x1e, 0xd6, 0x5b, 0x7f, 0xa2, 0x1c, 0x51, 0x51, 0x45,
        0x08, 0x12, 0xd7, 0xf2, 0x9d, 0xa8, 0x89, 0xdb, 0x82, 0x86, 0x7e, 0x94, 0xed, 0x52, 0x94, 0x80,
    },
    .expected_output = &[_]u8{}, // No output expected for invalid input
    .gas_cost = 0, // No gas consumed on invalid input
    .should_succeed = false,
    .description = "Invalid input length should fail",
};

test "bls12_381_g1_msm basic functionality with known vectors" {
    var output_buffer: [128]u8 = undefined;
    
    // Test simple MSM
    const result = bls12_381_g1msm.execute(
        simple_msm_vector.input,
        &output_buffer,
        simple_msm_vector.gas_cost,
    );
    
    try testing.expect(result.is_success() == simple_msm_vector.should_succeed);
    if (result.is_success()) {
        try testing.expectEqualSlices(u8, simple_msm_vector.expected_output, output_buffer[0..128]);
    }
}

test "bls12_381_g1_msm handles edge cases correctly" {
    var output_buffer: [128]u8 = undefined;
    
    // Test zero scalar
    const zero_result = bls12_381_g1msm.execute(
        zero_scalar_vector.input,
        &output_buffer,
        zero_scalar_vector.gas_cost,
    );
    
    try testing.expect(zero_result.is_success() == zero_scalar_vector.should_succeed);
    if (zero_result.is_success()) {
        try testing.expectEqualSlices(u8, zero_scalar_vector.expected_output, output_buffer[0..128]);
    }
}

test "bls12_381_g1_msm validates input format" {
    var output_buffer: [128]u8 = undefined;
    
    // Test invalid length
    const invalid_result = bls12_381_g1msm.execute(
        invalid_length_vector.input,
        &output_buffer,
        1000000, // Large gas limit
    );
    
    try testing.expect(invalid_result.is_success() == invalid_length_vector.should_succeed);
}


test "bls12_381_g1_msm gas cost calculation accuracy" {
    // Test gas calculation for different input sizes
    const one_pair_gas = try bls12_381_g1msm.calculate_gas_checked(160); // 1 pair
    try testing.expectEqual(@as(u64, 12275 + 15900), one_pair_gas);
    
    const two_pair_gas = try bls12_381_g1msm.calculate_gas_checked(320); // 2 pairs
    try testing.expectEqual(@as(u64, 12275 + 2 * 15900), two_pair_gas);
    
    // Test invalid input size
    const invalid_gas_result = bls12_381_g1msm.calculate_gas_checked(100); // Invalid size
    try testing.expectError(error.InvalidInput, invalid_gas_result);
}


test "bls12_381_g1_msm output size calculation" {
    // G1MSM always outputs 128 bytes (one G1 point)
    const output_size = bls12_381_g1msm.get_output_size(160); // 1 pair
    try testing.expectEqual(@as(usize, 128), output_size);
    
    const output_size_2 = bls12_381_g1msm.get_output_size(320); // 2 pairs
    try testing.expectEqual(@as(usize, 128), output_size_2);
}


test "bls12_381_g1_msm handles empty input" {
    var output_buffer: [128]u8 = undefined;
    
    const empty_result = bls12_381_g1msm.execute(
        &[_]u8{}, // Empty input
        &output_buffer,
        1000000, // Large gas limit
    );
    
    try testing.expect(!empty_result.is_success());
}


test "bls12_381_g1_msm gas overflow protection" {
    // Test with a large input that would cause gas overflow
    // We need a size that is divisible by 160 but would cause gas overflow
    // Let's use a size that would result in num_pairs causing overflow in multiplication
    const large_num_pairs = std.math.maxInt(u64) / 15900 + 1;
    const large_size = large_num_pairs * 160; // This should be valid input size but cause gas overflow
    const result = bls12_381_g1msm.calculate_gas_checked(large_size);
    try testing.expectError(error.GasOverflow, result);
}


test "bls12_381_g1_msm precompile registration" {
    // Test that G1MSM address will be recognized as precompile
    // Note: This test will need to be updated once we add the address constant
    // const g1msm_address: Address.Address = [_]u8{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0C };
    
    // This will fail initially since G1MSM is not yet registered
    // const is_precompile = addresses.is_precompile(g1msm_address);
    // const precompile_id = addresses.get_precompile_id(g1msm_address);
    // try testing.expectEqual(@as(u8, 12), precompile_id);
}


test "bls12_381_g1_msm never panics on malformed input" {
    var output_buffer: [128]u8 = undefined;
    
    // Test various malformed inputs
    const malformed_inputs = [_][]const u8{
        &[_]u8{0xFF} ** 159, // 159 bytes (one less than required)
        &[_]u8{0xFF} ** 161, // 161 bytes (one more than required)
        &[_]u8{0xFF} ** 320, // 320 bytes but with invalid point data
        &[_]u8{}, // Empty
        &[_]u8{0x00}, // Single byte
    };
    
    for (malformed_inputs) |input| {
        const result = bls12_381_g1msm.execute(input, &output_buffer, 1000000);
        // Should not panic, just fail gracefully
        try testing.expect(!result.is_success());
    }
}

test "bls12_381_g1_msm performance with multiple pairs" {
    // This test will be implemented once the basic functionality works
    // It should test MSM with 2, 4, 8, 16 pairs to ensure reasonable performance
}


test "bls12_381_g1_msm matches reference implementation output" {
    // This test will be implemented with official EIP-2537 test vectors
    // once they are available and the basic implementation is working
}