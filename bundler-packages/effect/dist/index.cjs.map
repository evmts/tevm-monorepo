{"version":3,"sources":["../src/createRequireEffect.js","../src/fileExists.js","../src/logAllErrors.js","../src/parseJson.js","../src/resolve.js"],"names":["e","logDebug","tap","tryEffect"],"mappings":"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","sourcesContent":["import { createRequire } from 'node:module'\n// TODO unused move this to @tevm/createRequire package\nimport { try as tryEffect } from 'effect/Effect'\nimport { map } from 'effect/Effect'\n\nexport class CreateRequireError extends Error {\n\t/**\n\t * @type {'CreateRequireError'}\n\t */\n\t_tag = 'CreateRequireError'\n\t/**\n\t * @param {string} url\n\t * @param {object} [cause]\n\t * @param {unknown} [cause.cause]\n\t * @internal\n\t */\n\tconstructor(url, options = {}) {\n\t\tsuper(`Failed to create require for ${url}`, options)\n\t}\n}\n\nexport class RequireError extends Error {\n\t_tag = 'RequireError'\n\t/**\n\t * @param {string} url\n\t * @param {object} [cause]\n\t * @param {unknown} [cause.cause]\n\t * @internal\n\t */\n\tconstructor(url, options = {}) {\n\t\tsuper(`Failed to require ${url}`, options)\n\t}\n}\n\n/**\n * An {@link https://www.effect.website/docs/introduction Effect} wrapper around createRequire\n * createRequire is used to use the node.js `require` function in esm modules and cjs modules\n * in a way that is compatible with both. It also wraps them weith Effect for better error handling\n * @param {string} url - url to create require from\n * @returns {import(\"effect/Effect\").Effect<never, CreateRequireError, (id: string) => import(\"effect/Effect\").Effect<never, RequireError, ReturnType<NodeRequire>>>} require function\n * @example\n * ```typescript\n * import { createRequireEffect } from '@eth-optimism/config'\n * const requireEffect = createRequireEffect(import.meta.url)\n * const solcEffect = requireEffect('solc')\n * ```\n * @see https://nodejs.org/api/modules.html#modules_module_createrequire_filename\n * @internal\n */\nexport const createRequireEffect = (url) => {\n\treturn tryEffect({\n\t\ttry: () => createRequire(url),\n\t\tcatch: (cause) => new CreateRequireError(url, { cause }),\n\t}).pipe(\n\t\tmap((createdRequire) => {\n\t\t\t/**\n\t\t\t * Same as require but returns a module as an Effect\n\t\t\t * @param {string} id\n\t\t\t * @returns {import(\"effect/Effect\").Effect<never, RequireError, ReturnType<NodeRequire>>}\n\t\t\t */\n\t\t\tconst requireAsEffect = (id) => {\n\t\t\t\treturn tryEffect({\n\t\t\t\t\ttry: () => createdRequire(id),\n\t\t\t\t\tcatch: (cause) => new RequireError(id, { cause }),\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn requireAsEffect\n\t\t}),\n\t)\n}\n","import { constants } from 'node:fs'\nimport { access } from 'node:fs/promises'\nimport { flatMap, logDebug, promise, tap } from 'effect/Effect'\n\n/**\n * Checks if a file exists at the given path\n * @param {string} path - path to check\n * @returns {import(\"effect/Effect\").Effect<never, never, boolean>} true if the file exists, false otherwise\n * @example\n * ```typescript\n * import { fileExists } from '@eth-optimism/config'\n * await fileExists('./someFile.txt')\n * ```\n * @internal\n */\nexport const fileExists = (path) => {\n\treturn logDebug(`fileExists: Checking if file exists at path: ${path}`).pipe(\n\t\tflatMap(() =>\n\t\t\tpromise(() =>\n\t\t\t\taccess(path, constants.F_OK)\n\t\t\t\t\t.then(() => true)\n\t\t\t\t\t.catch(() => false),\n\t\t\t),\n\t\t),\n\t\ttap((exists) => logDebug(`fileExists: ${path}: ${exists}`)),\n\t)\n}\n","import { all, logError } from 'effect/Effect'\n\n/**\n * Logs all errors and causes from effect\n * @param {unknown} e\n * @returns {import(\"effect/Effect\").Effect<never, never, void>}\n * @internal\n * @example\n * ```typescript\n * import { logAllErrors } from '@eth-optimism/config'\n *\n * someEffect.pipe(\n *   tapError(logAllErrors)\n * )\n */\nexport const logAllErrors = (e) => {\n\tconst errors = [e]\n\tlet nextError = /** @type {Error} */ (e)\n\twhile (nextError.cause) {\n\t\terrors.unshift(nextError.cause)\n\t\tnextError = /** @type {Error} */ (nextError.cause)\n\t}\n\treturn all(errors.map((e) => logError(e)))\n}\n","import { logDebug, tap, try as tryEffect } from 'effect/Effect'\nimport { parse } from 'jsonc-parser'\n\n/**\n * Error thrown when the tsconfig.json file is not valid json\n * @internal\n */\nexport class ParseJsonError extends Error {\n\t/**\n\t * @type {'ParseJsonError'}\n\t */\n\t_tag = 'ParseJsonError'\n\t/**\n\t * @param {object} [options]\n\t * @param {unknown} [options.cause]\n\t */\n\tconstructor(options = {}) {\n\t\tsuper('Failed to parse tsconfig.json', options)\n\t}\n}\n\n/**\n * Parses a json string\n * @param {string} jsonStr\n * @returns {import(\"effect/Effect\").Effect<never, ParseJsonError, unknown>}\n * @throws {ParseJsonError} when the tevm.json file is not valid json\n * @example\n * ```ts\n * const jsonEffect = parseJson('{ \"compilerOptions\": { \"plugins\": [{ \"name\": \"@tevm/ts-plugin\" }] } }')\n * ````\n * @internal\n */\nexport const parseJson = (jsonStr) => {\n\treturn tryEffect({\n\t\ttry: () => {\n\t\t\tconst errors = /** @type {import(\"jsonc-parser\").ParseError[]}*/ ([])\n\t\t\tconst res = parse(jsonStr, errors, {\n\t\t\t\tdisallowComments: false,\n\t\t\t\tallowTrailingComma: true,\n\t\t\t\tallowEmptyContent: false,\n\t\t\t})\n\t\t\tif (errors.length > 0) {\n\t\t\t\tthrow new AggregateError(errors)\n\t\t\t}\n\t\t\treturn res\n\t\t},\n\t\tcatch: (cause) => new ParseJsonError({ cause }),\n\t}).pipe(tap((res) => logDebug(`Parsed tsconfig.json: ${JSON.stringify(res)}`)))\n}\n","import { async as effectAsync, fail, succeed, try as trySync } from 'effect/Effect'\nimport resolve from 'resolve'\n\n/**\n * @typedef {(importPath: string, options: import('resolve').SyncOpts & import('resolve').AsyncOpts) => import('effect/Effect').Effect<never, CouldNotResolveImportError, string>} ResolveSafe\n */\n\n/**\n * Error thrown when 'node:resolve' throws\n */\nexport class CouldNotResolveImportError extends Error {\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t */\n\t_tag = 'CouldNotResolveImportError'\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t * @override\n\t */\n\tname = 'CouldNotResolveImportError'\n\t/**\n\t * @param {string} importPath\n\t * @param {string} absolutePath\n\t * @param {Error} cause\n\t */\n\tconstructor(importPath, absolutePath, cause) {\n\t\tsuper(`Could not resolve import ${importPath} from ${absolutePath}. Please check your remappings and libraries.`, {\n\t\t\tcause,\n\t\t})\n\t}\n}\n\n/**\n * Effect wrapper around import('node:resolve').resolveSync\n * @type {ResolveSafe}\n * @example\n * ```ts\n * import {tap} from 'effect/Effect'\n * import {resolveSync} from '@tevm/effect'\n * resolveSync('react').pipe(\n *    tap(console.log)\n * )\n * ````\n * `\n */\nexport const resolveSync = (importPath, options) => {\n\treturn trySync({\n\t\ttry: () => resolve.sync(importPath, options),\n\t\tcatch: (e) => new CouldNotResolveImportError(importPath, options.basedir ?? __dirname, /** @type {Error} */ (e)),\n\t})\n}\n\n/**\n * Effect wrpper around import('node:resolve')\n * @type {ResolveSafe}\n * @example\n * ```ts\n * import {tap} from 'effect/Effect'\n * import {resolveAsync} from '@tevm/effect'\n * resolveAsync('react').pipe(\n *    tap(console.log)\n * )\n * ````\n */\nexport const resolveAsync = (importPath, options) => {\n\treturn effectAsync((resume) => {\n\t\tresolve(importPath, options, (err, resolvedPath) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err)\n\t\t\t\tresume(fail(new CouldNotResolveImportError(importPath, options.basedir ?? '', err)))\n\t\t\t} else {\n\t\t\t\tresume(succeed(/** @type {string} */ (resolvedPath)))\n\t\t\t}\n\t\t})\n\t})\n}\n"]}