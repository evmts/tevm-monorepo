{"version":3,"sources":["../src/index.js"],"names":["error"],"mappings":";;;;AAQA,IAAI,aAAgB,GAAA,CAAA;AAoCP,IAAA,GAAA,GAAM,CAAC,OAAA,EAAA,GAAY,MAAW,KAAA;AAC1C,EAAA,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAO,CAAC,MAAA,EAAQ,QAAQ,CAAM,KAAA;AACpD,IAAA,OAAO,MAAS,GAAA,MAAA,IAAU,MAAO,CAAA,CAAC,CAAK,IAAA,EAAA,CAAA;AAAA,KACrC,EAAE,CAAA;AAGL,EAAM,MAAA,KAAA,GAAQ,IAAI,KAAM,EAAA;AACxB,EAAM,MAAA,KAAA,GAAQ,MAAM,KAAS,IAAA,EAAA;AAC7B,EAAA,MAAM,aAAa,KAAM,CAAA,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAK,IAAA,EAAA;AAC3C,EAAA,MAAM,KAAQ,GAAA,UAAA,CAAW,KAAM,CAAA,8BAA8B,KAAK,EAAC;AAGnE,EAAM,MAAA,UAAA,GAAa,KAAM,CAAA,CAAC,CAAK,IAAA,SAAA;AAC/B,EAAA,MAAM,iBAAiB,UAAW,CAAA,UAAA,CAAW,SAAS,CAAI,GAAA,aAAA,CAAc,UAAU,CAAI,GAAA,UAAA;AAItF,EAAA,MAAM,KAAQ,GAAA,aAAA,EAAA;AACd,EAAA,MAAM,WAAW,cAAe,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,KAAS,IAAA,QAAA;AACpD,EAAA,MAAM,WAAc,GAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,KAAK,CAAA,IAAA,CAAA;AAGxC,EAAA,MAAM,MAAS,GAAA;AAAA,IACd,YAAY,EAAC;AAAA,IACb,MAAM,EAAC;AAAA,IACP,KAAO,EAAA;AAAA,GACR;AAEA,EAAI,IAAA;AAGH,IAAA,MAAM,SAAS,QAAS,CAAA,mBAAA;AAAA,MACvB,MAAA;AAAA,MACA,WAAA;AAAA,MACA,QAAQ,GAAI,EAAA;AAAA,MACZ,MAAA;AAAA,MACA,KAAA;AAAA;AAAA,MACA,IAAA;AAAA;AAAA,MACA;AAAA;AAAA,QAEC,YAAA,EAAc,CAAC,IAAS,KAAA;AACvB,UAAI,IAAA,IAAA,KAAS,aAAoB,OAAA,MAAA;AACjC,UAAA,MAAM,IAAI,KAAA,CAAM,CAAmB,gBAAA,EAAA,IAAI,CAAE,CAAA,CAAA;AAAA,SAC1C;AAAA,QACA,UAAA,EAAY,CAAC,IAAA,KAAS,IAAS,KAAA,WAAA;AAAA,QAC/B,eAAe,MAAM;AAAA;AAAC,OACvB;AAAA,MACA;AAAA;AAAA,KACD;AAEA,IAAA,OAAO,MAAO,CAAA,QAAA;AAAA,WACNA,MAAO,EAAA;AACf,IAAQ,OAAA,CAAA,KAAA,CAAM,oCAAoCA,MAAK,CAAA;AACvD,IAAMA,MAAAA,MAAAA;AAAA;AAER","file":"index.mjs","sourcesContent":["/**\n * @module @tevm/inline-sol\n * @description Inline Solidity template literal tag for Tevm\n */\n\nimport { fileURLToPath } from 'node:url'\nimport { compiler } from '@tevm/compiler'\n\nlet inlineCounter = 0\n\n/**\n * Template literal tag for inline Solidity code\n * Compiles the Solidity code inline and returns the contract\n *\n * @example\n * ```ts\n * import { sol } from 'tevm'\n *\n * // Define contract inline\n * const Counter = sol`\n *   pragma solidity ^0.8.19;\n *\n *   contract Counter {\n *     uint256 private count = 0;\n *\n *     function increment() public {\n *       count += 1;\n *     }\n *\n *     function count() public view returns (uint256) {\n *       return count;\n *     }\n *   }\n * `\n *\n * // Use with client.deployContract, client.readContract, etc.\n * const client = createMemoryClient()\n * const deployed = await client.deployContract(Counter)\n * ```\n *\n * @param {TemplateStringsArray} strings - The template literal strings\n * @param {...any} values - The template literal values\n * @returns {import('@tevm/contract').Contract<any,any,any,any>} The compiled contract\n */\nexport const sol = (strings, ...values) => {\n\tconst source = strings.reduce((result, string, i) => {\n\t\treturn result + string + (values[i] ?? '')\n\t}, '')\n\n\t// Get caller file info to create unique filename\n\tconst error = new Error()\n\tconst stack = error.stack || ''\n\tconst callerLine = stack.split('\\n')[2] || ''\n\tconst match = callerLine.match(/at (.+) \\((.+):(\\d+):(\\d+)\\)/) || []\n\n\t// Extract file path from stack trace\n\tconst callerFile = match[2] || 'unknown'\n\tconst normalizedPath = callerFile.startsWith('file://') ? fileURLToPath(callerFile) : callerFile\n\n\t// Create a unique filename for this inline contract\n\t// Format: originalFileName_inlineIndex.sol\n\tconst index = inlineCounter++\n\tconst baseName = normalizedPath.split('/').pop() || 'inline'\n\tconst solFileName = `${baseName}_${index}.sol`\n\n\t// Default compiler config\n\tconst config = {\n\t\tremappings: {},\n\t\tlibs: [],\n\t\tdebug: false,\n\t}\n\n\ttry {\n\t\t// Since this is running in user code context, we use the sync API\n\t\t// We deliberately use a temporary file that doesn't need to be written to disk\n\t\tconst result = compiler.compileContractSync(\n\t\t\tsource,\n\t\t\tsolFileName,\n\t\t\tprocess.cwd(),\n\t\t\tconfig,\n\t\t\tfalse, // includeAst\n\t\t\ttrue, // includeBytecode\n\t\t\t{\n\t\t\t\t// Simple in-memory file system for the compiler\n\t\t\t\treadFileSync: (file) => {\n\t\t\t\t\tif (file === solFileName) return source\n\t\t\t\t\tthrow new Error(`File not found: ${file}`)\n\t\t\t\t},\n\t\t\t\texistsSync: (file) => file === solFileName,\n\t\t\t\twriteFileSync: () => {},\n\t\t\t},\n\t\t\tconsole, // logger\n\t\t)\n\n\t\treturn result.contract\n\t} catch (error) {\n\t\tconsole.error('Error compiling inline Solidity:', error)\n\t\tthrow error\n\t}\n}\n"]}