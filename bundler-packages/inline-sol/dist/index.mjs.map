{"version":3,"sources":["../src/index.js"],"names":["error"],"mappings":";;;;AAQA,IAAI,aAAgB,GAAA,CAAA;AAoCP,IAAA,GAAA,GAAM,CAAC,OAAA,EAAA,GAAY,MAAW,KAAA;AAC1C,EAAA,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAO,CAAC,MAAA,EAAQ,QAAQ,CAAM,KAAA;AACpD,IAAA,OAAO,MAAS,GAAA,MAAA,IAAU,MAAO,CAAA,CAAC,CAAK,IAAA,EAAA,CAAA;AAAA,KACrC,EAAE,CAAA;AAGL,EAAM,MAAA,KAAA,GAAQ,IAAI,KAAM,EAAA;AACxB,EAAM,MAAA,KAAA,GAAQ,MAAM,KAAS,IAAA,EAAA;AAC7B,EAAA,MAAM,aAAa,KAAM,CAAA,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAK,IAAA,EAAA;AAC3C,EAAA,MAAM,KAAQ,GAAA,UAAA,CAAW,KAAM,CAAA,8BAA8B,KAAK,EAAC;AAGnE,EAAM,MAAA,UAAA,GAAa,KAAM,CAAA,CAAC,CAAK,IAAA,SAAA;AAC/B,EAAA,MAAM,iBAAiB,UAAW,CAAA,UAAA,CAAW,SAAS,CAAI,GAAA,aAAA,CAAc,UAAU,CAAI,GAAA,UAAA;AAItF,EAAA,MAAM,KAAQ,GAAA,aAAA,EAAA;AACd,EAAA,MAAM,WAAW,cAAe,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,KAAS,IAAA,QAAA;AACpD,EAAA,MAAM,WAAc,GAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,KAAK,CAAA,IAAA,CAAA;AAIxC,EAAA,MAAM,MAAS,GAAA;AAAA,IACd,YAAY,EAAC;AAAA,IACb,MAAM,EAAC;AAAA,IACP,KAAO,EAAA,KAAA;AAAA,IACP,aAAa,EAAC;AAAA,IACd,cAAgB,EAAA,KAAA;AAAA,IAChB,QAAU,EAAA,CAAA,EAAG,OAAQ,CAAA,GAAA,EAAK,CAAA,MAAA;AAAA,GAC3B;AAEA,EAAI,IAAA;AAGH,IAAA,MAAM,MAAS,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMd,YAAA,EAAc,CAAC,IAAA,EAAM,QAAa,KAAA;AACjC,QAAI,IAAA,IAAA,KAAS,aAAoB,OAAA,MAAA;AACjC,QAAA,MAAM,IAAI,KAAA,CAAM,CAAmB,gBAAA,EAAA,IAAI,CAAE,CAAA,CAAA;AAAA,OAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,QAAA,EAAU,CAAC,IAAA,EAAM,QAAa,KAAA;AAC7B,QAAA,IAAI,IAAS,KAAA,WAAA,EAAoB,OAAA,OAAA,CAAQ,QAAQ,MAAM,CAAA;AACvD,QAAA,OAAO,QAAQ,MAAO,CAAA,IAAI,MAAM,CAAmB,gBAAA,EAAA,IAAI,EAAE,CAAC,CAAA;AAAA,OAC3D;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,UAAA,EAAY,CAAC,IAAA,KAAS,IAAS,KAAA,WAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAK/B,QAAQ,CAAC,IAAA,KAAS,OAAQ,CAAA,OAAA,CAAQ,SAAS,WAAW;AAAA,KACvD;AAIA,IAAA,MAAM,SAAwB,cAAS,CAAA,QAAA,CAAA,mBAAA;AAAA,MACtC,WAAA;AAAA;AAAA,MACA,QAAQ,GAAI,EAAA;AAAA;AAAA;AAAA,MACQ,MAAA;AAAA;AAAA,MACpB,KAAA;AAAA;AAAA,MACA,IAAA;AAAA;AAAA,MACA,MAAA;AAAA;AAAA,MACA,OAAA;AAAA;AAAA,MACA,KAAA;AAAA;AAAA,KACD;AAEA,IAAA,OAAO,MAAO,CAAA,QAAA;AAAA,WACNA,MAAO,EAAA;AACf,IAAQ,OAAA,CAAA,KAAA,CAAM,oCAAoCA,MAAK,CAAA;AACvD,IAAMA,MAAAA,MAAAA;AAAA;AAER","file":"index.mjs","sourcesContent":["/**\n * @module @tevm/inline-sol\n * @description Inline Solidity template literal tag for Tevm\n */\n\nimport { fileURLToPath } from 'node:url'\nimport * as compilerModule from '@tevm/compiler'\n\nlet inlineCounter = 0\n\n/**\n * Template literal tag for inline Solidity code\n * Compiles the Solidity code inline and returns the contract\n *\n * @example\n * ```ts\n * import { sol } from 'tevm'\n *\n * // Define contract inline\n * const Counter = sol`\n *   pragma solidity ^0.8.19;\n *\n *   contract Counter {\n *     uint256 private count = 0;\n *\n *     function increment() public {\n *       count += 1;\n *     }\n *\n *     function count() public view returns (uint256) {\n *       return count;\n *     }\n *   }\n * `\n *\n * // Use with client.deployContract, client.readContract, etc.\n * const client = createMemoryClient()\n * const deployed = await client.deployContract(Counter)\n * ```\n *\n * @param {TemplateStringsArray} strings - The template literal strings\n * @param {...any} values - The template literal values\n * @returns {import('@tevm/contract').Contract<any,any,any,any>} The compiled contract\n */\nexport const sol = (strings, ...values) => {\n\tconst source = strings.reduce((result, string, i) => {\n\t\treturn result + string + (values[i] ?? '')\n\t}, '')\n\n\t// Get caller file info to create unique filename\n\tconst error = new Error()\n\tconst stack = error.stack || ''\n\tconst callerLine = stack.split('\\n')[2] || ''\n\tconst match = callerLine.match(/at (.+) \\((.+):(\\d+):(\\d+)\\)/) || []\n\n\t// Extract file path from stack trace\n\tconst callerFile = match[2] || 'unknown'\n\tconst normalizedPath = callerFile.startsWith('file://') ? fileURLToPath(callerFile) : callerFile\n\n\t// Create a unique filename for this inline contract\n\t// Format: originalFileName_inlineIndex.sol\n\tconst index = inlineCounter++\n\tconst baseName = normalizedPath.split('/').pop() || 'inline'\n\tconst solFileName = `${baseName}_${index}.sol`\n\n\t// Default compiler config\n\t/** @type {import('@tevm/config').ResolvedCompilerConfig} */\n\tconst config = {\n\t\tremappings: {},\n\t\tlibs: [],\n\t\tdebug: false,\n\t\tjsonAsConst: [],\n\t\tfoundryProject: false,\n\t\tcacheDir: `${process.cwd()}/.tevm`,\n\t}\n\n\ttry {\n\t\t// Create a simple in-memory file system\n\t\t/** @type {import('@tevm/compiler').FileAccessObject} */\n\t\tconst fakeFs = {\n\t\t\t/**\n\t\t\t * @param {string} file - File path\n\t\t\t * @param {BufferEncoding} encoding - File encoding\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\treadFileSync: (file, encoding) => {\n\t\t\t\tif (file === solFileName) return source\n\t\t\t\tthrow new Error(`File not found: ${file}`)\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {string} file - File path\n\t\t\t * @param {BufferEncoding} encoding - File encoding\n\t\t\t * @returns {Promise<string>}\n\t\t\t */\n\t\t\treadFile: (file, encoding) => {\n\t\t\t\tif (file === solFileName) return Promise.resolve(source)\n\t\t\t\treturn Promise.reject(new Error(`File not found: ${file}`))\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {string} file - File path\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\texistsSync: (file) => file === solFileName,\n\t\t\t/**\n\t\t\t * @param {string} file - File path\n\t\t\t * @returns {Promise<boolean>}\n\t\t\t */\n\t\t\texists: (file) => Promise.resolve(file === solFileName),\n\t\t}\n\n\t\t// Since this is running in user code context, we use the sync API\n\t\t// We deliberately use a temporary file that doesn't need to be written to disk\n\t\tconst result = compilerModule.compiler.compileContractSync(\n\t\t\tsolFileName, // filePath\n\t\t\tprocess.cwd(), // basedir\n\t\t\t/** @type {any} */ (config), // config\n\t\t\tfalse, // includeAst\n\t\t\ttrue, // includeBytecode\n\t\t\tfakeFs, // fao\n\t\t\tconsole, // logger\n\t\t\tundefined, // solc - use default\n\t\t)\n\n\t\treturn result.contract\n\t} catch (error) {\n\t\tconsole.error('Error compiling inline Solidity:', error)\n\t\tthrow error\n\t}\n}\n"]}