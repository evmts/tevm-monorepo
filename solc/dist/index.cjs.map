{"version":3,"sources":["../src/index.js","../src/runtime/generateEvmtsBodyDts.js","../src/runtime/generateEvmtsBody.js","../src/runtime/generateRuntime.js","../src/runtime/generateRuntimeSync.js","../src/utils/isImportLocal.js","../src/utils/formatPath.js","../src/utils/invariant.js","../src/utils/resolvePromise.js","../src/solc/resolveImportPath.js","../src/solc/resolveImports.js","../src/solc/moduleFactory.js","../src/solc/solc.js","../src/solc/compileContracts.js","../src/solc/resolveArtifacts.js","../src/solc/moduleFactorySync.js","../src/solc/compileContractsSync.js","../src/solc/resolveArtifactsSync.js","../src/bundler.js","../src/createCache.js","../src/unplugin.js"],"sourcesContent":["/**\n * ./types.ts\n * @typedef {import('./types.js').AsyncBundlerResult} AsyncBundlerResult\n * @typedef {import('./types.js').Bundler} Bundler\n * @typedef {import('./types.js').BundlerResult} BundlerResult\n * @typedef {import('./types.js').CompiledContracts} CompiledContracts\n * @typedef {import('./types.js').FileAccessObject} FileAccessObject\n * @typedef {import('./types.js').Logger} Logger\n * @typedef {import('./types.js').ModuleInfo} ModuleInfo\n * @typedef {import('./types.js').SolidityResolver} SolidityResolver\n * @typedef {import('./types.js').SyncBundlerResult} SyncBundlerResult\n *\n * ./createCache.js\n * @typedef {import('./createCache.js').Cache} Cache\n */\nexport { bundler } from './bundler.js'\nexport { createCache } from './createCache.js'\nexport { resolveArtifacts, resolveArtifactsSync } from './solc/index.js'\nexport {\n\tvitePluginEvmts,\n\trollupPluginEvmts,\n\trspackPluginEvmts,\n\tesbuildPluginEvmts,\n\twebpackPluginEvmts,\n} from './unplugin.js'\n// export * from './runtime/index.js'\n// export * from './utils/index.js'\n","import { formatAbi } from 'abitype'\n\n/**\n * @param {import(\"../solc/resolveArtifactsSync.js\").Artifacts} artifacts\n * @returns {string}\n */\nexport const generateDtsBody = (artifacts) => {\n\treturn Object.entries(artifacts)\n\t\t.flatMap(([contractName, { abi, userdoc = {} }]) => {\n\t\t\tconst contract = {\n\t\t\t\tname: contractName,\n\t\t\t\thumanReadableAbi: formatAbi(abi),\n\t\t\t}\n\t\t\tconst natspec = Object.entries(userdoc.methods ?? {}).map(\n\t\t\t\t([method, { notice }]) => ` * @property ${method} ${notice}`,\n\t\t\t)\n\t\t\tif (userdoc.notice) {\n\t\t\t\tnatspec.unshift(` * @notice ${userdoc.notice}`)\n\t\t\t}\n\t\t\treturn [\n\t\t\t\t`const _abi${contractName} = ${JSON.stringify(\n\t\t\t\t\tcontract.humanReadableAbi,\n\t\t\t\t)} as const;`,\n\t\t\t\t`const _name${contractName} = ${JSON.stringify(\n\t\t\t\t\tcontractName,\n\t\t\t\t)} as const;`,\n\t\t\t\t'/**',\n\t\t\t\t` * ${contractName} EvmtsContract`,\n\t\t\t\t...natspec,\n\t\t\t\t' */',\n\t\t\t\t`export const ${contractName}: EvmtsContract<typeof _name${contractName}, typeof _abi${contractName}>;`,\n\t\t\t].filter(Boolean)\n\t\t})\n\t\t.join('\\n')\n}\n","import { generateDtsBody } from './generateEvmtsBodyDts.js'\nimport { formatAbi } from 'abitype'\n\n/**\n * @typedef {'cjs' | 'mjs' | 'ts' | 'dts'} ModuleType\n */\n\n/**\n * @param {import(\"../solc/resolveArtifactsSync.js\").Artifacts} artifacts\n * @param {ModuleType} moduleType\n * @returns {string}\n */\nexport const generateEvmtsBody = (artifacts, moduleType) => {\n\tif (moduleType === 'dts') {\n\t\treturn generateDtsBody(artifacts)\n\t}\n\treturn Object.entries(artifacts)\n\t\t.flatMap(([contractName, { abi, userdoc = {} }]) => {\n\t\t\tconst contract = JSON.stringify({\n\t\t\t\tname: contractName,\n\t\t\t\thumanReadableAbi: formatAbi(abi),\n\t\t\t})\n\n\t\t\tconst natspec = Object.entries(userdoc.methods ?? {}).map(\n\t\t\t\t([method, { notice }]) => ` * @property ${method} ${notice}`,\n\t\t\t)\n\t\t\tif (userdoc.notice) {\n\t\t\t\tnatspec.unshift(` * ${userdoc.notice}`)\n\t\t\t}\n\t\t\tif (natspec.length) {\n\t\t\t\tnatspec.unshift('/**')\n\t\t\t\tnatspec.push(' */')\n\t\t\t}\n\t\t\tif (moduleType === 'cjs') {\n\t\t\t\treturn [\n\t\t\t\t\t`const _${contractName} = ${contract}`,\n\t\t\t\t\t...natspec,\n\t\t\t\t\t`module.exports.${contractName} = evmtsContractFactory(_${contractName})`,\n\t\t\t\t]\n\t\t\t}\n\n\t\t\tif (moduleType === 'ts') {\n\t\t\t\treturn [\n\t\t\t\t\t`const _${contractName} = ${contract} as const`,\n\t\t\t\t\t...natspec,\n\t\t\t\t\t`export const ${contractName} = evmtsContractFactory(_${contractName})`,\n\t\t\t\t]\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t`const _${contractName} = ${contract}`,\n\t\t\t\t...natspec,\n\t\t\t\t`export const ${contractName} = evmtsContractFactory(_${contractName})`,\n\t\t\t]\n\t\t})\n\t\t.join('\\n')\n}\n","import { generateEvmtsBody } from './generateEvmtsBody.js'\n\n/**\n * Generates the runtime code for the given artifacts.\n * @param {import(\"../solc/resolveArtifactsSync.js\").Artifacts} artifacts\n * @param {'cjs' | 'mjs' | 'ts'} moduleType\n * @param {import(\"../types.js\").Logger} logger\n * @returns {Promise<string>}\n */\nexport const generateRuntime = async (artifacts, moduleType, logger) => {\n\tif (artifacts) {\n\t\tconst evmtsImports =\n\t\t\tmoduleType !== 'cjs'\n\t\t\t\t? `import { evmtsContractFactory } from '@evmts/core'`\n\t\t\t\t: `const { evmtsContractFactory } = require('@evmts/core')`\n\t\tconst evmtsBody = generateEvmtsBody(artifacts, moduleType)\n\t\treturn [evmtsImports, evmtsBody].join('\\n')\n\t}\n\tlogger.warn('No artifacts found, skipping runtime generation')\n\treturn ''\n}\n","import { generateEvmtsBody } from './generateEvmtsBody.js'\n\n/**\n * @param {import(\"../solc/resolveArtifactsSync.js\").Artifacts} artifacts\n * @param {'cjs' | 'mjs' | 'ts' | 'dts'} moduleType\n * @param {import(\"../types.js\").Logger} logger\n * @returns {string}\n */\nexport const generateRuntimeSync = (artifacts, moduleType, logger) => {\n\tif (!artifacts || Object.keys(artifacts).length === 0) {\n\t\tlogger.warn('No artifacts found, skipping runtime generation')\n\t\treturn ''\n\t}\n\t/**\n\t * @type {string}\n\t */\n\tlet evmtsImports\n\tif (moduleType === 'cjs') {\n\t\tevmtsImports = `const { evmtsContractFactory } = require('@evmts/core')`\n\t} else if (moduleType === 'dts') {\n\t\tevmtsImports = `import { EvmtsContract } from '@evmts/core'`\n\t} else if (moduleType === 'ts' || moduleType === 'mjs') {\n\t\tevmtsImports = `import { evmtsContractFactory } from '@evmts/core'`\n\t} else {\n\t\tthrow new Error(`Unknown module type: ${moduleType}`)\n\t}\n\tconst evmtsBody = generateEvmtsBody(artifacts, moduleType)\n\treturn [evmtsImports, evmtsBody].join('\\n')\n}\n","/**\n * Check if import path is local\n * @param {string} importPath\n * @returns {boolean}\n */\nexport const isImportLocal = (importPath) => {\n\treturn importPath.startsWith('.')\n}\n","/**\n * Formats a path to be used in the contract loader\n * @param {string} contractPath - The path to the contract\n * @returns {string} - The formatted path\n */\nexport const formatPath = (contractPath) => {\n\treturn contractPath.replace(/\\\\/g, '/')\n}\n","/**\n * Asserts an invariant in a typesafe way\n * @param {boolean} condition - The condition to assert\n * @param {string} message - The message to display if the condition is false\n * @throws {Error} Throws an error if the condition is false\n */\nexport function invariant(condition, message) {\n\tif (!condition) {\n\t\tthrow new Error(message)\n\t}\n}\n","import { Effect } from 'effect'\nimport resolve from 'resolve'\n\n/**\n * import resolve from 'resolve wrapped in an effect\n * @param {string} filePath\n * @param {string} basedir\n * @param {import(\"../types.js\").FileAccessObject} fao\n * @param {import(\"../types.js\").Logger} logger\n * @returns {Effect.Effect<never, Error, string>}\n */\nexport const resolveEffect = (filePath, basedir, fao, logger) => {\n\treturn Effect.async((resume) => {\n\t\tresolve(\n\t\t\tfilePath,\n\t\t\t{\n\t\t\t\tbasedir,\n\t\t\t\treadFile: (file, cb) => {\n\t\t\t\t\tfao\n\t\t\t\t\t\t.readFile(file, 'utf8')\n\t\t\t\t\t\t.then((fileContent) => {\n\t\t\t\t\t\t\tcb(null, fileContent)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\tlogger.error(e)\n\t\t\t\t\t\t\tlogger.error('Error reading file')\n\t\t\t\t\t\t\tcb(e)\n\t\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tisFile: (file, cb) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcb(null, fao.existsSync(file))\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcb(/** @type Error */ (e))\n\t\t\t\t\t\tlogger.error(/** @type any */ (e))\n\t\t\t\t\t\tlogger.error(`Error checking if isFile ${file}`)\n\t\t\t\t\t\tresume(Effect.fail(/** @type Error */ (e))) // resume with a failure effect when error occurs\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t(err, res) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.error(/** @type any */ (err))\n\t\t\t\t\tlogger.error(`There was an error resolving ${filePath}`)\n\t\t\t\t\tresume(Effect.fail(err)) // resume with a failure effect when error occurs\n\t\t\t\t} else {\n\t\t\t\t\tresume(Effect.succeed(/** @type string */ (res))) // resume with a success effect when the operation succeeds\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t})\n}\n","import { formatPath } from '../utils/formatPath.js'\nimport { isImportLocal } from '../utils/isImportLocal.js'\nimport * as path from 'path'\nimport resolve from 'resolve'\n\n/**\n * Resolve import statement to absolute file path\n *\n * @param {string} importPath import statement in *.sol contract\n * @param {string} absolutePath absolute path to the contract\n * @param {Record<string, string>} remappings remappings from the config\n * @param {ReadonlyArray<string>} libs libs from the config\n * @returns {string} absolute path to the imported file\n */\nexport const resolveImportPath = (\n\tabsolutePath,\n\timportPath,\n\tremappings,\n\tlibs,\n) => {\n\t// Foundry remappings\n\tfor (const [key, value] of Object.entries(remappings)) {\n\t\tif (importPath.startsWith(key)) {\n\t\t\treturn formatPath(path.resolve(importPath.replace(key, value)))\n\t\t}\n\t}\n\t// Local import \"./LocalContract.sol\"\n\tif (isImportLocal(importPath)) {\n\t\treturn formatPath(path.resolve(path.dirname(absolutePath), importPath))\n\t} /*else if (project !== undefined && project !== null) {*/\n\t// try resolving with node resolution\n\ttry {\n\t\treturn resolve.sync(importPath, {\n\t\t\tbasedir: path.dirname(absolutePath),\n\t\t\tpaths: libs,\n\t\t})\n\t} catch (e) {\n\t\tconsole.error(\n\t\t\t`Could not resolve import ${importPath} from ${absolutePath}`,\n\t\t\te,\n\t\t)\n\t\treturn importPath\n\t}\n}\n","import { formatPath } from '../utils/formatPath.js'\nimport { isImportLocal } from '../utils/isImportLocal.js'\nimport * as path from 'path'\n\n/**\n * @param {string} absolutePath\n * @param {string} code\n * @returns {ReadonlyArray<string>}\n */\nexport const resolveImports = (absolutePath, code) => {\n\tconst imports = /** @type Array<string> */ ([])\n\tconst importRegEx = /^\\s?import\\s+[^'\"]*['\"](.*)['\"]\\s*/gm\n\tlet foundImport = importRegEx.exec(code)\n\twhile (foundImport != null) {\n\t\tconst importPath = foundImport[1]\n\t\tif (!importPath) {\n\t\t\tthrow new Error('expected import path to exist')\n\t\t}\n\t\tif (isImportLocal(importPath)) {\n\t\t\tconst importFullPath = formatPath(\n\t\t\t\tpath.resolve(path.dirname(absolutePath), importPath),\n\t\t\t)\n\t\t\timports.push(importFullPath)\n\t\t} else {\n\t\t\timports.push(importPath)\n\t\t}\n\t\tfoundImport = importRegEx.exec(code)\n\t}\n\treturn imports\n}\n","import { invariant } from '../utils/invariant.js'\nimport { resolveImportPath } from './resolveImportPath.js'\nimport { resolveImports } from './resolveImports.js'\n\n/**\n * Creates a module from the given module information.\n * This includes resolving all imports and creating a dependency graph.\n *\n * Currently it modifies the source code in place which causes the ast to not match the source code.\n * This complexity leaks to the typescript lsp which has to account for this\n * Ideally we refactor this to not need to modify source code in place\n * Doing this hurts our ability to control the import graph and make it use node resolution though\n * See foundry that is alergic to using npm\n * Doing it this way for now is easier but for sure a leaky abstraction\n * @param {string} absolutePath\n * @param {string} rawCode\n * @param {Record<string, string>} remappings\n * @param {ReadonlyArray<string>} libs\n * @param {import(\"../types.js\").FileAccessObject} fao\n * @returns {Promise<import(\"../types.js\").ModuleInfo>}\n */\nexport const moduleFactory = async (\n\tabsolutePath,\n\trawCode,\n\tremappings,\n\tlibs,\n\tfao,\n) => {\n\tconst stack = [{ absolutePath, rawCode }]\n\tconst modules =\n\t\t/** @type{Map<string, import(\"../types.js\").ModuleInfo>} */\n\t\t(new Map())\n\n\twhile (stack.length) {\n\t\tconst nextItem = stack.pop()\n\t\tinvariant(nextItem, 'Module should exist')\n\t\tconst { absolutePath, rawCode } = nextItem\n\n\t\tif (modules.has(absolutePath)) continue\n\n\t\tconst importedIds = resolveImports(absolutePath, rawCode).map((paths) =>\n\t\t\tresolveImportPath(absolutePath, paths, remappings, libs),\n\t\t)\n\n\t\tconst importRegEx = /(^\\s?import\\s+[^'\"]*['\"])(.*)(['\"]\\s*)/gm\n\t\tconst code = importedIds.reduce((code, importedId) => {\n\t\t\tconsole.log({ importedId })\n\t\t\tconst depImportAbsolutePath = resolveImportPath(\n\t\t\t\tabsolutePath,\n\t\t\t\timportedId,\n\t\t\t\tremappings,\n\t\t\t\tlibs,\n\t\t\t)\n\t\t\treturn code.replace(importRegEx, (match, p1, p2, p3) => {\n\t\t\t\tconst resolvedPath = resolveImportPath(\n\t\t\t\t\tabsolutePath,\n\t\t\t\t\tp2,\n\t\t\t\t\tremappings,\n\t\t\t\t\tlibs,\n\t\t\t\t)\n\t\t\t\tif (resolvedPath === importedId) {\n\t\t\t\t\treturn `${p1}${depImportAbsolutePath}${p3}`\n\t\t\t\t} else {\n\t\t\t\t\treturn match\n\t\t\t\t}\n\t\t\t})\n\t\t}, rawCode)\n\n\t\tmodules.set(absolutePath, {\n\t\t\tid: absolutePath,\n\t\t\trawCode,\n\t\t\tcode,\n\t\t\timportedIds,\n\t\t\tresolutions: [],\n\t\t})\n\n\t\tfor (const importedId of importedIds) {\n\t\t\tconst depImportAbsolutePath = resolveImportPath(\n\t\t\t\tabsolutePath,\n\t\t\t\timportedId,\n\t\t\t\tremappings,\n\t\t\t\tlibs,\n\t\t\t)\n\t\t\tconst depRawCode = await fao.readFile(depImportAbsolutePath, 'utf8')\n\n\t\t\tstack.push({ absolutePath: depImportAbsolutePath, rawCode: depRawCode })\n\t\t}\n\t}\n\n\tfor (const [_, m] of modules.entries()) {\n\t\tconst { importedIds } = m\n\t\tm.resolutions = []\n\t\timportedIds.forEach((importedId) => {\n\t\t\tconst resolution = modules.get(importedId)\n\t\t\tinvariant(resolution, `resolution for ${importedId} not found`)\n\t\t\tm.resolutions.push(resolution)\n\t\t})\n\t}\n\n\tconst out = modules.get(absolutePath)\n\tif (!out) {\n\t\tthrow new Error('No module found')\n\t}\n\treturn out\n}\n","// @ts-ignore\nimport solc from 'solc'\n\n/**\n * @type {''}\n */\nexport const fileLevelOption = ''\n\n/**\n * Typesafe wrapper around solc.compile\n * @param {import(\"./solcTypes.js\").SolcInputDescription} input\n * @returns {import(\"./solcTypes.js\").SolcOutput}\n */\nexport const solcCompile = (input) => {\n\treturn JSON.parse(solc.compile(JSON.stringify(input)))\n}\n","import { invariant, resolveEffect } from '../utils/index.js'\nimport { moduleFactory } from './moduleFactory.js'\nimport { solcCompile } from './solc.js'\nimport { Effect } from 'effect'\n\n/**\n * Compile the Solidity contract and return its ABI.\n *\n * @template TIncludeAsts\n * @param {string} filePath\n * @param {string} basedir\n * @param {import('@evmts/config').ResolvedCompilerConfig} config\n * @param {TIncludeAsts} includeAst\n * @param {import('../types.js').FileAccessObject} fao\n * @param {import('../types.js').Logger} logger\n * @param {import('../createCache.js').Cache} [cache]\n * @returns {Promise<import('../types.js').CompiledContracts<TIncludeAsts>>}\n * @example\n * const { artifacts, modules } = await compileContract(\n *   './contracts/MyContract.sol',\n *   __dirname,\n *   config,\n *   true,\n *   await import('fs'),\n *   logger,\n *   cache,\n * )\n */\nexport const compileContract = async (\n\tfilePath,\n\tbasedir,\n\tconfig,\n\tincludeAst,\n\tfao,\n\tlogger,\n\tcache,\n) => {\n\tconst entryModule = await moduleFactory(\n\t\tfilePath,\n\t\tawait fao\n\t\t\t.readFile(\n\t\t\t\tawait Effect.runPromise(resolveEffect(filePath, basedir, fao, logger)),\n\t\t\t\t'utf8',\n\t\t\t)\n\t\t\t.then((code) => {\n\t\t\t\treturn code\n\t\t\t}),\n\t\tconfig.remappings,\n\t\tconfig.libs,\n\t\tfao,\n\t)\n\n\t/**\n\t * @type {Object.<string, import('../types.js').ModuleInfo>}\n\t */\n\tconst modules = {}\n\n\tconst stack = [entryModule]\n\twhile (stack.length !== 0) {\n\t\tconst m = stack.pop()\n\t\tinvariant(m, 'Module should exist')\n\t\tif (m.id in modules) {\n\t\t\tcontinue\n\t\t}\n\t\tmodules[m.id] = m\n\t\tfor (const dep of m.resolutions) {\n\t\t\tstack.push(dep)\n\t\t}\n\t}\n\n\tconst sources = Object.fromEntries(\n\t\tObject.entries(modules).map(([id, module]) => {\n\t\t\treturn [\n\t\t\t\tid,\n\t\t\t\t{\n\t\t\t\t\tcontent:\n\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t(module.code),\n\t\t\t\t},\n\t\t\t]\n\t\t}),\n\t)\n\n\tconst emptyString = ''\n\t/**\n\t * @type {import('./solcTypes.js').SolcInputDescription}\n\t */\n\tconst input = {\n\t\tlanguage: 'Solidity',\n\t\tsources,\n\t\tsettings: {\n\t\t\toutputSelection: {\n\t\t\t\t'*': {\n\t\t\t\t\t'*': ['abi', 'userdoc'],\n\t\t\t\t\t...(includeAst ? { [emptyString]: ['ast'] } : {}),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t/**\n\t * @type {import('./solcTypes.js').SolcOutput}\n\t */\n\tconst output = cache?.isCached(entryModule.id, sources)\n\t\t? cache.read(entryModule.id)\n\t\t: solcCompile(input)\n\n\tcache?.write(entryModule.id, output)\n\n\tconst warnings = output?.errors?.filter(({ type }) => type === 'Warning')\n\tconst isErrors = (output?.errors?.length ?? 0) > (warnings?.length ?? 0)\n\n\tif (isErrors) {\n\t\tlogger.error('Compilation errors:')\n\t\tlogger.error(/** @type {any} */ (output?.errors))\n\t\tthrow new Error('Compilation failed')\n\t}\n\tif (warnings?.length) {\n\t\tlogger.warn(/** @type {any} */ (warnings))\n\t\tlogger.warn('Compilation warnings:')\n\t}\n\n\tif (includeAst) {\n\t\tconst asts = Object.fromEntries(\n\t\t\tObject.entries(output.sources).map(([id, source]) => {\n\t\t\t\treturn [id, source.ast]\n\t\t\t}),\n\t\t)\n\t\treturn {\n\t\t\tartifacts: output.contracts[entryModule.id],\n\t\t\tmodules: /** @type {any} */ (modules),\n\t\t\tasts: /** @type {any} */ (asts),\n\t\t\tsolcInput: input,\n\t\t\tsolcOutput: output,\n\t\t}\n\t}\n\treturn {\n\t\tartifacts: output.contracts[entryModule.id],\n\t\tmodules: /** @type {any} */ (modules),\n\t\tasts: /** @type {any} */ (undefined),\n\t\tsolcInput: input,\n\t\tsolcOutput: output,\n\t}\n}\n","import { compileContract } from './compileContracts.js'\n\n/**\n * Resolves artifacts with solc asyncronously\n * @type {import('./resolveArtifactsSync.js').ResolveArtifactsSync}\n */\nexport const resolveArtifacts = async (\n\tsolFile,\n\tbasedir,\n\tlogger,\n\tconfig,\n\tincludeAst,\n\tfao,\n\tcache,\n) => {\n\tif (!solFile.endsWith('.sol')) {\n\t\tthrow new Error('Not a solidity file')\n\t}\n\tconst { artifacts, modules, asts, solcInput, solcOutput } =\n\t\tawait compileContract(\n\t\t\tsolFile,\n\t\t\tbasedir,\n\t\t\tconfig,\n\t\t\tincludeAst,\n\t\t\tfao,\n\t\t\tlogger,\n\t\t\tcache,\n\t\t)\n\n\tif (!artifacts) {\n\t\tlogger.error(`Compilation failed for ${solFile}`)\n\t\tthrow new Error('Compilation failed')\n\t}\n\n\treturn {\n\t\tartifacts: Object.fromEntries(\n\t\t\tObject.entries(artifacts).map(([contractName, contract]) => {\n\t\t\t\treturn [\n\t\t\t\t\tcontractName,\n\t\t\t\t\t{ contractName, abi: contract.abi, userdoc: contract.userdoc },\n\t\t\t\t]\n\t\t\t}),\n\t\t),\n\t\tmodules,\n\t\tasts,\n\t\tsolcInput,\n\t\tsolcOutput,\n\t}\n}\n","import { invariant } from '../utils/invariant.js'\nimport { resolveImportPath } from './resolveImportPath.js'\nimport { resolveImports } from './resolveImports.js'\n\n/**\n * Creates a module from the given module information.\n * This includes resolving all imports and creating a dependency graph.\n *\n * Currently it modifies the source code in place which causes the ast to not match the source code.\n * This complexity leaks to the typescript lsp which has to account for this\n * Ideally we refactor this to not need to modify source code in place\n * Doing this hurts our ability to control the import graph and make it use node resolution though\n * See foundry that is alergic to using npm\n * Doing it this way for now is easier but for sure a leaky abstraction\n * @param {string} absolutePath\n * @param {string} rawCode\n * @param {Record<string, string>} remappings\n * @param {ReadonlyArray<string>} libs\n * @param {import(\"../types.js\").FileAccessObject} fao\n * @returns {import(\"../types.js\").ModuleInfo}\n */\nexport const moduleFactorySync = (\n\tabsolutePath,\n\trawCode,\n\tremappings,\n\tlibs,\n\tfao,\n) => {\n\tconst stack = [{ absolutePath, rawCode }]\n\tconst modules = /** @type {Map<string, import(\"../types.js\").ModuleInfo>} */ (\n\t\tnew Map()\n\t)\n\n\twhile (stack.length) {\n\t\tconst nextItem = stack.pop()\n\t\tinvariant(nextItem, 'Module should exist')\n\t\tconst { absolutePath, rawCode } = nextItem\n\n\t\tif (modules.has(absolutePath)) continue\n\n\t\tconst importedIds = resolveImports(absolutePath, rawCode).map((paths) =>\n\t\t\tresolveImportPath(absolutePath, paths, remappings, libs),\n\t\t)\n\n\t\tconst importRegEx = /(^\\s?import\\s+[^'\"]*['\"])(.*)(['\"]\\s*)/gm\n\t\tconst code = importedIds.reduce((code, importedId) => {\n\t\t\tconst depImportAbsolutePath = resolveImportPath(\n\t\t\t\tabsolutePath,\n\t\t\t\timportedId,\n\t\t\t\tremappings,\n\t\t\t\tlibs,\n\t\t\t)\n\t\t\treturn code.replace(importRegEx, (match, p1, p2, p3) => {\n\t\t\t\tconst resolvedPath = resolveImportPath(\n\t\t\t\t\tabsolutePath,\n\t\t\t\t\tp2,\n\t\t\t\t\tremappings,\n\t\t\t\t\tlibs,\n\t\t\t\t)\n\t\t\t\tif (resolvedPath === importedId) {\n\t\t\t\t\treturn `${p1}${depImportAbsolutePath}${p3}`\n\t\t\t\t} else {\n\t\t\t\t\treturn match\n\t\t\t\t}\n\t\t\t})\n\t\t}, rawCode)\n\n\t\tmodules.set(absolutePath, {\n\t\t\tid: absolutePath,\n\t\t\trawCode,\n\t\t\tcode,\n\t\t\timportedIds,\n\t\t\tresolutions: [],\n\t\t})\n\n\t\timportedIds.forEach((importedId) => {\n\t\t\tconst depImportAbsolutePath = resolveImportPath(\n\t\t\t\tabsolutePath,\n\t\t\t\timportedId,\n\t\t\t\tremappings,\n\t\t\t\tlibs,\n\t\t\t)\n\t\t\tconst depRawCode = fao.readFileSync(depImportAbsolutePath, 'utf8')\n\n\t\t\tstack.push({ absolutePath: depImportAbsolutePath, rawCode: depRawCode })\n\t\t})\n\t}\n\n\tfor (const [_, m] of modules.entries()) {\n\t\tconst { importedIds } = m\n\t\tm.resolutions = []\n\t\timportedIds.forEach((importedId) => {\n\t\t\tconst resolution = modules.get(importedId)\n\t\t\tinvariant(resolution, `resolution for ${importedId} not found`)\n\t\t\tm.resolutions.push(resolution)\n\t\t})\n\t}\n\n\treturn /** @type import(\"../types.js\").ModuleInfo */ (\n\t\tmodules.get(absolutePath)\n\t)\n}\n","import { invariant } from '../utils/invariant.js'\nimport { moduleFactorySync } from './moduleFactorySync.js'\nimport * as solc from './solc.js'\nimport resolve from 'resolve'\n\n/**\n * Compile the Solidity contract and return its ABI.\n *\n * @template TIncludeAsts\n * @param {string} filePath\n * @param {string} basedir\n * @param {import('@evmts/config').ResolvedCompilerConfig} config\n * @param {TIncludeAsts} includeAst\n * @param {import('../types.js').FileAccessObject} fao\n * @param {import('../types.js').Logger} logger\n * @param {import('../createCache.js').Cache} [cache]\n * @returns {import('../types.js').CompiledContracts}\n * @example\n * const { artifacts, modules } = compileContractSync(\n *  './contracts/MyContract.sol',\n *  __dirname,\n *  config,\n *  true,\n *  await import('fs'),\n *  logger,\n *  cache,\n *  )\n */\nexport function compileContractSync(\n\tfilePath,\n\tbasedir,\n\tconfig,\n\tincludeAst,\n\tfao,\n\tlogger,\n\tcache,\n) {\n\tconst entryModule = moduleFactorySync(\n\t\tfilePath,\n\t\tfao.readFileSync(\n\t\t\tresolve.sync(filePath, {\n\t\t\t\tbasedir,\n\t\t\t\treadFileSync: (file) => fao.readFileSync(file, 'utf8'),\n\t\t\t\tisFile: fao.existsSync,\n\t\t\t}),\n\t\t\t'utf8',\n\t\t),\n\t\tconfig.remappings,\n\t\tconfig.libs,\n\t\tfao,\n\t)\n\n\t/** @type {Record<string, import('../types.js').ModuleInfo>} */\n\tconst modules = {}\n\n\tconst stack = [entryModule]\n\twhile (stack.length !== 0) {\n\t\tconst m = stack.pop()\n\t\tinvariant(m, 'Module should exist')\n\t\tif (m.id in modules) {\n\t\t\tcontinue\n\t\t}\n\t\tmodules[m.id] = m\n\t\tfor (const dep of m.resolutions) {\n\t\t\tstack.push(dep)\n\t\t}\n\t}\n\n\tconst sources = Object.fromEntries(\n\t\tObject.entries(modules).map(([id, module]) => {\n\t\t\tconst code =\n\t\t\t\t/** @type {string} */\n\t\t\t\t(module.code)\n\t\t\treturn [id, { content: code }]\n\t\t}),\n\t)\n\n\t/**\n\t * @type {import('./solcTypes.js').SolcInputDescription}\n\t */\n\tconst solcInput = {\n\t\tlanguage: 'Solidity',\n\t\tsources,\n\t\tsettings: {\n\t\t\toutputSelection: {\n\t\t\t\t'*': {\n\t\t\t\t\t'*': ['abi', 'userdoc'],\n\t\t\t\t\t...(includeAst ? { '': ['ast'] } : {}),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\t/**\n\t * @type {import('./solcTypes.js').SolcOutput}\n\t */\n\tconst solcOutput = cache?.isCached(entryModule.id, sources)\n\t\t? cache.read(entryModule.id)\n\t\t: solc.solcCompile(solcInput)\n\n\tcache?.write(entryModule.id, solcOutput)\n\n\tconst warnings = solcOutput?.errors?.filter(({ type }) => type === 'Warning')\n\tconst isErrors = (solcOutput?.errors?.length ?? 0) > (warnings?.length ?? 0)\n\n\tif (isErrors) {\n\t\tlogger.error('Compilation errors:', /** @type {any}*/ (solcOutput?.errors))\n\t\tthrow new Error('Compilation failed')\n\t}\n\tif (warnings?.length) {\n\t\tlogger.warn('Compilation warnings:', /** @type {any}*/ (solcOutput?.errors))\n\t}\n\n\tif (includeAst) {\n\t\tconst asts = Object.fromEntries(\n\t\t\tObject.entries(solcOutput.sources).map(([id, source]) => {\n\t\t\t\treturn [id, source.ast]\n\t\t\t}),\n\t\t)\n\t\treturn {\n\t\t\tartifacts: solcOutput.contracts[entryModule.id],\n\t\t\tmodules,\n\t\t\tasts,\n\t\t\tsolcInput,\n\t\t\tsolcOutput: solcOutput,\n\t\t}\n\t}\n\treturn {\n\t\tartifacts: solcOutput.contracts[entryModule.id],\n\t\tmodules,\n\t\tasts: undefined,\n\t\tsolcInput: solcInput,\n\t\tsolcOutput: solcOutput,\n\t}\n}\n","import { compileContractSync } from './compileContractsSync.js'\n\n/**\n * @type {import('./resolveArtifactsSync.js').ResolveArtifactsSync}\n */\nexport const resolveArtifactsSync = (\n\tsolFile,\n\tbasedir,\n\tlogger,\n\tconfig,\n\tincludeAst,\n\tfao,\n\tcache,\n) => {\n\tif (!solFile.endsWith('.sol')) {\n\t\tthrow new Error('Not a solidity file')\n\t}\n\tconst { artifacts, modules, asts, solcInput, solcOutput } =\n\t\tcompileContractSync(\n\t\t\tsolFile,\n\t\t\tbasedir,\n\t\t\tconfig,\n\t\t\tincludeAst,\n\t\t\tfao,\n\t\t\tlogger,\n\t\t\tcache,\n\t\t)\n\n\tif (!artifacts) {\n\t\tlogger.error(`Compilation failed for ${solFile}`)\n\t\tthrow new Error('Compilation failed')\n\t}\n\n\treturn {\n\t\tartifacts: Object.fromEntries(\n\t\t\tObject.entries(artifacts).map(([contractName, contract]) => {\n\t\t\t\treturn [\n\t\t\t\t\tcontractName,\n\t\t\t\t\t{ contractName, abi: contract.abi, userdoc: contract.userdoc },\n\t\t\t\t]\n\t\t\t}),\n\t\t),\n\t\tmodules,\n\t\tasts,\n\t\tsolcInput,\n\t\tsolcOutput,\n\t}\n}\n","import { generateDtsBody } from './runtime/generateEvmtsBodyDts.js'\nimport { generateRuntime } from './runtime/generateRuntime.js'\nimport { generateRuntimeSync } from './runtime/generateRuntimeSync.js'\nimport { resolveArtifacts, resolveArtifactsSync } from './solc/index.js'\n// TODO wrap this in a typesafe version\n// @ts-ignore\nimport solc from 'solc'\n\n/**\n * @type {import('./types.js').Bundler}\n */\nexport const bundler = (config, logger, fao, cache) => {\n\treturn {\n\t\tname: bundler.name,\n\t\tconfig,\n\t\tresolveDts: async (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, artifacts, modules, asts } =\n\t\t\t\t\tawait resolveArtifacts(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tif (artifacts) {\n\t\t\t\t\tconst evmtsImports = `import { EvmtsContract } from '@evmts/core'`\n\t\t\t\t\tconst evmtsBody = generateDtsBody(artifacts)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsolcInput,\n\t\t\t\t\t\tsolcOutput,\n\t\t\t\t\t\tasts,\n\t\t\t\t\t\tcode: [evmtsImports, evmtsBody].join('\\n'),\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { solcInput, solcOutput, code: '', modules, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin generating .dts')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveDtsSync: (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { artifacts, modules, asts, solcInput, solcOutput } =\n\t\t\t\t\tresolveArtifactsSync(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tif (artifacts) {\n\t\t\t\t\tconst evmtsImports = `import { EvmtsContract } from '@evmts/core'`\n\t\t\t\t\tconst evmtsBody = generateDtsBody(artifacts)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsolcInput,\n\t\t\t\t\t\tsolcOutput,\n\t\t\t\t\t\tasts,\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\tcode: [evmtsImports, evmtsBody].join('\\n'),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { modules, code: '', asts, solcInput, solcOutput }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .dts')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveTsModuleSync: (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tresolveArtifactsSync(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = generateRuntimeSync(artifacts, 'ts', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .ts')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveTsModule: async (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tawait resolveArtifacts(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = await generateRuntime(artifacts, 'ts', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .ts')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveCjsModuleSync: (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tresolveArtifactsSync(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = generateRuntimeSync(artifacts, 'cjs', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .cjs')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveCjsModule: async (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tawait resolveArtifacts(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = await generateRuntime(artifacts, 'cjs', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .cjs')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveEsmModuleSync: (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tresolveArtifactsSync(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = generateRuntimeSync(artifacts, 'mjs', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .mjs')\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t\tresolveEsmModule: async (modulePath, basedir, includeAst) => {\n\t\t\ttry {\n\t\t\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\t\t\tawait resolveArtifacts(\n\t\t\t\t\t\tmodulePath,\n\t\t\t\t\t\tbasedir,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tincludeAst,\n\t\t\t\t\t\tfao,\n\t\t\t\t\t\tcache,\n\t\t\t\t\t)\n\t\t\t\tconst code = await generateRuntime(artifacts, 'mjs', logger)\n\t\t\t\treturn { code, modules, solcInput, solcOutput, asts }\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(/** @type {any} */ (e))\n\t\t\t\tlogger.error('there was an error in evmts plugin resolving .mjs')\n\t\t\t\tthrow e\n\t\t\t}\n\t\t},\n\t}\n}\n","/**\n * @typedef {import('./createCache.js').Cache} Cache\n\n/**\n * @type {import('./createCache.js').CreateCache}\n */\nexport const createCache = (logger) => {\n\t/**\n\t * @type {import('./createCache.js').CacheObject}\n\t */\n\tconst cache = {}\n\n\treturn {\n\t\twrite: (entryModuleId, compiledContracts) => {\n\t\t\tcache[entryModuleId] = compiledContracts\n\t\t},\n\t\tread: (entryModuleId) => {\n\t\t\tconst out = cache[entryModuleId]\n\t\t\tif (!out) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cache miss for ${entryModuleId}. Try calling isCached first`,\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn out\n\t\t},\n\t\tisCached: (entryModuleId, sources) => {\n\t\t\tconst previousCachedItem = cache[entryModuleId]\n\t\t\tif (!previousCachedItem) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tconst { sources: previousSources } = previousCachedItem\n\t\t\tif (Object.keys(sources).length !== Object.keys(previousSources).length) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor (const [key, newSource] of Object.entries(sources)) {\n\t\t\t\tconst oldSource = previousSources[key]\n\t\t\t\tif (!oldSource) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif (!('content' in oldSource) || !('content' in newSource)) {\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'Unexpected error: Unable to use cache because content is undefined. Continuing without cache.',\n\t\t\t\t\t)\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif (oldSource.content !== newSource.content) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t},\n\t}\n}\n","import { bundler } from './bundler.js'\nimport { createCache } from './createCache.js'\nimport { loadConfig } from '@evmts/config'\nimport { runSync } from 'effect/Effect'\nimport { existsSync, readFileSync } from 'fs'\nimport { readFile } from 'fs/promises'\nimport { createRequire } from 'module'\nimport { createUnplugin } from 'unplugin'\nimport { z } from 'zod'\n\nconst compilerOptionValidator = z\n\t.enum(['solc', 'foundry'])\n\t.default('solc')\n\t.describe('compiler to use.  Defaults to solc')\n\n/**\n * @typedef {import(\"zod\").infer<typeof compilerOptionValidator>} CompilerOption\n */\n\nconst bundlers = {\n\tsolc: bundler,\n}\n\n/**\n * @type {import(\"unplugin\").UnpluginFactory<{compiler?: CompilerOption } | undefined, false>}\n */\nexport const unpluginFn = (options = {}) => {\n\t/**\n\t * @type {import(\"@evmts/config\").ResolvedCompilerConfig}\n\t */\n\tlet config\n\n\t// for current release we will hardcode this to solc\n\tconst parsedCompilerOption = compilerOptionValidator.safeParse(\n\t\toptions.compiler,\n\t)\n\tif (!parsedCompilerOption.success) {\n\t\tthrow new Error(\n\t\t\t`Invalid compiler option: ${options.compiler}.  Valid options are 'solc' and 'foundry'`,\n\t\t)\n\t}\n\tconst compilerOption = parsedCompilerOption.data\n\n\tif (compilerOption === 'foundry') {\n\t\tthrow new Error(\n\t\t\t'We have abandoned the foundry option despite supporting it in the past. Please use solc instead. Foundry will be added back as a compiler at a later time.',\n\t\t)\n\t}\n\tconst bundler = bundlers[compilerOption]\n\t/**\n\t * @type {ReturnType<typeof bundler>}\n\t */\n\tlet moduleResolver\n\n\t/**\n\t * @type {import(\"./types.js\").FileAccessObject}\n\t */\n\tconst fao = {\n\t\texistsSync,\n\t\treadFile,\n\t\treadFileSync,\n\t}\n\n\tconst solcCache = createCache(console)\n\n\treturn {\n\t\tname: '@evmts/rollup-plugin',\n\t\tasync buildStart() {\n\t\t\tconfig = runSync(loadConfig(process.cwd()))\n\t\t\tmoduleResolver = bundler(config, console, fao, solcCache)\n\t\t\tthis.addWatchFile('./tsconfig.json')\n\t\t},\n\t\tasync resolveId(id, importer, options) {\n\t\t\t// to handle the case where the import is coming from a node_module or a different workspace\n\t\t\t// we need to always point @evmts/core to the local version\n\t\t\tif (\n\t\t\t\tid.startsWith('@evmts/core') &&\n\t\t\t\t!importer?.startsWith(process.cwd()) &&\n\t\t\t\t!importer?.includes('node_modules')\n\t\t\t) {\n\t\t\t\tconsole.log({ id, importer, options })\n\t\t\t\treturn createRequire(`${process.cwd()}/`).resolve('@evmts/core')\n\t\t\t}\n\t\t\treturn null\n\t\t},\n\t\tasync load(id) {\n\t\t\tif (!id.endsWith('.sol')) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (existsSync(`${id}.ts`)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (existsSync(`${id}.d.ts`)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst { code, modules } = await moduleResolver.resolveEsmModule(\n\t\t\t\tid,\n\t\t\t\tprocess.cwd(),\n\t\t\t\tfalse,\n\t\t\t)\n\t\t\tObject.values(modules).forEach((module) => {\n\t\t\t\tif (module.id.includes('node_modules')) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.addWatchFile(module.id)\n\t\t\t})\n\t\t\treturn code\n\t\t},\n\t\t...{ version: '0.11.2' },\n\t}\n}\n\nconst evmtsUnplugin = createUnplugin(unpluginFn)\n\n// Hacks to make types portable\n// we should manually type these at some point\n\nexport const vitePluginEvmts = /** @type {typeof evmtsUnplugin.rollup} */ (\n\t/** @type {any} */ (evmtsUnplugin.vite)\n)\nexport const rollupPluginEvmts = evmtsUnplugin.rollup\nexport const esbuildPluginEvmts = evmtsUnplugin.esbuild\nexport const webpackPluginEvmts = /** @type {typeof evmtsUnplugin.rspack} */ (\n\tevmtsUnplugin.webpack\n)\n\nexport const rspackPluginEvmts = evmtsUnplugin.rspack\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,qBAA0B;AAMnB,IAAM,kBAAkB,CAAC,cAAc;AAC7C,SAAO,OAAO,QAAQ,SAAS,EAC7B,QAAQ,CAAC,CAAC,cAAc,EAAE,KAAK,UAAU,CAAC,EAAE,CAAC,MAAM;AACnD,UAAM,WAAW;AAAA,MAChB,MAAM;AAAA,MACN,sBAAkB,0BAAU,GAAG;AAAA,IAChC;AACA,UAAM,UAAU,OAAO,QAAQ,QAAQ,WAAW,CAAC,CAAC,EAAE;AAAA,MACrD,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,MAAM,gBAAgB,MAAM,IAAI,MAAM;AAAA,IAC3D;AACA,QAAI,QAAQ,QAAQ;AACnB,cAAQ,QAAQ,cAAc,QAAQ,MAAM,EAAE;AAAA,IAC/C;AACA,WAAO;AAAA,MACN,aAAa,YAAY,MAAM,KAAK;AAAA,QACnC,SAAS;AAAA,MACV,CAAC;AAAA,MACD,cAAc,YAAY,MAAM,KAAK;AAAA,QACpC;AAAA,MACD,CAAC;AAAA,MACD;AAAA,MACA,MAAM,YAAY;AAAA,MAClB,GAAG;AAAA,MACH;AAAA,MACA,gBAAgB,YAAY,+BAA+B,YAAY,gBAAgB,YAAY;AAAA,IACpG,EAAE,OAAO,OAAO;AAAA,EACjB,CAAC,EACA,KAAK,IAAI;AACZ;;;ACjCA,IAAAA,kBAA0B;AAWnB,IAAM,oBAAoB,CAAC,WAAW,eAAe;AAC3D,MAAI,eAAe,OAAO;AACzB,WAAO,gBAAgB,SAAS;AAAA,EACjC;AACA,SAAO,OAAO,QAAQ,SAAS,EAC7B,QAAQ,CAAC,CAAC,cAAc,EAAE,KAAK,UAAU,CAAC,EAAE,CAAC,MAAM;AACnD,UAAM,WAAW,KAAK,UAAU;AAAA,MAC/B,MAAM;AAAA,MACN,sBAAkB,2BAAU,GAAG;AAAA,IAChC,CAAC;AAED,UAAM,UAAU,OAAO,QAAQ,QAAQ,WAAW,CAAC,CAAC,EAAE;AAAA,MACrD,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,MAAM,gBAAgB,MAAM,IAAI,MAAM;AAAA,IAC3D;AACA,QAAI,QAAQ,QAAQ;AACnB,cAAQ,QAAQ,MAAM,QAAQ,MAAM,EAAE;AAAA,IACvC;AACA,QAAI,QAAQ,QAAQ;AACnB,cAAQ,QAAQ,KAAK;AACrB,cAAQ,KAAK,KAAK;AAAA,IACnB;AACA,QAAI,eAAe,OAAO;AACzB,aAAO;AAAA,QACN,UAAU,YAAY,MAAM,QAAQ;AAAA,QACpC,GAAG;AAAA,QACH,kBAAkB,YAAY,4BAA4B,YAAY;AAAA,MACvE;AAAA,IACD;AAEA,QAAI,eAAe,MAAM;AACxB,aAAO;AAAA,QACN,UAAU,YAAY,MAAM,QAAQ;AAAA,QACpC,GAAG;AAAA,QACH,gBAAgB,YAAY,4BAA4B,YAAY;AAAA,MACrE;AAAA,IACD;AAEA,WAAO;AAAA,MACN,UAAU,YAAY,MAAM,QAAQ;AAAA,MACpC,GAAG;AAAA,MACH,gBAAgB,YAAY,4BAA4B,YAAY;AAAA,IACrE;AAAA,EACD,CAAC,EACA,KAAK,IAAI;AACZ;;;AC/CO,IAAM,kBAAkB,OAAO,WAAW,YAAY,WAAW;AACvE,MAAI,WAAW;AACd,UAAM,eACL,eAAe,QACZ,uDACA;AACJ,UAAM,YAAY,kBAAkB,WAAW,UAAU;AACzD,WAAO,CAAC,cAAc,SAAS,EAAE,KAAK,IAAI;AAAA,EAC3C;AACA,SAAO,KAAK,iDAAiD;AAC7D,SAAO;AACR;;;ACZO,IAAM,sBAAsB,CAAC,WAAW,YAAY,WAAW;AACrE,MAAI,CAAC,aAAa,OAAO,KAAK,SAAS,EAAE,WAAW,GAAG;AACtD,WAAO,KAAK,iDAAiD;AAC7D,WAAO;AAAA,EACR;AAIA,MAAI;AACJ,MAAI,eAAe,OAAO;AACzB,mBAAe;AAAA,EAChB,WAAW,eAAe,OAAO;AAChC,mBAAe;AAAA,EAChB,WAAW,eAAe,QAAQ,eAAe,OAAO;AACvD,mBAAe;AAAA,EAChB,OAAO;AACN,UAAM,IAAI,MAAM,wBAAwB,UAAU,EAAE;AAAA,EACrD;AACA,QAAM,YAAY,kBAAkB,WAAW,UAAU;AACzD,SAAO,CAAC,cAAc,SAAS,EAAE,KAAK,IAAI;AAC3C;;;ACvBO,IAAM,gBAAgB,CAAC,eAAe;AAC5C,SAAO,WAAW,WAAW,GAAG;AACjC;;;ACFO,IAAM,aAAa,CAAC,iBAAiB;AAC3C,SAAO,aAAa,QAAQ,OAAO,GAAG;AACvC;;;ACDO,SAAS,UAAU,WAAW,SAAS;AAC7C,MAAI,CAAC,WAAW;AACf,UAAM,IAAI,MAAM,OAAO;AAAA,EACxB;AACD;;;ACVA,oBAAuB;AACvB,qBAAoB;AAUb,IAAM,gBAAgB,CAAC,UAAU,SAAS,KAAK,WAAW;AAChE,SAAO,qBAAO,MAAM,CAAC,WAAW;AAC/B,uBAAAC;AAAA,MACC;AAAA,MACA;AAAA,QACC;AAAA,QACA,UAAU,CAAC,MAAM,OAAO;AACvB,cACE,SAAS,MAAM,MAAM,EACrB,KAAK,CAAC,gBAAgB;AACtB,eAAG,MAAM,WAAW;AAAA,UACrB,CAAC,EACA,MAAM,CAAC,MAAM;AACb,mBAAO,MAAM,CAAC;AACd,mBAAO,MAAM,oBAAoB;AACjC,eAAG,CAAC;AAAA,UACL,CAAC;AAAA,QACH;AAAA,QACA,QAAQ,CAAC,MAAM,OAAO;AACrB,cAAI;AACH,eAAG,MAAM,IAAI,WAAW,IAAI,CAAC;AAAA,UAC9B,SAAS,GAAG;AACX;AAAA;AAAA,cAAuB;AAAA,YAAE;AACzB,mBAAO;AAAA;AAAA,cAAwB;AAAA,YAAE;AACjC,mBAAO,MAAM,4BAA4B,IAAI,EAAE;AAC/C,mBAAO,qBAAO;AAAA;AAAA,cAAyB;AAAA,YAAE,CAAC;AAC1C;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,MACA,CAAC,KAAK,QAAQ;AACb,YAAI,KAAK;AACR,iBAAO;AAAA;AAAA,YAAwB;AAAA,UAAI;AACnC,iBAAO,MAAM,gCAAgC,QAAQ,EAAE;AACvD,iBAAO,qBAAO,KAAK,GAAG,CAAC;AAAA,QACxB,OAAO;AACN,iBAAO,qBAAO;AAAA;AAAA,YAA6B;AAAA,UAAI,CAAC;AAAA,QACjD;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAC;AACF;;;AClDA,WAAsB;AACtB,IAAAC,kBAAoB;AAWb,IAAM,oBAAoB,CAChC,cACA,YACA,YACA,SACI;AAEJ,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,UAAU,GAAG;AACtD,QAAI,WAAW,WAAW,GAAG,GAAG;AAC/B,aAAO,WAAgB,aAAQ,WAAW,QAAQ,KAAK,KAAK,CAAC,CAAC;AAAA,IAC/D;AAAA,EACD;AAEA,MAAI,cAAc,UAAU,GAAG;AAC9B,WAAO,WAAgB,aAAa,aAAQ,YAAY,GAAG,UAAU,CAAC;AAAA,EACvE;AAEA,MAAI;AACH,WAAO,gBAAAC,QAAQ,KAAK,YAAY;AAAA,MAC/B,SAAc,aAAQ,YAAY;AAAA,MAClC,OAAO;AAAA,IACR,CAAC;AAAA,EACF,SAAS,GAAG;AACX,YAAQ;AAAA,MACP,4BAA4B,UAAU,SAAS,YAAY;AAAA,MAC3D;AAAA,IACD;AACA,WAAO;AAAA,EACR;AACD;;;ACzCA,IAAAC,QAAsB;AAOf,IAAM,iBAAiB,CAAC,cAAc,SAAS;AACrD,QAAM;AAAA;AAAA,IAAsC,CAAC;AAAA;AAC7C,QAAM,cAAc;AACpB,MAAI,cAAc,YAAY,KAAK,IAAI;AACvC,SAAO,eAAe,MAAM;AAC3B,UAAM,aAAa,YAAY,CAAC;AAChC,QAAI,CAAC,YAAY;AAChB,YAAM,IAAI,MAAM,+BAA+B;AAAA,IAChD;AACA,QAAI,cAAc,UAAU,GAAG;AAC9B,YAAM,iBAAiB;AAAA,QACjB,cAAa,cAAQ,YAAY,GAAG,UAAU;AAAA,MACpD;AACA,cAAQ,KAAK,cAAc;AAAA,IAC5B,OAAO;AACN,cAAQ,KAAK,UAAU;AAAA,IACxB;AACA,kBAAc,YAAY,KAAK,IAAI;AAAA,EACpC;AACA,SAAO;AACR;;;ACRO,IAAM,gBAAgB,OAC5B,cACA,SACA,YACA,MACA,QACI;AACJ,QAAM,QAAQ,CAAC,EAAE,cAAc,QAAQ,CAAC;AACxC,QAAM;AAAA;AAAA,IAEJ,oBAAI,IAAI;AAAA;AAEV,SAAO,MAAM,QAAQ;AACpB,UAAM,WAAW,MAAM,IAAI;AAC3B,cAAU,UAAU,qBAAqB;AACzC,UAAM,EAAE,cAAAC,eAAc,SAAAC,SAAQ,IAAI;AAElC,QAAI,QAAQ,IAAID,aAAY;AAAG;AAE/B,UAAM,cAAc,eAAeA,eAAcC,QAAO,EAAE;AAAA,MAAI,CAAC,UAC9D,kBAAkBD,eAAc,OAAO,YAAY,IAAI;AAAA,IACxD;AAEA,UAAM,cAAc;AACpB,UAAM,OAAO,YAAY,OAAO,CAACE,OAAM,eAAe;AACrD,cAAQ,IAAI,EAAE,WAAW,CAAC;AAC1B,YAAM,wBAAwB;AAAA,QAC7BF;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AACA,aAAOE,MAAK,QAAQ,aAAa,CAAC,OAAO,IAAI,IAAI,OAAO;AACvD,cAAM,eAAe;AAAA,UACpBF;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACA,YAAI,iBAAiB,YAAY;AAChC,iBAAO,GAAG,EAAE,GAAG,qBAAqB,GAAG,EAAE;AAAA,QAC1C,OAAO;AACN,iBAAO;AAAA,QACR;AAAA,MACD,CAAC;AAAA,IACF,GAAGC,QAAO;AAEV,YAAQ,IAAID,eAAc;AAAA,MACzB,IAAIA;AAAA,MACJ,SAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,CAAC;AAAA,IACf,CAAC;AAED,eAAW,cAAc,aAAa;AACrC,YAAM,wBAAwB;AAAA,QAC7BD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AACA,YAAM,aAAa,MAAM,IAAI,SAAS,uBAAuB,MAAM;AAEnE,YAAM,KAAK,EAAE,cAAc,uBAAuB,SAAS,WAAW,CAAC;AAAA,IACxE;AAAA,EACD;AAEA,aAAW,CAAC,GAAG,CAAC,KAAK,QAAQ,QAAQ,GAAG;AACvC,UAAM,EAAE,YAAY,IAAI;AACxB,MAAE,cAAc,CAAC;AACjB,gBAAY,QAAQ,CAAC,eAAe;AACnC,YAAM,aAAa,QAAQ,IAAI,UAAU;AACzC,gBAAU,YAAY,kBAAkB,UAAU,YAAY;AAC9D,QAAE,YAAY,KAAK,UAAU;AAAA,IAC9B,CAAC;AAAA,EACF;AAEA,QAAM,MAAM,QAAQ,IAAI,YAAY;AACpC,MAAI,CAAC,KAAK;AACT,UAAM,IAAI,MAAM,iBAAiB;AAAA,EAClC;AACA,SAAO;AACR;;;ACvGA,kBAAiB;AAYV,IAAM,cAAc,CAAC,UAAU;AACrC,SAAO,KAAK,MAAM,YAAAG,QAAK,QAAQ,KAAK,UAAU,KAAK,CAAC,CAAC;AACtD;;;ACZA,IAAAC,iBAAuB;AAyBhB,IAAM,kBAAkB,OAC9B,UACA,SACA,QACA,YACA,KACA,QACA,UACI;AACJ,QAAM,cAAc,MAAM;AAAA,IACzB;AAAA,IACA,MAAM,IACJ;AAAA,MACA,MAAM,sBAAO,WAAW,cAAc,UAAU,SAAS,KAAK,MAAM,CAAC;AAAA,MACrE;AAAA,IACD,EACC,KAAK,CAAC,SAAS;AACf,aAAO;AAAA,IACR,CAAC;AAAA,IACF,OAAO;AAAA,IACP,OAAO;AAAA,IACP;AAAA,EACD;AAKA,QAAM,UAAU,CAAC;AAEjB,QAAM,QAAQ,CAAC,WAAW;AAC1B,SAAO,MAAM,WAAW,GAAG;AAC1B,UAAM,IAAI,MAAM,IAAI;AACpB,cAAU,GAAG,qBAAqB;AAClC,QAAI,EAAE,MAAM,SAAS;AACpB;AAAA,IACD;AACA,YAAQ,EAAE,EAAE,IAAI;AAChB,eAAW,OAAO,EAAE,aAAa;AAChC,YAAM,KAAK,GAAG;AAAA,IACf;AAAA,EACD;AAEA,QAAM,UAAU,OAAO;AAAA,IACtB,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,IAAIC,OAAM,MAAM;AAC7C,aAAO;AAAA,QACN;AAAA,QACA;AAAA,UACC;AAAA;AAAA,YAEEA,QAAO;AAAA;AAAA,QACV;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AAEA,QAAM,cAAc;AAIpB,QAAM,QAAQ;AAAA,IACb,UAAU;AAAA,IACV;AAAA,IACA,UAAU;AAAA,MACT,iBAAiB;AAAA,QAChB,KAAK;AAAA,UACJ,KAAK,CAAC,OAAO,SAAS;AAAA,UACtB,GAAI,aAAa,EAAE,CAAC,WAAW,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC;AAAA,QAChD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAKA,QAAM,SAAS,OAAO,SAAS,YAAY,IAAI,OAAO,IACnD,MAAM,KAAK,YAAY,EAAE,IACzB,YAAY,KAAK;AAEpB,SAAO,MAAM,YAAY,IAAI,MAAM;AAEnC,QAAM,WAAW,QAAQ,QAAQ,OAAO,CAAC,EAAE,KAAK,MAAM,SAAS,SAAS;AACxE,QAAM,YAAY,QAAQ,QAAQ,UAAU,MAAM,UAAU,UAAU;AAEtE,MAAI,UAAU;AACb,WAAO,MAAM,qBAAqB;AAClC,WAAO;AAAA;AAAA,MAA0B,QAAQ;AAAA,IAAO;AAChD,UAAM,IAAI,MAAM,oBAAoB;AAAA,EACrC;AACA,MAAI,UAAU,QAAQ;AACrB,WAAO;AAAA;AAAA,MAAyB;AAAA,IAAS;AACzC,WAAO,KAAK,uBAAuB;AAAA,EACpC;AAEA,MAAI,YAAY;AACf,UAAM,OAAO,OAAO;AAAA,MACnB,OAAO,QAAQ,OAAO,OAAO,EAAE,IAAI,CAAC,CAAC,IAAI,MAAM,MAAM;AACpD,eAAO,CAAC,IAAI,OAAO,GAAG;AAAA,MACvB,CAAC;AAAA,IACF;AACA,WAAO;AAAA,MACN,WAAW,OAAO,UAAU,YAAY,EAAE;AAAA,MAC1C;AAAA;AAAA,QAA6B;AAAA;AAAA,MAC7B;AAAA;AAAA,QAA0B;AAAA;AAAA,MAC1B,WAAW;AAAA,MACX,YAAY;AAAA,IACb;AAAA,EACD;AACA,SAAO;AAAA,IACN,WAAW,OAAO,UAAU,YAAY,EAAE;AAAA,IAC1C;AAAA;AAAA,MAA6B;AAAA;AAAA,IAC7B;AAAA;AAAA,MAA0B;AAAA;AAAA,IAC1B,WAAW;AAAA,IACX,YAAY;AAAA,EACb;AACD;;;ACzIO,IAAM,mBAAmB,OAC/B,SACA,SACA,QACA,QACA,YACA,KACA,UACI;AACJ,MAAI,CAAC,QAAQ,SAAS,MAAM,GAAG;AAC9B,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACtC;AACA,QAAM,EAAE,WAAW,SAAS,MAAM,WAAW,WAAW,IACvD,MAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAED,MAAI,CAAC,WAAW;AACf,WAAO,MAAM,0BAA0B,OAAO,EAAE;AAChD,UAAM,IAAI,MAAM,oBAAoB;AAAA,EACrC;AAEA,SAAO;AAAA,IACN,WAAW,OAAO;AAAA,MACjB,OAAO,QAAQ,SAAS,EAAE,IAAI,CAAC,CAAC,cAAc,QAAQ,MAAM;AAC3D,eAAO;AAAA,UACN;AAAA,UACA,EAAE,cAAc,KAAK,SAAS,KAAK,SAAS,SAAS,QAAQ;AAAA,QAC9D;AAAA,MACD,CAAC;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;;;AC3BO,IAAM,oBAAoB,CAChC,cACA,SACA,YACA,MACA,QACI;AACJ,QAAM,QAAQ,CAAC,EAAE,cAAc,QAAQ,CAAC;AACxC,QAAM;AAAA;AAAA,IACL,oBAAI,IAAI;AAAA;AAGT,SAAO,MAAM,QAAQ;AACpB,UAAM,WAAW,MAAM,IAAI;AAC3B,cAAU,UAAU,qBAAqB;AACzC,UAAM,EAAE,cAAAC,eAAc,SAAAC,SAAQ,IAAI;AAElC,QAAI,QAAQ,IAAID,aAAY;AAAG;AAE/B,UAAM,cAAc,eAAeA,eAAcC,QAAO,EAAE;AAAA,MAAI,CAAC,UAC9D,kBAAkBD,eAAc,OAAO,YAAY,IAAI;AAAA,IACxD;AAEA,UAAM,cAAc;AACpB,UAAM,OAAO,YAAY,OAAO,CAACE,OAAM,eAAe;AACrD,YAAM,wBAAwB;AAAA,QAC7BF;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AACA,aAAOE,MAAK,QAAQ,aAAa,CAAC,OAAO,IAAI,IAAI,OAAO;AACvD,cAAM,eAAe;AAAA,UACpBF;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACA,YAAI,iBAAiB,YAAY;AAChC,iBAAO,GAAG,EAAE,GAAG,qBAAqB,GAAG,EAAE;AAAA,QAC1C,OAAO;AACN,iBAAO;AAAA,QACR;AAAA,MACD,CAAC;AAAA,IACF,GAAGC,QAAO;AAEV,YAAQ,IAAID,eAAc;AAAA,MACzB,IAAIA;AAAA,MACJ,SAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,CAAC;AAAA,IACf,CAAC;AAED,gBAAY,QAAQ,CAAC,eAAe;AACnC,YAAM,wBAAwB;AAAA,QAC7BD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AACA,YAAM,aAAa,IAAI,aAAa,uBAAuB,MAAM;AAEjE,YAAM,KAAK,EAAE,cAAc,uBAAuB,SAAS,WAAW,CAAC;AAAA,IACxE,CAAC;AAAA,EACF;AAEA,aAAW,CAAC,GAAG,CAAC,KAAK,QAAQ,QAAQ,GAAG;AACvC,UAAM,EAAE,YAAY,IAAI;AACxB,MAAE,cAAc,CAAC;AACjB,gBAAY,QAAQ,CAAC,eAAe;AACnC,YAAM,aAAa,QAAQ,IAAI,UAAU;AACzC,gBAAU,YAAY,kBAAkB,UAAU,YAAY;AAC9D,QAAE,YAAY,KAAK,UAAU;AAAA,IAC9B,CAAC;AAAA,EACF;AAEA;AAAA;AAAA,IACC,QAAQ,IAAI,YAAY;AAAA;AAE1B;;;AClGA,IAAAG,kBAAoB;AAyBb,SAAS,oBACf,UACA,SACA,QACA,YACA,KACA,QACA,OACC;AACD,QAAM,cAAc;AAAA,IACnB;AAAA,IACA,IAAI;AAAA,MACH,gBAAAC,QAAQ,KAAK,UAAU;AAAA,QACtB;AAAA,QACA,cAAc,CAAC,SAAS,IAAI,aAAa,MAAM,MAAM;AAAA,QACrD,QAAQ,IAAI;AAAA,MACb,CAAC;AAAA,MACD;AAAA,IACD;AAAA,IACA,OAAO;AAAA,IACP,OAAO;AAAA,IACP;AAAA,EACD;AAGA,QAAM,UAAU,CAAC;AAEjB,QAAM,QAAQ,CAAC,WAAW;AAC1B,SAAO,MAAM,WAAW,GAAG;AAC1B,UAAM,IAAI,MAAM,IAAI;AACpB,cAAU,GAAG,qBAAqB;AAClC,QAAI,EAAE,MAAM,SAAS;AACpB;AAAA,IACD;AACA,YAAQ,EAAE,EAAE,IAAI;AAChB,eAAW,OAAO,EAAE,aAAa;AAChC,YAAM,KAAK,GAAG;AAAA,IACf;AAAA,EACD;AAEA,QAAM,UAAU,OAAO;AAAA,IACtB,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,IAAIC,OAAM,MAAM;AAC7C,YAAM;AAAA;AAAA,QAEJA,QAAO;AAAA;AACT,aAAO,CAAC,IAAI,EAAE,SAAS,KAAK,CAAC;AAAA,IAC9B,CAAC;AAAA,EACF;AAKA,QAAM,YAAY;AAAA,IACjB,UAAU;AAAA,IACV;AAAA,IACA,UAAU;AAAA,MACT,iBAAiB;AAAA,QAChB,KAAK;AAAA,UACJ,KAAK,CAAC,OAAO,SAAS;AAAA,UACtB,GAAI,aAAa,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC;AAAA,QACrC;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAIA,QAAM,aAAa,OAAO,SAAS,YAAY,IAAI,OAAO,IACvD,MAAM,KAAK,YAAY,EAAE,IACpB,YAAY,SAAS;AAE7B,SAAO,MAAM,YAAY,IAAI,UAAU;AAEvC,QAAM,WAAW,YAAY,QAAQ,OAAO,CAAC,EAAE,KAAK,MAAM,SAAS,SAAS;AAC5E,QAAM,YAAY,YAAY,QAAQ,UAAU,MAAM,UAAU,UAAU;AAE1E,MAAI,UAAU;AACb,WAAO;AAAA,MAAM;AAAA;AAAA,MAA0C,YAAY;AAAA,IAAO;AAC1E,UAAM,IAAI,MAAM,oBAAoB;AAAA,EACrC;AACA,MAAI,UAAU,QAAQ;AACrB,WAAO;AAAA,MAAK;AAAA;AAAA,MAA4C,YAAY;AAAA,IAAO;AAAA,EAC5E;AAEA,MAAI,YAAY;AACf,UAAM,OAAO,OAAO;AAAA,MACnB,OAAO,QAAQ,WAAW,OAAO,EAAE,IAAI,CAAC,CAAC,IAAI,MAAM,MAAM;AACxD,eAAO,CAAC,IAAI,OAAO,GAAG;AAAA,MACvB,CAAC;AAAA,IACF;AACA,WAAO;AAAA,MACN,WAAW,WAAW,UAAU,YAAY,EAAE;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACA,SAAO;AAAA,IACN,WAAW,WAAW,UAAU,YAAY,EAAE;AAAA,IAC9C;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA;AAAA,EACD;AACD;;;AChIO,IAAM,uBAAuB,CACnC,SACA,SACA,QACA,QACA,YACA,KACA,UACI;AACJ,MAAI,CAAC,QAAQ,SAAS,MAAM,GAAG;AAC9B,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACtC;AACA,QAAM,EAAE,WAAW,SAAS,MAAM,WAAW,WAAW,IACvD;AAAA,IACC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAED,MAAI,CAAC,WAAW;AACf,WAAO,MAAM,0BAA0B,OAAO,EAAE;AAChD,UAAM,IAAI,MAAM,oBAAoB;AAAA,EACrC;AAEA,SAAO;AAAA,IACN,WAAW,OAAO;AAAA,MACjB,OAAO,QAAQ,SAAS,EAAE,IAAI,CAAC,CAAC,cAAc,QAAQ,MAAM;AAC3D,eAAO;AAAA,UACN;AAAA,UACA,EAAE,cAAc,KAAK,SAAS,KAAK,SAAS,SAAS,QAAQ;AAAA,QAC9D;AAAA,MACD,CAAC;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;;;ACzCA,IAAAC,eAAiB;AAKV,IAAM,UAAU,CAAC,QAAQ,QAAQ,KAAK,UAAU;AACtD,SAAO;AAAA,IACN,MAAM,QAAQ;AAAA,IACd;AAAA,IACA,YAAY,OAAO,YAAY,SAAS,eAAe;AACtD,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,WAAW,SAAS,KAAK,IACvD,MAAM;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,YAAI,WAAW;AACd,gBAAM,eAAe;AACrB,gBAAM,YAAY,gBAAgB,SAAS;AAC3C,iBAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA,MAAM,CAAC,cAAc,SAAS,EAAE,KAAK,IAAI;AAAA,YACzC;AAAA,UACD;AAAA,QACD;AACA,eAAO,EAAE,WAAW,YAAY,MAAM,IAAI,SAAS,KAAK;AAAA,MACzD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,oDAAoD;AACjE,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,gBAAgB,CAAC,YAAY,SAAS,eAAe;AACpD,UAAI;AACH,cAAM,EAAE,WAAW,SAAS,MAAM,WAAW,WAAW,IACvD;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,YAAI,WAAW;AACd,gBAAM,eAAe;AACrB,gBAAM,YAAY,gBAAgB,SAAS;AAC3C,iBAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,MAAM,CAAC,cAAc,SAAS,EAAE,KAAK,IAAI;AAAA,UAC1C;AAAA,QACD;AACA,eAAO,EAAE,SAAS,MAAM,IAAI,MAAM,WAAW,WAAW;AAAA,MACzD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,mDAAmD;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,qBAAqB,CAAC,YAAY,SAAS,eAAe;AACzD,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,oBAAoB,WAAW,MAAM,MAAM;AACxD,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,kDAAkD;AAC/D,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,iBAAiB,OAAO,YAAY,SAAS,eAAe;AAC3D,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD,MAAM;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,MAAM,gBAAgB,WAAW,MAAM,MAAM;AAC1D,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,kDAAkD;AAC/D,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,sBAAsB,CAAC,YAAY,SAAS,eAAe;AAC1D,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,oBAAoB,WAAW,OAAO,MAAM;AACzD,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,mDAAmD;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,kBAAkB,OAAO,YAAY,SAAS,eAAe;AAC5D,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD,MAAM;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,MAAM,gBAAgB,WAAW,OAAO,MAAM;AAC3D,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,mDAAmD;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,sBAAsB,CAAC,YAAY,SAAS,eAAe;AAC1D,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,oBAAoB,WAAW,OAAO,MAAM;AACzD,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO,MAAM,mDAAmD;AAChE,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,cAAM;AAAA,MACP;AAAA,IACD;AAAA,IACA,kBAAkB,OAAO,YAAY,SAAS,eAAe;AAC5D,UAAI;AACH,cAAM,EAAE,WAAW,YAAY,MAAM,WAAW,QAAQ,IACvD,MAAM;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AACD,cAAM,OAAO,MAAM,gBAAgB,WAAW,OAAO,MAAM;AAC3D,eAAO,EAAE,MAAM,SAAS,WAAW,YAAY,KAAK;AAAA,MACrD,SAAS,GAAG;AACX,eAAO;AAAA;AAAA,UAA0B;AAAA,QAAE;AACnC,eAAO,MAAM,mDAAmD;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACD;;;AC9LO,IAAM,cAAc,CAAC,WAAW;AAItC,QAAM,QAAQ,CAAC;AAEf,SAAO;AAAA,IACN,OAAO,CAAC,eAAe,sBAAsB;AAC5C,YAAM,aAAa,IAAI;AAAA,IACxB;AAAA,IACA,MAAM,CAAC,kBAAkB;AACxB,YAAM,MAAM,MAAM,aAAa;AAC/B,UAAI,CAAC,KAAK;AACT,cAAM,IAAI;AAAA,UACT,kBAAkB,aAAa;AAAA,QAChC;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAAA,IACA,UAAU,CAAC,eAAe,YAAY;AACrC,YAAM,qBAAqB,MAAM,aAAa;AAC9C,UAAI,CAAC,oBAAoB;AACxB,eAAO;AAAA,MACR;AACA,YAAM,EAAE,SAAS,gBAAgB,IAAI;AACrC,UAAI,OAAO,KAAK,OAAO,EAAE,WAAW,OAAO,KAAK,eAAe,EAAE,QAAQ;AACxE,eAAO;AAAA,MACR;AACA,iBAAW,CAAC,KAAK,SAAS,KAAK,OAAO,QAAQ,OAAO,GAAG;AACvD,cAAM,YAAY,gBAAgB,GAAG;AACrC,YAAI,CAAC,WAAW;AACf,iBAAO;AAAA,QACR;AACA,YAAI,EAAE,aAAa,cAAc,EAAE,aAAa,YAAY;AAC3D,iBAAO;AAAA,YACN;AAAA,UACD;AACA,iBAAO;AAAA,QACR;AACA,YAAI,UAAU,YAAY,UAAU,SAAS;AAC5C,iBAAO;AAAA,QACR;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAAA,EACD;AACD;;;AClDA,oBAA2B;AAC3B,oBAAwB;AACxB,gBAAyC;AACzC,sBAAyB;AACzB,oBAA8B;AAC9B,sBAA+B;AAC/B,iBAAkB;AAElB,IAAM,0BAA0B,aAC9B,KAAK,CAAC,QAAQ,SAAS,CAAC,EACxB,QAAQ,MAAM,EACd,SAAS,oCAAoC;AAM/C,IAAM,WAAW;AAAA,EAChB,MAAM;AACP;AAKO,IAAM,aAAa,CAAC,UAAU,CAAC,MAAM;AAI3C,MAAI;AAGJ,QAAM,uBAAuB,wBAAwB;AAAA,IACpD,QAAQ;AAAA,EACT;AACA,MAAI,CAAC,qBAAqB,SAAS;AAClC,UAAM,IAAI;AAAA,MACT,4BAA4B,QAAQ,QAAQ;AAAA,IAC7C;AAAA,EACD;AACA,QAAM,iBAAiB,qBAAqB;AAE5C,MAAI,mBAAmB,WAAW;AACjC,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AACA,QAAMC,WAAU,SAAS,cAAc;AAIvC,MAAI;AAKJ,QAAM,MAAM;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,QAAM,YAAY,YAAY,OAAO;AAErC,SAAO;AAAA,IACN,MAAM;AAAA,IACN,MAAM,aAAa;AAClB,mBAAS,2BAAQ,0BAAW,QAAQ,IAAI,CAAC,CAAC;AAC1C,uBAAiBA,SAAQ,QAAQ,SAAS,KAAK,SAAS;AACxD,WAAK,aAAa,iBAAiB;AAAA,IACpC;AAAA,IACA,MAAM,UAAU,IAAI,UAAUC,UAAS;AAGtC,UACC,GAAG,WAAW,aAAa,KAC3B,CAAC,UAAU,WAAW,QAAQ,IAAI,CAAC,KACnC,CAAC,UAAU,SAAS,cAAc,GACjC;AACD,gBAAQ,IAAI,EAAE,IAAI,UAAU,SAAAA,SAAQ,CAAC;AACrC,mBAAO,6BAAc,GAAG,QAAQ,IAAI,CAAC,GAAG,EAAE,QAAQ,aAAa;AAAA,MAChE;AACA,aAAO;AAAA,IACR;AAAA,IACA,MAAM,KAAK,IAAI;AACd,UAAI,CAAC,GAAG,SAAS,MAAM,GAAG;AACzB;AAAA,MACD;AACA,cAAI,sBAAW,GAAG,EAAE,KAAK,GAAG;AAC3B;AAAA,MACD;AACA,cAAI,sBAAW,GAAG,EAAE,OAAO,GAAG;AAC7B;AAAA,MACD;AACA,YAAM,EAAE,MAAM,QAAQ,IAAI,MAAM,eAAe;AAAA,QAC9C;AAAA,QACA,QAAQ,IAAI;AAAA,QACZ;AAAA,MACD;AACA,aAAO,OAAO,OAAO,EAAE,QAAQ,CAACC,YAAW;AAC1C,YAAIA,QAAO,GAAG,SAAS,cAAc,GAAG;AACvC;AAAA,QACD;AACA,aAAK,aAAaA,QAAO,EAAE;AAAA,MAC5B,CAAC;AACD,aAAO;AAAA,IACR;AAAA,IACA,GAAG,EAAE,SAAS,SAAS;AAAA,EACxB;AACD;AAEA,IAAM,oBAAgB,gCAAe,UAAU;AAKxC,IAAM;AAAA;AAAA;AAAA,EACQ,cAAc;AAAA;AAE5B,IAAM,oBAAoB,cAAc;AACxC,IAAM,qBAAqB,cAAc;AACzC,IAAM;AAAA;AAAA,EACZ,cAAc;AAAA;AAGR,IAAM,oBAAoB,cAAc;","names":["import_abitype","resolve","import_resolve","resolve","path","absolutePath","rawCode","code","solc","import_effect","module","absolutePath","rawCode","code","import_resolve","resolve","module","import_solc","bundler","options","module"]}